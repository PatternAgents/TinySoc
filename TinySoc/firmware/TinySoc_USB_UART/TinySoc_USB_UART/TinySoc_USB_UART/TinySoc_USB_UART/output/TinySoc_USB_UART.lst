FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY7C64215 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0108)     halt                           ;Stop execution if power falls too low
                                        (0109) 
                                        (0110)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0111)     // call	void_handler
0008: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0115)     // call	void_handler
000C: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   18h                      ;VC3 Interrupt Vector
                                        (0119)     // call	void_handler
0018: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0123)     // call	void_handler
001C: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 12 87 LJMP  _Counter8_1_ISR    (0127)     ljmp	_Counter8_1_ISR
0023: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0131)     // call	void_handler
0024: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 0F 2E LJMP  _UART_1_TX_ISR     (0135)     ljmp	_UART_1_TX_ISR
002B: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 0F 2F LJMP  _UART_1_RX_ISR     (0139)     ljmp	_UART_1_RX_ISR
002F: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   40h                      ;USB Reset Interrupt Vector
0040: 7D 17 62 LJMP  _USBUART_1_RESET_ISR(0143)     ljmp	_USBUART_1_RESET_ISR
0043: 7E       RETI                     (0144)     reti
                                        (0145) 
                                        (0146)     org   44h                      ;USB SOF Interrupt Vector
0044: 7D 17 87 LJMP  _USBUART_1_SOF_ISR (0147)     ljmp	_USBUART_1_SOF_ISR
0047: 7E       RETI                     (0148)     reti
                                        (0149) 
                                        (0150)     org   48h                      ;USB EP0 Interrupt Vector
0048: 7D 07 72 LJMP  _USBUART_1_EP0_ISR (0151)     ljmp	_USBUART_1_EP0_ISR
004B: 7E       RETI                     (0152)     reti
                                        (0153) 
                                        (0154)     org   4Ch                      ;USB EP1 Interrupt Vector
004C: 7D 17 52 LJMP  _USBUART_1_EP1_ISR (0155)     ljmp	_USBUART_1_EP1_ISR
004F: 7E       RETI                     (0156)     reti
                                        (0157) 
                                        (0158)     org   50h                      ;USB EP2 Interrupt Vector
0050: 7D 17 56 LJMP  _USBUART_1_EP2_ISR (0159)     ljmp	_USBUART_1_EP2_ISR
0053: 7E       RETI                     (0160)     reti
                                        (0161) 
                                        (0162)     org   54h                      ;USB EP3 Interrupt Vector
0054: 7D 17 5A LJMP  _USBUART_1_EP3_ISR (0163)     ljmp	_USBUART_1_EP3_ISR
0057: 7E       RETI                     (0164)     reti
                                        (0165) 
                                        (0166)     org   58h                      ;USB EP4 Interrupt Vector
0058: 7D 17 5E LJMP  _USBUART_1_EP4_ISR (0167)     ljmp	_USBUART_1_EP4_ISR
005B: 7E       RETI                     (0168)     reti
                                        (0169) 
                                        (0170)     org   5Ch                      ;USB Wakeup Interrupt Vector
005C: 7D 17 88 LJMP  _USBUART_1_WAKEUP_ISR(0171)     ljmp	_USBUART_1_WAKEUP_ISR
005F: 7E       RETI                     (0172)     reti
                                        (0173) 
                                        (0174)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0175)     // call	void_handler
0060: 7E       RETI                     (0176)     reti
                                        (0177) 
                                        (0178)     org   64h                      ;Sleep Timer Interrupt Vector
0064: 7D 11 8D LJMP  _SleepTimer_1_ISR  (0179)     ljmp	_SleepTimer_1_ISR
0067: 7E       RETI                     (0180)     reti
0068: 71 10    OR    F,0x10             
                                        (0181)     ;---------------------------------------------------
                                        (0182)     ; Insert your custom code above this banner
                                        (0183)     ;---------------------------------------------------
                                        (0184)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0185) 
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  Start of Execution.
                                        (0188) ;-----------------------------------------------------------------------------
                                        (0189) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0190) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0191) ;
                                        (0192) 
                                        (0193) IF	(TOOLCHAIN & HITECH)
                                        (0194)  	AREA PD_startup(CODE, REL, CON)
                                        (0195) ELSE
                                        (0196)     org 68h
                                        (0197) ENDIF
                                        (0198) __Start:
                                        (0199) 
                                        (0200)     ; initialize values for voltage stabilization, if required,
                                        (0201)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0202)     ; least for now. 
                                        (0203)     ;
                                        (0204)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0205)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 07 MOV   REG[0xE3],0x7      (0206)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0207)     M8C_SetBank0
                                        (0208) 
                                        (0209)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0210)     mov   A, 20h
0074: 28       ROMX                     (0211)     romx
0075: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0212)     ; %45%20%46%46% End workaround
                                        (0213) 
                                        (0214) M8C_ClearWDTAndSleep ; Clear WDT before enabling it    	
                                        (0215) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0216)     M8C_EnableWatchDog
                                        (0217) ENDIF
                                        (0218) 
0078: 41 FE FB AND   REG[0xFE],0xFB     (0219)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0220) 
                                        (0221)     ;---------------------------
                                        (0222)     ; Set up the Temporary stack
                                        (0223)     ;---------------------------
                                        (0224)     ; A temporary stack is set up for the SSC instructions.
                                        (0225)     ; The real stack start will be assigned later.
                                        (0226)     ;
                                        (0227) _stack_start:          equ 80h
007B: 50 80    MOV   A,0x80             (0228)     mov   A, _stack_start          ; Set top of stack to end of used RAM
007D: 4E       SWAP  SP,A               (0229)     swap  SP, A                    ; This is only temporary if going to LMM
007E: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0230) 
                                        (0231)     ;------------------------
                                        (0232)     ; Set Power-related Trim 
                                        (0233)     ;------------------------
                                        (0234) M8C_ClearWDTAndSleep ; Clear WDT before enabling it
                                        (0235) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0236) 
                                        (0237)   IF ( AGND_BYPASS )
                                        (0238)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0239)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0240)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0241)     ; value using the proper trim values.
                                        (0242)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0243)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0244)   ENDIF
                                        (0245) ELSE
                                        (0246) 	; 3.3V operation trim codes
                                        (0247) 	; Set the IMO and Bandgap trims for 3v operation
                                        (0248)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                        (0249) 	
                                        (0250) 	; Set the IMO Gain Trim for 3v operation
                                        (0251) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                        (0252) 
                                        (0253) ENDIF ; 3.3 Volt Operation
                                        (0254) 
0081: 55 F8 00 MOV   [VDD_ON+43],0x0    (0255)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [VDD_ON+44],0x0    (0256)     mov  [bSSC_KEYSP], 0
0087: 71 10    OR    F,0x10             
                                        (0257) 				
                                        (0258)     ;---------------------------------------
                                        (0259)     ; Initialize Crystal Oscillator and PLL
                                        (0260)     ;---------------------------------------
                                        (0261) 
                                        (0262)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0263)     M8C_SetBank1
0089: 62 E0 1A MOV   REG[0xE0],0x1A     (0264)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,0xEF             
008E: 62 E3 38 MOV   REG[0xE3],0x38     
0091: 62 D1 03 MOV   REG[0xD1],0x3      
                                        (0265)     M8C_SetBank0
                                        (0266)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0267) 
                                        (0268) 	;-------------------------------------------------------
                                        (0269)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0270)     ;-------------------------------------------------------
                                        (0271) 
                                        (0272)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0273) 
                                        (0274) IF (SYSCLK_SOURCE)
                                        (0275)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0276) ENDIF
                                        (0277)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0278) 	
                                        (0279) IF	(TOOLCHAIN & HITECH)
                                        (0280)     ;---------------------------------------------
                                        (0281)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0282)     ;---------------------------------------------
                                        (0283) 	global		__Lstackps
                                        (0284) 	mov     a,low __Lstackps
                                        (0285) 	swap    a,sp
                                        (0286) 
                                        (0287) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0288)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0289)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0290)     RAM_SETPAGE_CUR 0
                                        (0291)     RAM_SETPAGE_MVW 0
                                        (0292)     RAM_SETPAGE_MVR 0
                                        (0293)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0294)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0295)     ELSE
                                        (0296)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0297)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0298) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0299) ELSE
                                        (0300)     ;---------------------------------------------
                                        (0301)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0302)     ;---------------------------------------------
                                        (0303) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0304)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
0094: 50 00    MOV   A,0x0              (0305)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
0096: 4E       SWAP  SP,A               (0306)     swap  A, SP
0097: 62 D3 03 MOV   REG[0xD3],0x3      
009A: 62 D0 00 MOV   REG[0xD0],0x0      
009D: 62 D5 00 MOV   REG[0xD5],0x0      
00A0: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0307)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0308)     RAM_SETPAGE_CUR 0
                                        (0309)     RAM_SETPAGE_MVW 0
                                        (0310)     RAM_SETPAGE_MVR 0
                                        (0311) 
                                        (0312)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00A3: 71 C0    OR    F,0xC0             (0313)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0314)   ELSE
                                        (0315)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0316)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0317) ELSE
                                        (0318)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0319)     swap  SP, A
                                        (0320) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0321) ENDIF ;	TOOLCHAIN
                                        (0322) 
                                        (0323)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0324)     ;---------------------------------------------------
                                        (0325)     ; Insert your custom code below this banner
                                        (0326)     ;---------------------------------------------------
                                        (0327) 
                                        (0328)     ;---------------------------------------------------
                                        (0329)     ; Insert your custom code above this banner
                                        (0330)     ;---------------------------------------------------
                                        (0331)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0332) 
                                        (0333)     ;-------------------------
                                        (0334)     ; Load Base Configuration
                                        (0335)     ;-------------------------
                                        (0336)     ; Load global parameter settings and load the user modules in the
                                        (0337)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0338)     ; to minimize start up time; (2) We may still need to play with the
                                        (0339)     ; Sleep Timer.
                                        (0340)     ;
00A5: 7C 04 49 LCALL 0x0449             (0341)     lcall LoadConfigInit
00A8: 71 10    OR    F,0x10             
                                        (0342) 	M8C_SetBank1
00AA: 41 E7 3F AND   REG[0xE7],0x3F     (0343) 	and  reg[DEC_CR1], 0x3F
00AD: 43 E7 80 OR    REG[0xE7],0x80     (0344) 	or   reg[DEC_CR1], 0x80
00B0: 70 EF    AND   F,0xEF             
                                        (0345) 	M8C_SetBank0
                                        (0346)     ;-----------------------------------
                                        (0347)     ; Initialize C Run-Time Environment
                                        (0348)     ;-----------------------------------
                                        (0349) IF ( C_LANGUAGE_SUPPORT )
                                        (0350) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0351)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0352)     mov  [__r0],<__bss_start
                                        (0353) BssLoop:
                                        (0354)     cmp  [__r0],<__bss_end
                                        (0355)     jz   BssDone
                                        (0356)     mvi  [__r0],A
                                        (0357)     jmp  BssLoop
                                        (0358) BssDone:
                                        (0359)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0360)     mov  X,<__idata_start
                                        (0361)     mov  [__r0],<__data_start
                                        (0362) IDataLoop:
                                        (0363)     cmp  [__r0],<__data_end
                                        (0364)     jz   C_RTE_Done
                                        (0365)     push A
                                        (0366)     romx
                                        (0367)     mvi  [__r0],A
                                        (0368)     pop  A
                                        (0369)     inc  X
                                        (0370)     adc  A,0
                                        (0371)     jmp  IDataLoop
                                        (0372) 
                                        (0373) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0374) 
                                        (0375) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B2: 62 D0 00 MOV   REG[0xD0],0x0      (0376)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0377)                                        ; to use the Virtual Register page.
                                        (0378) 
                                        (0379)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0380)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0381)     ; text segment and may have been relocated by the Code Compressor.
                                        (0382)     ;
00B5: 50 03    MOV   A,0x3              (0383)     mov   A, >__pXIData                ; Get the address of the flash
00B7: 57 62    MOV   X,0x62             (0384)     mov   X, <__pXIData                ;   pointer to the xidata area.
00B9: 08       PUSH  A                  (0385)     push  A
00BA: 28       ROMX                     (0386)     romx                               ; get the MSB of xidata's address
00BB: 53 C1    MOV   [__r0],A           (0387)     mov   [__r0], A
00BD: 18       POP   A                  (0388)     pop   A
00BE: 75       INC   X                  (0389)     inc   X
00BF: 09 00    ADC   A,0x0              (0390)     adc   A, 0
00C1: 28       ROMX                     (0391)     romx                               ; get the LSB of xidata's address
00C2: 4B       SWAP  A,X                (0392)     swap  A, X
00C3: 51 C1    MOV   A,[__r0]           (0393)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0394)                                        ;   XIData structure list in flash
00C5: 80 04    JMP   0x00CA             (0395)     jmp   .AccessStruct
                                        (0396) 
                                        (0397)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0398)     ; values of C variables. Each structure contains 3 member elements.
                                        (0399)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0400)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0401)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0402)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0403)     ; value in the second member element, an unsigned byte:
                                        (0404)     ; (1) If the value of the second element is non-zero, it represents
                                        (0405)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0406)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0407)     ; the bytes are copied to the block of RAM.
                                        (0408)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0409)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0410)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0411) 
                                        (0412) .AccessNextStructLoop:
00C7: 75       INC   X                  (0413)     inc   X                            ; pXIData++
00C8: 09 00    ADC   A,0x0              (0414)     adc   A, 0
00CA: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0415) .AccessStruct:                         ; Entry point for first block
                                        (0416)     ;
                                        (0417)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0418)     ;
                                        (0419)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CD: 08       PUSH  A                  (0420)     push  A
00CE: 28       ROMX                     (0421)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00CF: 60 D5    MOV   REG[0xD5],A        (0422)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D1: 74       INC   A                  (0423)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D2: A0 4B    JZ    0x011E             (0424)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D4: 18       POP   A                  (0425)     pop   A                            ; restore pXIData to [A,X]
00D5: 75       INC   X                  (0426)     inc   X                            ; pXIData++
00D6: 09 00    ADC   A,0x0              (0427)     adc   A, 0
00D8: 08       PUSH  A                  (0428)     push  A
00D9: 28       ROMX                     (0429)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00DA: 53 C1    MOV   [__r0],A           (0430)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00DC: 18       POP   A                  (0431)     pop   A                            ; restore pXIData to [A,X]
00DD: 75       INC   X                  (0432)     inc   X                            ; pXIData++ (point to size)
00DE: 09 00    ADC   A,0x0              (0433)     adc   A, 0
00E0: 08       PUSH  A                  (0434)     push  A
00E1: 28       ROMX                     (0435)     romx                               ; Get the size (CPU.A <- *pXIData)
00E2: A0 1C    JZ    0x00FF             (0436)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E4: 53 C0    MOV   [__r1],A           (0437)     mov   [__r1], A                    ;             else downcount in __r1
00E6: 18       POP   A                  (0438)     pop   A                            ; restore pXIData to [A,X]
                                        (0439) 
                                        (0440) .CopyNextByteLoop:
                                        (0441)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0442)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0443)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0444)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0445)     ;
00E7: 75       INC   X                  (0446)     inc   X                            ; pXIData++ (point to next data byte)
00E8: 09 00    ADC   A,0x0              (0447)     adc   A, 0
00EA: 08       PUSH  A                  (0448)     push  A
00EB: 28       ROMX                     (0449)     romx                               ; Get the data value (CPU.A <- *pXIData)
00EC: 3F C1    MVI   [__r0],A           (0450)     mvi   [__r0], A                    ; Transfer the data to RAM
00EE: 47 C1 FF TST   [__r0],0xFF        (0451)     tst   [__r0], 0xff                 ; Check for page crossing
00F1: B0 06    JNZ   0x00F8             (0452)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F3: 5D D5    MOV   A,REG[0xD5]        (0453)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F5: 74       INC   A                  (0454)     inc   A
00F6: 60 D5    MOV   REG[0xD5],A        (0455)     mov   reg[ MVW_PP], A
                                        (0456) .CopyLoopTail:
00F8: 18       POP   A                  (0457)     pop   A                            ; restore pXIData to [A,X]
00F9: 7A C0    DEC   [__r1]             (0458)     dec   [__r1]                       ; End of this array in flash?
00FB: BF EB    JNZ   0x00E7             (0459)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FD: 8F C9    JMP   0x00C7             (0460)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0461) 
                                        (0462) .ClearRAMBlockToZero:
00FF: 18       POP   A                  (0463)     pop   A                            ; restore pXIData to [A,X]
0100: 75       INC   X                  (0464)     inc   X                            ; pXIData++ (point to next data byte)
0101: 09 00    ADC   A,0x0              (0465)     adc   A, 0
0103: 08       PUSH  A                  (0466)     push  A
0104: 28       ROMX                     (0467)     romx                               ; Get the run length (CPU.A <- *pXIData)
0105: 53 C0    MOV   [__r1],A           (0468)     mov   [__r1], A                    ; Initialize downcounter
0107: 50 00    MOV   A,0x0              (0469)     mov   A, 0                         ; Initialize source data
                                        (0470) 
                                        (0471) .ClearRAMBlockLoop:
                                        (0472)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0473)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0474)     ;
0109: 3F C1    MVI   [__r0],A           (0475)     mvi   [__r0], A                    ; Clear a byte
010B: 47 C1 FF TST   [__r0],0xFF        (0476)     tst   [__r0], 0xff                 ; Check for page crossing
010E: B0 08    JNZ   0x0117             (0477)     jnz   .ClearLoopTail               ;   No crossing, keep going
0110: 5D D5    MOV   A,REG[0xD5]        (0478)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0112: 74       INC   A                  (0479)     inc   A
0113: 60 D5    MOV   REG[0xD5],A        (0480)     mov   reg[ MVW_PP], A
0115: 50 00    MOV   A,0x0              (0481)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0482) .ClearLoopTail:
0117: 7A C0    DEC   [__r1]             (0483)     dec   [__r1]                       ; Was this the last byte?
0119: BF EF    JNZ   0x0109             (0484)     jnz   .ClearRAMBlockLoop           ;   No,  continue
011B: 18       POP   A                  (0485)     pop   A                            ;   Yes, restore pXIData to [A,X] and
011C: 8F AA    JMP   0x00C7             (0486)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0487) 
                                        (0488) .C_RTE_WrapUp:
011E: 18       POP   A                  (0489)     pop   A                            ; balance stack
011F: 71 10    OR    F,0x10             
                                        (0490) 
                                        (0491) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0492) 
                                        (0493) C_RTE_Done:
                                        (0494) 
                                        (0495) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0496) 
                                        (0497) 
                                        (0498)     ;-------------------------------
                                        (0499)     ; Set Power-On Reset (POR) Level
                                        (0500)     ;-------------------------------
                                        (0501)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0502)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0503)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0504)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0505)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0506) 
                                        (0507)     M8C_SetBank1
                                        (0508) 
                                        (0509) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                        (0510)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                        (0511) ELSE										   ; 5V Operation
                                        (0512)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
0121: 43 E3 00 OR    REG[0xE3],0x0      (0513)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
0124: 70 EF    AND   F,0xEF             
                                        (0514)   ELSE ; 24HMz                                 ;
                                        (0515)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0516)   ENDIF ; 24MHz
                                        (0517) ENDIF ; 3.3V Operation
                                        (0518) 
                                        (0519)     M8C_SetBank0
                                        (0520) 
                                        (0521)     ;----------------------------
                                        (0522)     ; Wrap up and invoke "main"
                                        (0523)     ;----------------------------
                                        (0524) 
                                        (0525)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0526)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0527)     ;
0126: 62 E0 00 MOV   REG[0xE0],0x0      (0528)     mov  reg[INT_MSK0],0
0129: 71 10    OR    F,0x10             
                                        (0529) 
                                        (0530)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0531)     ;
                                        (0532)     M8C_SetBank1
012B: 62 E0 19 MOV   REG[0xE0],0x19     (0533)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012E: 70 EF    AND   F,0xEF             
                                        (0534)     M8C_SetBank0
                                        (0535) 
                                        (0536)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0537)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0538)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0539)     ;
0130: 62 E2 00 MOV   REG[0xE2],0x0      (0540)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0541)                                    ; have been set during the boot process.
                                        (0542) IF	(TOOLCHAIN & HITECH)
                                        (0543) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0544) ELSE
                                        (0545) IF ENABLE_LJMP_TO_MAIN
                                        (0546)     ljmp  _main                    ; goto main (no return)
                                        (0547) ELSE
0133: 7C 12 D2 LCALL __UserModules_end|__text_start|_main|_main(0548)     lcall _main                    ; call main
                                        (0549) .Exit:
0136: 8F FF    JMP   0x0136             (0550)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0551) ENDIF
                                        (0552) ENDIF ; TOOLCHAIN
                                        (0553) 
                                        (0554)     ;---------------------------------
                                        (0555)     ; Library Access to Global Parms
                                        (0556)     ;---------------------------------
                                        (0557)     ;
                                        (0558)  bGetPowerSetting:
                                        (0559) _bGetPowerSetting:
                                        (0560)     ; Returns value of POWER_SETTING in the A register.
                                        (0561)     ; No inputs. No Side Effects.
                                        (0562)     ;
0138: 50 10    MOV   A,0x10             (0563)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
013A: 7F       RET                      (0564)     ret
                                        (0565) 
                                        (0566) IF	(TOOLCHAIN & HITECH)
                                        (0567) ELSE
                                        (0568)     ;---------------------------------
                                        (0569)     ; Order Critical RAM & ROM AREAs
                                        (0570)     ;---------------------------------
                                        (0571)     ;  'TOP' is all that has been defined so far...
                                        (0572) 
                                        (0573)     ;  ROM AREAs for C CONST, static & global items
                                        (0574)     ;
                                        (0575)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0576)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0577) __idata_start:
                                        (0578) 
                                        (0579)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0580) __func_lit_start:
                                        (0581) 
                                        (0582) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0583)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0584)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0585)     ; relocated by the code compressor, but the text area may shrink and
                                        (0586)     ; that moves xidata around.
                                        (0587)     ;
                                        (0588) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0589) ENDIF
                                        (0590) 
                                        (0591)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0592)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0593) 
                                        (0594)     ; CODE segment for general use
                                        (0595)     ;
                                        (0596)     AREA text (ROM, REL, CON)
                                        (0597) __text_start:
                                        (0598) 
                                        (0599)     ; RAM area usage
                                        (0600)     ;
                                        (0601)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0602) __data_start:
                                        (0603) 
                                        (0604)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0605)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0606)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0607) __bss_start:
                                        (0608) 
                                        (0609) ENDIF ; TOOLCHAIN
                                        (0610) 
                                        (0611) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.2946
0364: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_USB_Radon_Tiny_Bank1
                                        (0019) export LoadConfigTBL_USB_Radon_Tiny_Bank0
                                        (0020) export LoadConfigTBL_USB_Radon_Tiny_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_USB_Radon_Tiny_Bank0:
                                        (0023) ;  Instance name Counter8_1, User Module Counter8
                                        (0024) ;       Instance name Counter8_1, Block Name CNTR8(DBB00)
                                        (0025) 	db		23h, 00h		;Counter8_1_CONTROL_REG(DBB00CR0)
                                        (0026) 	db		21h, 67h		;Counter8_1_PERIOD_REG(DBB00DR1)
                                        (0027) 	db		22h, 34h		;Counter8_1_COMPARE_REG(DBB00DR2)
                                        (0028) ;  Instance name LED_1, User Module LED
                                        (0029) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0030) ;  Instance name UART_1, User Module UART
                                        (0031) ;       Instance name UART_1, Block Name RX(DCB03)
                                        (0032) 	db		2fh, 00h		;UART_1_RX_CONTROL_REG(DCB03CR0)
                                        (0033) 	db		2dh, 00h		;UART_1_(DCB03DR1)
                                        (0034) 	db		2eh, 00h		;UART_1_RX_BUFFER_REG (DCB03DR2)
                                        (0035) ;       Instance name UART_1, Block Name TX(DCB02)
                                        (0036) 	db		2bh, 00h		;UART_1_TX_CONTROL_REG(DCB02CR0)
                                        (0037) 	db		29h, 00h		;UART_1_TX_BUFFER_REG (DCB02DR1)
                                        (0038) 	db		2ah, 00h		;UART_1_(DCB02DR2)
                                        (0039) ;  Instance name USBUART_1, User Module USBUART
                                        (0040) ;  Global Register values Bank 0
                                        (0041) 	db		60h, 09h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0042) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0043) 	db		61h, 00h		; AnalogMuxBusConfig register (AMUXCFG)
                                        (0044) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0045) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0046) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0047) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0048) 	db		56h, 00h		; Endpoint0Control register (EP0_CR)
                                        (0049) 	db		57h, 00h		; Endpoint0Count register (EP0_CNT)
                                        (0050) 	db		58h, 00h		; Endpoint0Data0 register (EP0_DR0)
                                        (0051) 	db		59h, 00h		; Endpoint0Data1 register (EP0_DR1)
                                        (0052) 	db		5ah, 00h		; Endpoint0Data2 register (EP0_DR2)
                                        (0053) 	db		5bh, 00h		; Endpoint0Data3 register (EP0_DR3)
                                        (0054) 	db		5ch, 00h		; Endpoint0Data4 register (EP0_DR4)
                                        (0055) 	db		5dh, 00h		; Endpoint0Data5 register (EP0_DR5)
                                        (0056) 	db		5eh, 00h		; Endpoint0Data6 register (EP0_DR6)
                                        (0057) 	db		5fh, 00h		; Endpoint0Data7 register (EP0_DR7)
                                        (0058) 	db		4fh, 00h		; Endpoint1Count0 register (EP1_CNT)
                                        (0059) 	db		4eh, 00h		; Endpoint1Count1 register (EP1_CNT1)
                                        (0060) 	db		51h, 00h		; Endpoint2Count0 register (EP2_CNT)
                                        (0061) 	db		50h, 00h		; Endpoint2Count1 register (EP2_CNT1)
                                        (0062) 	db		53h, 00h		; Endpoint3Count0 register (EP3_CNT)
                                        (0063) 	db		52h, 00h		; Endpoint3Count1 register (EP3_CNT1)
                                        (0064) 	db		55h, 00h		; Endpoint4Count0 register (EP4_CNT)
                                        (0065) 	db		54h, 00h		; Endpoint4Count1 register (EP4_CNT1)
                                        (0066) 	db		d6h, 00h		; I2CConfig register (I2CCFG)
                                        (0067) 	db		b0h, c0h		; Row_0_InputMux register (RDI0RI)
                                        (0068) 	db		b1h, 08h		; Row_0_InputSync register (RDI0SYN)
                                        (0069) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0070) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0071) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0072) 	db		b5h, 80h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0073) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0074) 	db		4ah, 00h		; USBControl_0 register (USB_CR0)
                                        (0075) 	db		4bh, 00h		; USBIOControl_0 register (USBIO_CR0)
                                        (0076) 	db		4ch, 00h		; USBIOControl_1 register (USBIO_CR1)
                                        (0077) 	db		ffh
                                        (0078) LoadConfigTBL_USB_Radon_Tiny_Bank1:
                                        (0079) ;  Instance name Counter8_1, User Module Counter8
                                        (0080) ;       Instance name Counter8_1, Block Name CNTR8(DBB00)
                                        (0081) 	db		20h, 61h		;Counter8_1_FUNC_REG(DBB00FN)
                                        (0082) 	db		21h, 14h		;Counter8_1_INPUT_REG(DBB00IN)
                                        (0083) 	db		22h, 00h		;Counter8_1_OUTPUT_REG(DBB00OU)
                                        (0084) ;  Instance name LED_1, User Module LED
                                        (0085) ;  Instance name SleepTimer_1, User Module SleepTimer
                                        (0086) ;  Instance name UART_1, User Module UART
                                        (0087) ;       Instance name UART_1, Block Name RX(DCB03)
                                        (0088) 	db		2ch, 05h		;UART_1_RX_FUNC_REG   (DCB03FN)
                                        (0089) 	db		2dh, f2h		;UART_1_RX_INPUT_REG  (DCB03IN)
                                        (0090) 	db		2eh, 40h		;UART_1_RX_OUTPUT_REG (DCB03OU)
                                        (0091) ;       Instance name UART_1, Block Name TX(DCB02)
                                        (0092) 	db		28h, 1dh		;UART_1_TX_FUNC_REG   (DCB02FN)
                                        (0093) 	db		29h, 02h		;UART_1_TX_INPUT_REG  (DCB02IN)
                                        (0094) 	db		2ah, 45h		;UART_1_TX_OUTPUT_REG (DCB02OU)
                                        (0095) ;  Instance name USBUART_1, User Module USBUART
                                        (0096) ;  Global Register values Bank 1
                                        (0097) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0098) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0099) 	db		60h, 01h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0100) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0101) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0102) 	db		68h, 00h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0103) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0104) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0105) 	db		64h, 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
                                        (0106) 	db		65h, 00h		; ComparatorGlobalOutEn1 register (CMP_GO_EN1)
                                        (0107) 	db		fdh, 80h		; DAC_Control register (DAC_CR)
                                        (0108) 	db		c4h, 00h		; Endpoint1Control register (EP1_CR)
                                        (0109) 	db		c5h, 00h		; Endpoint2Control register (EP2_CR)
                                        (0110) 	db		c6h, 00h		; Endpoint3Control register (EP3_CR)
                                        (0111) 	db		c7h, 00h		; Endpoint4Control register (EP4_CR)
                                        (0112) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0113) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0114) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0115) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0116) 	db		e1h, 19h		; OscillatorControl_1 register (OSC_CR1)
                                        (0117) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0118) 	db		dfh, feh		; OscillatorControl_3 register (OSC_CR3)
                                        (0119) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0120) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0121) 	db		d8h, 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
                                        (0122) 	db		d9h, 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
                                        (0123) 	db		dah, 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
                                        (0124) 	db		dbh, 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
                                        (0125) 	db		ech, 00h		; Port_4_MUXBusCtrl register (MUX_CR4)
                                        (0126) 	db		edh, 00h		; Port_5_MUXBusCtrl register (MUX_CR5)
                                        (0127) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0128) 	db		c1h, 00h		; USBControl_1 register (USB_CR1)
                                        (0129) 	db		ffh
                                        (0130) AREA psoc_config(rom, rel)
                                        (0131) LoadConfigTBL_USB_Radon_Tiny_Ordered:
                                        (0132) ;  Ordered Global Register values
                                        (0133) 	M8C_SetBank0
0366: 62 00 00 MOV   REG[0x0],0x0       (0134) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
0369: 71 10    OR    F,0x10             
                                        (0135) 	M8C_SetBank1
036B: 62 00 00 MOV   REG[0x0],0x0       (0136) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
036E: 62 01 FF MOV   REG[0x1],0xFF      (0137) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
0371: 70 EF    AND   F,0xEF             
                                        (0138) 	M8C_SetBank0
0373: 62 03 FF MOV   REG[0x3],0xFF      (0139) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
0376: 62 02 00 MOV   REG[0x2],0x0       (0140) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
0379: 71 10    OR    F,0x10             
                                        (0141) 	M8C_SetBank1
037B: 62 02 00 MOV   REG[0x2],0x0       (0142) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
037E: 62 03 00 MOV   REG[0x3],0x0       (0143) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
0381: 70 EF    AND   F,0xEF             
                                        (0144) 	M8C_SetBank0
0383: 62 01 00 MOV   REG[0x1],0x0       (0145) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
0386: 62 04 00 MOV   REG[0x4],0x0       (0146) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
0389: 71 10    OR    F,0x10             
                                        (0147) 	M8C_SetBank1
038B: 62 04 28 MOV   REG[0x4],0x28      (0148) 	mov	reg[04h], 28h		; Port_1_DriveMode_0 register (PRT1DM0)
038E: 62 05 D7 MOV   REG[0x5],0xD7      (0149) 	mov	reg[05h], d7h		; Port_1_DriveMode_1 register (PRT1DM1)
0391: 70 EF    AND   F,0xEF             
                                        (0150) 	M8C_SetBank0
0393: 62 07 57 MOV   REG[0x7],0x57      (0151) 	mov	reg[07h], 57h		; Port_1_DriveMode_2 register (PRT1DM2)
0396: 62 06 A0 MOV   REG[0x6],0xA0      (0152) 	mov	reg[06h], a0h		; Port_1_GlobalSelect register (PRT1GS)
0399: 71 10    OR    F,0x10             
                                        (0153) 	M8C_SetBank1
039B: 62 06 00 MOV   REG[0x6],0x0       (0154) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
039E: 62 07 00 MOV   REG[0x7],0x0       (0155) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
03A1: 70 EF    AND   F,0xEF             
                                        (0156) 	M8C_SetBank0
03A3: 62 05 00 MOV   REG[0x5],0x0       (0157) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
03A6: 62 08 00 MOV   REG[0x8],0x0       (0158) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
03A9: 71 10    OR    F,0x10             
                                        (0159) 	M8C_SetBank1
03AB: 62 08 00 MOV   REG[0x8],0x0       (0160) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
03AE: 62 09 3F MOV   REG[0x9],0x3F      (0161) 	mov	reg[09h], 3fh		; Port_2_DriveMode_1 register (PRT2DM1)
03B1: 70 EF    AND   F,0xEF             
                                        (0162) 	M8C_SetBank0
03B3: 62 0B 3F MOV   REG[0xB],0x3F      (0163) 	mov	reg[0bh], 3fh		; Port_2_DriveMode_2 register (PRT2DM2)
03B6: 62 0A 00 MOV   REG[0xA],0x0       (0164) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
03B9: 71 10    OR    F,0x10             
                                        (0165) 	M8C_SetBank1
03BB: 62 0A 00 MOV   REG[0xA],0x0       (0166) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
03BE: 62 0B 00 MOV   REG[0xB],0x0       (0167) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
03C1: 70 EF    AND   F,0xEF             
                                        (0168) 	M8C_SetBank0
03C3: 62 09 00 MOV   REG[0x9],0x0       (0169) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
03C6: 62 0C 00 MOV   REG[0xC],0x0       (0170) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
03C9: 71 10    OR    F,0x10             
                                        (0171) 	M8C_SetBank1
03CB: 62 0C 00 MOV   REG[0xC],0x0       (0172) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
03CE: 62 0D 00 MOV   REG[0xD],0x0       (0173) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
03D1: 70 EF    AND   F,0xEF             
                                        (0174) 	M8C_SetBank0
03D3: 62 0F 00 MOV   REG[0xF],0x0       (0175) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
03D6: 62 0E 00 MOV   REG[0xE],0x0       (0176) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
03D9: 71 10    OR    F,0x10             
                                        (0177) 	M8C_SetBank1
03DB: 62 0E 00 MOV   REG[0xE],0x0       (0178) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
03DE: 62 0F 00 MOV   REG[0xF],0x0       (0179) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
03E1: 70 EF    AND   F,0xEF             
                                        (0180) 	M8C_SetBank0
03E3: 62 0D 00 MOV   REG[0xD],0x0       (0181) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
03E6: 62 10 00 MOV   REG[0x10],0x0      (0182) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
03E9: 71 10    OR    F,0x10             
                                        (0183) 	M8C_SetBank1
03EB: 62 10 00 MOV   REG[0x10],0x0      (0184) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
03EE: 62 11 00 MOV   REG[0x11],0x0      (0185) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
03F1: 70 EF    AND   F,0xEF             
                                        (0186) 	M8C_SetBank0
03F3: 62 13 00 MOV   REG[0x13],0x0      (0187) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
03F6: 62 12 00 MOV   REG[0x12],0x0      (0188) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
03F9: 71 10    OR    F,0x10             
                                        (0189) 	M8C_SetBank1
03FB: 62 12 00 MOV   REG[0x12],0x0      (0190) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
03FE: 62 13 00 MOV   REG[0x13],0x0      (0191) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0401: 70 EF    AND   F,0xEF             
                                        (0192) 	M8C_SetBank0
0403: 62 11 00 MOV   REG[0x11],0x0      (0193) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0406: 62 14 00 MOV   REG[0x14],0x0      (0194) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0409: 71 10    OR    F,0x10             
                                        (0195) 	M8C_SetBank1
040B: 62 14 00 MOV   REG[0x14],0x0      (0196) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
040E: 62 15 00 MOV   REG[0x15],0x0      (0197) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0411: 70 EF    AND   F,0xEF             
                                        (0198) 	M8C_SetBank0
0413: 62 17 00 MOV   REG[0x17],0x0      (0199) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
0416: 62 16 00 MOV   REG[0x16],0x0      (0200) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0419: 71 10    OR    F,0x10             
                                        (0201) 	M8C_SetBank1
041B: 62 16 00 MOV   REG[0x16],0x0      (0202) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
041E: 62 17 00 MOV   REG[0x17],0x0      (0203) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0421: 70 EF    AND   F,0xEF             
                                        (0204) 	M8C_SetBank0
0423: 62 15 00 MOV   REG[0x15],0x0      (0205) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0426: 62 1C 00 MOV   REG[0x1C],0x0      (0206) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
0429: 71 10    OR    F,0x10             
                                        (0207) 	M8C_SetBank1
042B: 62 1C 00 MOV   REG[0x1C],0x0      (0208) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
042E: 62 1D 00 MOV   REG[0x1D],0x0      (0209) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0431: 70 EF    AND   F,0xEF             
                                        (0210) 	M8C_SetBank0
0433: 62 1F 00 MOV   REG[0x1F],0x0      (0211) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
0436: 62 1E 00 MOV   REG[0x1E],0x0      (0212) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0439: 71 10    OR    F,0x10             
                                        (0213) 	M8C_SetBank1
043B: 62 1E 00 MOV   REG[0x1E],0x0      (0214) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
043E: 62 1F 00 MOV   REG[0x1F],0x0      (0215) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0441: 70 EF    AND   F,0xEF             
                                        (0216) 	M8C_SetBank0
0443: 62 1D 00 MOV   REG[0x1D],0x0      (0217) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
0446: 70 EF    AND   F,0xEF             
                                        (0218) 	M8C_SetBank0
0448: 7F       RET                      (0219) 	ret
                                        (0220) 
                                        (0221) 
                                        (0222) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_USB_Radon_Tiny
                                        (0026) export _LoadConfig_USB_Radon_Tiny
                                        (0027) export Port_1_Data_SHADE
                                        (0028) export _Port_1_Data_SHADE
                                        (0029) 
                                        (0030) 
                                        (0031) export NO_SHADOW
                                        (0032) export _NO_SHADOW
                                        (0033) 
                                        (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0036) 
                                        (0037) AREA psoc_config(rom, rel)
                                        (0038) 
                                        (0039) ;---------------------------------------------------------------------------
                                        (0040) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0041) ;                  parameters handled by boot code, like CPU speed). This
                                        (0042) ;                  function can be called from user code, but typically it
                                        (0043) ;                  is only called from boot.
                                        (0044) ;
                                        (0045) ;       INPUTS: None.
                                        (0046) ;      RETURNS: Nothing.
                                        (0047) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0048) ;               In the large memory model currently only the page
                                        (0049) ;               pointer registers listed below are modified.  This does
                                        (0050) ;               not guarantee that in future implementations of this
                                        (0051) ;               function other page pointer registers will not be
                                        (0052) ;               modified.
                                        (0053) ;          
                                        (0054) ;               Page Pointer Registers Modified: 
                                        (0055) ;               CUR_PP
                                        (0056) ;
                                        (0057) _LoadConfigInit:
                                        (0058)  LoadConfigInit:
                                        (0059)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0060)     
0449: 55 43 00 MOV   [0x43],0x0         (0061) 	mov		[Port_1_Data_SHADE], 0h
                                        (0062) 
044C: 7C 04 53 LCALL 0x0453             (0063) 	lcall	LoadConfig_USB_Radon_Tiny
044F: 7C 03 64 LCALL 0x0364             (0064) 	lcall	LoadConfigTBL_USB_Radon_Tiny_Ordered
                                        (0065) 
                                        (0066) 
                                        (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
0452: 7F       RET                      (0068)     ret
                                        (0069) 
                                        (0070) ;---------------------------------------------------------------------------
                                        (0071) ; Load Configuration USB_Radon_Tiny
                                        (0072) ;
                                        (0073) ;    Load configuration registers for USB_Radon_Tiny.
                                        (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0075) ;
                                        (0076) ;       INPUTS: None.
                                        (0077) ;      RETURNS: Nothing.
                                        (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0079) ;               modified as may the Page Pointer registers!
                                        (0080) ;               In the large memory model currently only the page
                                        (0081) ;               pointer registers listed below are modified.  This does
                                        (0082) ;               not guarantee that in future implementations of this
                                        (0083) ;               function other page pointer registers will not be
                                        (0084) ;               modified.
                                        (0085) ;          
                                        (0086) ;               Page Pointer Registers Modified: 
                                        (0087) ;               CUR_PP
                                        (0088) ;
                                        (0089) _LoadConfig_USB_Radon_Tiny:
                                        (0090)  LoadConfig_USB_Radon_Tiny:
                                        (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0092) 
0453: 10       PUSH  X                  (0093) 	push	x
0454: 70 EF    AND   F,0xEF             
                                        (0094)     M8C_SetBank0                    ; Force bank 0
0456: 50 00    MOV   A,0x0              (0095)     mov     a, 0                    ; Specify bank 0
0458: 67       ASR   A                  (0096)     asr     a                       ; Store in carry flag
                                        (0097)                                     ; Load bank 0 table:
0459: 50 02    MOV   A,0x2              (0098)     mov     A, >LoadConfigTBL_USB_Radon_Tiny_Bank0
045B: 57 B4    MOV   X,0xB4             (0099)     mov     X, <LoadConfigTBL_USB_Radon_Tiny_Bank0
045D: 7C 04 6E LCALL 0x046E             (0100)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0101) 
0460: 50 01    MOV   A,0x1              (0102)     mov     a, 1                    ; Specify bank 1
0462: 67       ASR   A                  (0103)     asr     a                       ; Store in carry flag
                                        (0104)                                     ; Load bank 1 table:
0463: 50 03    MOV   A,0x3              (0105)     mov     A, >LoadConfigTBL_USB_Radon_Tiny_Bank1
0465: 57 0F    MOV   X,0xF              (0106)     mov     X, <LoadConfigTBL_USB_Radon_Tiny_Bank1
0467: 7C 04 6E LCALL 0x046E             (0107)     lcall   LoadConfig              ; Load the bank 1 values
046A: 70 EF    AND   F,0xEF             
                                        (0108) 
                                        (0109)     M8C_SetBank0                    ; Force return to bank 0
046C: 20       POP   X                  (0110) 	pop		x
                                        (0111) 
                                        (0112)     RAM_EPILOGUE RAM_USE_CLASS_4
046D: 7F       RET                      (0113)     ret
                                        (0114) 
                                        (0115) 
                                        (0116) 
                                        (0117) 
                                        (0118) ;---------------------------------------------------------------------------
                                        (0119) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0120) ;              pairs. Terminate on address=0xFF.
                                        (0121) ;
                                        (0122) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0123) ;           Flag Register Carry bit encodes the Register Bank
                                        (0124) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0125) ;
                                        (0126) ;  RETURNS: nothing.
                                        (0127) ;
                                        (0128) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0129) ;                X-3 Temporary store for register address
                                        (0130) ;                X-2 LSB of config table address
                                        (0131) ;                X-1 MSB of config table address
                                        (0132) ;
                                        (0133) LoadConfig:
                                        (0134)     RAM_PROLOGUE RAM_USE_CLASS_2
046E: 38 02    ADD   SP,0x2             (0135)     add     SP, 2                   ; Set up local vars
0470: 10       PUSH  X                  (0136)     push    X                       ; Save config table address on stack
0471: 08       PUSH  A                  (0137)     push    A
0472: 4F       MOV   X,SP               (0138)     mov     X, SP
0473: 56 FC 00 MOV   [X-4],0x0          (0139)     mov     [X-4], 0                ; Set default Destination to Bank 0
0476: D0 04    JNC   0x047B             (0140)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
0478: 56 FC 01 MOV   [X-4],0x1          (0141)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0142) .BankSelectSaved:
047B: 18       POP   A                  (0143)     pop     A
047C: 20       POP   X                  (0144)     pop     X
047D: 70 EF    AND   F,0xEF             
047F: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0145) 
                                        (0146) LoadConfigLp:
                                        (0147)     M8C_SetBank0                    ; Switch to bank 0
                                        (0148)     M8C_ClearWDT                    ; Clear the watchdog for long inits
0482: 10       PUSH  X                  (0149)     push    X                       ; Preserve the config table address
0483: 08       PUSH  A                  (0150)     push    A
0484: 28       ROMX                     (0151)     romx                            ; Load register address from table
0485: 39 FF    CMP   A,0xFF             (0152)     cmp     A, END_CONFIG_TABLE     ; End of table?
0487: A0 1F    JZ    0x04A7             (0153)     jz      EndLoadConfig           ;   Yes, go wrap it up
0489: 4F       MOV   X,SP               (0154)     mov     X, SP                   ;
048A: 48 FC 01 TST   [X-4],0x1          (0155)     tst     [X-4], 1                ; Loading IO Bank 1?
048D: A0 03    JZ    0x0491             (0156)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
048F: 71 10    OR    F,0x10             
                                        (0157)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0158) .IOBankNowSet:
0491: 54 FD    MOV   [X-3],A            (0159)     mov     [X-3], A                ; Stash the register address
0493: 18       POP   A                  (0160)     pop     A                       ; Retrieve the table address
0494: 20       POP   X                  (0161)     pop     X
0495: 75       INC   X                  (0162)     inc     X                       ; Advance to the data byte
0496: 09 00    ADC   A,0x0              (0163)     adc     A, 0
0498: 10       PUSH  X                  (0164)     push    X                       ; Save the config table address again
0499: 08       PUSH  A                  (0165)     push    A
049A: 28       ROMX                     (0166)     romx                            ; load config data from the table
049B: 4F       MOV   X,SP               (0167)     mov     X, SP                   ; retrieve the register address
049C: 59 FD    MOV   X,[X-3]            (0168)     mov     X, [X-3]
049E: 61 00    MOV   REG[X+0x0],A       (0169)     mov     reg[X], A               ; Configure the register
04A0: 18       POP   A                  (0170)     pop     A                       ; retrieve the table address
04A1: 20       POP   X                  (0171)     pop     X
04A2: 75       INC   X                  (0172)     inc     X                       ; advance to next table entry
04A3: 09 00    ADC   A,0x0              (0173)     adc     A, 0
04A5: 8F D7    JMP   0x047D             (0174)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0175) EndLoadConfig:
04A7: 38 FC    ADD   SP,0xFC            (0176)     add     SP, -4
04A9: 70 3F    AND   F,0x3F             
04AB: 71 C0    OR    F,0xC0             
                                        (0177)     RAM_EPILOGUE RAM_USE_CLASS_2
04AD: 7F       RET                      (0178)     ret
                                        (0179) 
                                        (0180) AREA InterruptRAM(ram, rel)
                                        (0181) 
                                        (0182) NO_SHADOW:
                                        (0183) _NO_SHADOW:
                                        (0184) ; write only register shadows
                                        (0185) _Port_1_Data_SHADE:
                                        (0186) Port_1_Data_SHADE:	BLK	1
                                        (0187) 
FILE: lib\usbuart_1_std.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_std.asm
                                        (0004) ;;  Version: 1.60, Updated on 2013/5/19 at 10:44:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "USBUART_1_macros.inc"
                                        (0024) include "USBUART_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Constant Data Allocation
                                        (0028) ;-----------------------------------------------
                                        (0029) AREA UserModules (ROM, REL)
                                        (0030) 
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ;  FUNCTION NAME: USBUART_1_Not_Supported
                                        (0033) ;
                                        (0034) ;  DESCRIPTION:
                                        (0035) ;
                                        (0036) ;-----------------------------------------------------------------------------
                                        (0037) ;
                                        (0038) ;  ARGUMENTS:
                                        (0039) ;
                                        (0040) ;  RETURNS:
                                        (0041) ;
                                        (0042) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0043) ;
                                        (0044) ;  THEORY of OPERATION or PROCEDURE:
                                        (0045) ;
                                        (0046) ;-----------------------------------------------------------------------------
                                        (0047) 
                                        (0048) ; d2h_std_dev
                                        (0049) IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0050) export  USBUART_1_CB_d2h_std_dev_00
                                        (0051) USBUART_1_CB_d2h_std_dev_00:
                                        (0052) ENDIF
                                        (0053) IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0054) export  USBUART_1_CB_d2h_std_dev_01
                                        (0055) USBUART_1_CB_d2h_std_dev_01:
                                        (0056) ENDIF
                                        (0057) IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0058) export  USBUART_1_CB_d2h_std_dev_02
                                        (0059) USBUART_1_CB_d2h_std_dev_02:
                                        (0060) ENDIF
                                        (0061) IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0062) export  USBUART_1_CB_d2h_std_dev_03
                                        (0063) USBUART_1_CB_d2h_std_dev_03:
                                        (0064) ENDIF
                                        (0065) IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0066) export  USBUART_1_CB_d2h_std_dev_04
                                        (0067) USBUART_1_CB_d2h_std_dev_04:
                                        (0068) ENDIF
                                        (0069) IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0070) export  USBUART_1_CB_d2h_std_dev_05
                                        (0071) USBUART_1_CB_d2h_std_dev_05:
                                        (0072) ENDIF
                                        (0073) IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0074) export  USBUART_1_CB_d2h_std_dev_06
                                        (0075) USBUART_1_CB_d2h_std_dev_06:
                                        (0076) ENDIF
                                        (0077) IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0078) export  USBUART_1_CB_d2h_std_dev_07
                                        (0079) USBUART_1_CB_d2h_std_dev_07:
                                        (0080) ENDIF
                                        (0081) IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0082) export  USBUART_1_CB_d2h_std_dev_08
                                        (0083) USBUART_1_CB_d2h_std_dev_08:
                                        (0084) ENDIF
                                        (0085) 
                                        (0086) ; h2d_std_dev
                                        (0087) IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0088) export  USBUART_1_CB_h2d_std_dev_00
                                        (0089) USBUART_1_CB_h2d_std_dev_00:
                                        (0090) ENDIF
                                        (0091) IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0092) export  USBUART_1_CB_h2d_std_dev_01
                                        (0093) USBUART_1_CB_h2d_std_dev_01:
                                        (0094) ENDIF
                                        (0095) IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0096) export  USBUART_1_CB_h2d_std_dev_02
                                        (0097) USBUART_1_CB_h2d_std_dev_02:
                                        (0098) ENDIF
                                        (0099) IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0100) export  USBUART_1_CB_h2d_std_dev_03
                                        (0101) USBUART_1_CB_h2d_std_dev_03:
                                        (0102) ENDIF
                                        (0103) IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0104) export  USBUART_1_CB_h2d_std_dev_04
                                        (0105) USBUART_1_CB_h2d_std_dev_04:
                                        (0106) ENDIF
                                        (0107) IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0108) export  USBUART_1_CB_h2d_std_dev_05
                                        (0109) USBUART_1_CB_h2d_std_dev_05:
                                        (0110) ENDIF
                                        (0111) IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0112) export  USBUART_1_CB_h2d_std_dev_06
                                        (0113) USBUART_1_CB_h2d_std_dev_06:
                                        (0114) ENDIF
                                        (0115) IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0116) export  USBUART_1_CB_h2d_std_dev_07
                                        (0117) USBUART_1_CB_h2d_std_dev_07:
                                        (0118) ENDIF
                                        (0119) IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0120) export  USBUART_1_CB_h2d_std_dev_08
                                        (0121) USBUART_1_CB_h2d_std_dev_08:
                                        (0122) ENDIF
                                        (0123) IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                                        (0124) export  USBUART_1_CB_h2d_std_dev_09
                                        (0125) USBUART_1_CB_h2d_std_dev_09:
                                        (0126) ENDIF
                                        (0127) 
                                        (0128) ; d2h_std_ifc
                                        (0129) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0130) export  USBUART_1_CB_d2h_std_ifc_00
                                        (0131) USBUART_1_CB_d2h_std_ifc_00:
                                        (0132) ENDIF
                                        (0133) IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                                        (0134) export  USBUART_1_CB_d2h_std_ifc_01
                                        (0135) USBUART_1_CB_d2h_std_ifc_01:
                                        (0136) ENDIF
                                        (0137) IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                                        (0138) export  USBUART_1_CB_d2h_std_ifc_02
                                        (0139) USBUART_1_CB_d2h_std_ifc_02:
                                        (0140) ENDIF
                                        (0141) IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                                        (0142) export  USBUART_1_CB_d2h_std_ifc_03
                                        (0143) USBUART_1_CB_d2h_std_ifc_03:
                                        (0144) ENDIF
                                        (0145) IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                                        (0146) export  USBUART_1_CB_d2h_std_ifc_04
                                        (0147) USBUART_1_CB_d2h_std_ifc_04:
                                        (0148) ENDIF
                                        (0149) IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                                        (0150) export  USBUART_1_CB_d2h_std_ifc_05
                                        (0151) USBUART_1_CB_d2h_std_ifc_05:
                                        (0152) ENDIF
                                        (0153) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                                        (0154) export  USBUART_1_CB_d2h_std_ifc_06
                                        (0155) USBUART_1_CB_d2h_std_ifc_06:
                                        (0156) ENDIF
                                        (0157) IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                                        (0158) export  USBUART_1_CB_d2h_std_ifc_07
                                        (0159) USBUART_1_CB_d2h_std_ifc_07:
                                        (0160) ENDIF
                                        (0161) IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                                        (0162) export  USBUART_1_CB_d2h_std_ifc_08
                                        (0163) USBUART_1_CB_d2h_std_ifc_08:
                                        (0164) ENDIF
                                        (0165) IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                                        (0166) export  USBUART_1_CB_d2h_std_ifc_09
                                        (0167) USBUART_1_CB_d2h_std_ifc_09:
                                        (0168) ENDIF
                                        (0169) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                                        (0170) export  USBUART_1_CB_d2h_std_ifc_10
                                        (0171) USBUART_1_CB_d2h_std_ifc_10:
                                        (0172) ENDIF
                                        (0173) 
                                        (0174) ; d2h_std_ifc
                                        (0175) IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0176) export  USBUART_1_CB_h2d_std_ifc_00
                                        (0177) USBUART_1_CB_h2d_std_ifc_00:
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) ; d2h_std_ep
                                        (0181) IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0182) export  USBUART_1_CB_d2h_std_ep_00
                                        (0183) USBUART_1_CB_d2h_std_ep_00:
                                        (0184) ENDIF
                                        (0185) 
                                        (0186) ; h2d_std_ep
                                        (0187) IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0188) export  USBUART_1_CB_h2d_std_ep_00
                                        (0189) USBUART_1_CB_h2d_std_ep_00:
                                        (0190) ENDIF
                                        (0191) IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                                        (0192) export  USBUART_1_CB_h2d_std_ep_01
                                        (0193) USBUART_1_CB_h2d_std_ep_01:
                                        (0194) ENDIF
                                        (0195) IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                                        (0196) export  USBUART_1_CB_h2d_std_ep_02
                                        (0197) USBUART_1_CB_h2d_std_ep_02:
                                        (0198) ENDIF
                                        (0199) IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                                        (0200) export  USBUART_1_CB_h2d_std_ep_03
                                        (0201) USBUART_1_CB_h2d_std_ep_03:
                                        (0202) ENDIF
                                        (0203) 
                                        (0204) export  USBUART_1_Not_Supported
                                        (0205) export _USBUART_1_Not_Supported
                                        (0206) USBUART_1_Not_Supported:
                                        (0207) _USBUART_1_Not_Supported:
04AE: 50 00    MOV   A,0x0              (0208)    MOV    A, 0                         ; Count 0
04B0: 57 03    MOV   X,0x3              (0209)    MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
04B2: 7D 07 9A LJMP  USBUART_1_EP0_UPD_MODE_EXIT(0210)    LJMP   USBUART_1_EP0_UPD_MODE_EXIT
                                        (0211) ;-----------------------------------------------------------------------------
                                        (0212) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_dev_00
                                        (0213) ;
                                        (0214) ;  DESCRIPTION:   Get Device Status
                                        (0215) ;
                                        (0216) ;****************************************************************
                                        (0217) ; STANDARD DEVICE IN REQUEST: Get_Device_Status
                                        (0218) ;****************************************************************
                                        (0219) ;
                                        (0220) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0221) ; bRequest       : GET_STATUS                     = 00h
                                        (0222) ; wValue         : RESERVED                       = 0000h
                                        (0223) ; wIndex         : RESERVED                       = 0000h
                                        (0224) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                        (0225) ;
                                        (0226) ; The GET_DEVICE_STATUS request returns the current device status.
                                        (0227) ;
                                        (0228) ;****************************************************************
                                        (0229) ;-----------------------------------------------------------------------------
                                        (0230) ;
                                        (0231) ;  ARGUMENTS:
                                        (0232) ;
                                        (0233) ;  RETURNS:
                                        (0234) ;
                                        (0235) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION or PROCEDURE:
                                        (0238) ;
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                                        (0241) .LITERAL
                                        (0242) GetStatusTransferDescrTable:
                                        (0243)     TD_START_TABLE 1                   ; One entry
                                        (0244)     TD_ENTRY    USB_DS_RAM, 2, USBUART_1_TransferBuffer, NULL_PTR  ; Intermediate Buffer
                                        (0245) .ENDLITERAL
                                        (0246) export  USBUART_1_CB_d2h_std_dev_00
                                        (0247) USBUART_1_CB_d2h_std_dev_00:
04BE: 55 1F 00 MOV   [0x1F],0x0         (0248)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
                                        (0249) 
04C1: 55 0D 00 MOV   [0xD],0x0          (0250)     MOV     [USBUART_1_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
04C4: 5F 0C 02 MOV   [0xC],[0x2]        (0251)     MOV     [USBUART_1_TransferBuffer], [USBUART_1_DeviceStatus]
                                        (0252) 
04C7: 50 04    MOV   A,0x4              (0253)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
04C9: 57 B5    MOV   X,0xB5             (0254)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
04CB: 80 C1    JMP   0x058D             (0255)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0256) ENDIF
                                        (0257) 
                                        (0258) ;-----------------------------------------------------------------------------
                                        (0259) ;  USB 2nd Tier Dispatch Jump Tables for Standard Requests (based on bRequest)
                                        (0260) ;-----------------------------------------------------------------------------
                                        (0261) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                        (0262) ;
                                        (0263) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                        (0264) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                        (0265) ;
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267) ;
                                        (0268) ;  ARGUMENTS:
                                        (0269) ;
                                        (0270) ;  RETURNS:
                                        (0271) ;
                                        (0272) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0273) ;
                                        (0274) ;  THEORY of OPERATION or PROCEDURE:
                                        (0275) ;
                                        (0276) ;-----------------------------------------------------------------------------
                                        (0277) USBUART_1_DT_d2h_std_dev:
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) 
04CD: 8F F0    JMP   USBUART_1_CB_d2h_std_dev_00(0280)     jmp     USBUART_1_CB_d2h_std_dev_00
04CF: 8F DE    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0281)     jmp     USBUART_1_CB_d2h_std_dev_01
04D1: 8F DC    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0282)     jmp     USBUART_1_CB_d2h_std_dev_02
04D3: 8F DA    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0283)     jmp     USBUART_1_CB_d2h_std_dev_03
04D5: 8F D8    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0284)     jmp     USBUART_1_CB_d2h_std_dev_04
04D7: 8F D6    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0285)     jmp     USBUART_1_CB_d2h_std_dev_05
04D9: 80 B9    JMP   USBUART_1_CB_d2h_std_dev_06(0286)     jmp     USBUART_1_CB_d2h_std_dev_06
04DB: 8F D2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0287)     jmp     USBUART_1_CB_d2h_std_dev_07
04DD: 81 13    JMP   USBUART_1_CB_d2h_std_dev_08(0288)     jmp     USBUART_1_CB_d2h_std_dev_08
                                        (0289) 
                                        (0290) USBUART_1_DT_d2h_std_dev_End:
                                        (0291) USBUART_1_DT_d2h_std_dev_Size: equ (USBUART_1_DT_d2h_std_dev_End-USBUART_1_DT_d2h_std_dev) / 2
                                        (0292) USBUART_1_DT_d2h_std_dev_Dispatch::
04DF: 5D 59    MOV   A,REG[0x59]        (0293)     MOV    A, REG[USBUART_1_EP0DATA + bRequest]
04E1: 39 09    CMP   A,0x9              
04E3: D0 04    JNC   0x04E8             
04E5: 64       ASL   A                  
04E6: EF E6    JACC  0x04CD             
04E8: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0294)     DISPATCHER USBUART_1_DT_d2h_std_dev, USBUART_1_DT_d2h_std_dev_Size, USBUART_1_Not_Supported
                                        (0295) 
                                        (0296) ;-----------------------------------------------------------------------------
                                        (0297) USBUART_1_DT_h2d_std_dev:
                                        (0298) ;-----------------------------------------------------------------------------
                                        (0299) 
04EB: 8F C2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0300)     jmp     USBUART_1_CB_h2d_std_dev_00
04ED: 81 0C    JMP   USBUART_1_CB_h2d_std_dev_01(0301)     jmp     USBUART_1_CB_h2d_std_dev_01
04EF: 8F BE    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0302)     jmp     USBUART_1_CB_h2d_std_dev_02
04F1: 81 13    JMP   USBUART_1_CB_h2d_std_dev_03(0303)     jmp     USBUART_1_CB_h2d_std_dev_03
04F3: 8F BA    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0304)     jmp     USBUART_1_CB_h2d_std_dev_04
04F5: 81 24    JMP   USBUART_1_CB_h2d_std_dev_05(0305)     jmp     USBUART_1_CB_h2d_std_dev_05
04F7: 8F B6    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0306)     jmp     USBUART_1_CB_h2d_std_dev_06
04F9: 8F B4    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0307)     jmp     USBUART_1_CB_h2d_std_dev_07
04FB: 8F B2    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0308)     jmp     USBUART_1_CB_h2d_std_dev_08
04FD: 81 25    JMP   USBUART_1_CB_h2d_std_dev_09(0309)     jmp     USBUART_1_CB_h2d_std_dev_09
                                        (0310) 
                                        (0311) USBUART_1_DT_h2d_std_dev_End:
                                        (0312) USBUART_1_DT_h2d_std_dev_Size: equ (USBUART_1_DT_h2d_std_dev_End-USBUART_1_DT_h2d_std_dev) / 2
                                        (0313) USBUART_1_DT_h2d_std_dev_Dispatch::
                                        (0314) 
04FF: 5D 59    MOV   A,REG[0x59]        (0315)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
0501: 39 0A    CMP   A,0xA              
0503: D0 04    JNC   0x0508             
0505: 64       ASL   A                  
0506: EF E4    JACC  0x04EB             
0508: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0316)     DISPATCHER USBUART_1_DT_h2d_std_dev, USBUART_1_DT_h2d_std_dev_Size, USBUART_1_Not_Supported
                                        (0317) 
                                        (0318) 
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) USBUART_1_DT_d2h_std_ifc:
                                        (0321) ;-----------------------------------------------------------------------------
                                        (0322) 
050B: 81 71    JMP   USBUART_1_CB_d2h_std_ifc_00(0323)     jmp     USBUART_1_CB_d2h_std_ifc_00
050D: 8F A0    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0324)     jmp     USBUART_1_CB_d2h_std_ifc_01
050F: 8F 9E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0325)     jmp     USBUART_1_CB_d2h_std_ifc_02
0511: 8F 9C    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0326)     jmp     USBUART_1_CB_d2h_std_ifc_03
0513: 8F 9A    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0327)     jmp     USBUART_1_CB_d2h_std_ifc_04
0515: 8F 98    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0328)     jmp     USBUART_1_CB_d2h_std_ifc_05
0517: 8F 96    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0329)     jmp     USBUART_1_CB_d2h_std_ifc_06
0519: 8F 94    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0330)     jmp     USBUART_1_CB_d2h_std_ifc_07
051B: 8F 92    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0331)     jmp     USBUART_1_CB_d2h_std_ifc_08
051D: 8F 90    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0332)     jmp     USBUART_1_CB_d2h_std_ifc_09
051F: 81 75    JMP   USBUART_1_CB_d2h_std_ifc_10(0333)     jmp     USBUART_1_CB_d2h_std_ifc_10
                                        (0334) 
                                        (0335) USBUART_1_DT_d2h_std_ifc_End:
                                        (0336) USBUART_1_DT_d2h_std_ifc_Size: equ (USBUART_1_DT_d2h_std_ifc_End-USBUART_1_DT_d2h_std_ifc) / 2
                                        (0337) USBUART_1_DT_d2h_std_ifc_Dispatch::
0521: 3C 01 00 CMP   [0x1],0x0          (0338)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
0524: B0 03    JNZ   0x0528             (0339)     JNZ     .configured                ; Jump on configured
0526: 8F 87    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0340)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0341) ; Jump here if the device is configured
                                        (0342) .configured:
0528: 5D 59    MOV   A,REG[0x59]        (0343)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
052A: 39 0B    CMP   A,0xB              
052C: D0 04    JNC   0x0531             
052E: 64       ASL   A                  
052F: EF DB    JACC  0x050B             
0531: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0344)     DISPATCHER USBUART_1_DT_d2h_std_ifc, USBUART_1_DT_d2h_std_ifc_Size, USBUART_1_Not_Supported
                                        (0345) 
                                        (0346) ;-----------------------------------------------------------------------------
                                        (0347) USBUART_1_DT_h2d_std_ifc:
                                        (0348) ;-----------------------------------------------------------------------------
                                        (0349) 
0534: 8F 79    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0350)     jmp     USBUART_1_CB_h2d_std_ifc_00
                                        (0351) 
                                        (0352) USBUART_1_DT_h2d_std_ifc_End:
                                        (0353) USBUART_1_DT_h2d_std_ifc_Size: equ (USBUART_1_DT_h2d_std_ifc_End-USBUART_1_DT_h2d_std_ifc) / 2
                                        (0354) USBUART_1_DT_h2d_std_ifc_Dispatch::
0536: 3C 01 00 CMP   [0x1],0x0          (0355)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
0539: B0 03    JNZ   0x053D             (0356)     JNZ     .configured                ; Jump on configured
053B: 8F 72    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0357)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0358) ; Jump here if the device is configured
                                        (0359) .configured:
053D: 5D 59    MOV   A,REG[0x59]        (0360)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
053F: 39 01    CMP   A,0x1              
0541: D0 04    JNC   0x0546             
0543: 64       ASL   A                  
0544: EF EF    JACC  0x0534             
0546: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0361)     DISPATCHER USBUART_1_DT_h2d_std_ifc, USBUART_1_DT_h2d_std_ifc_Size, USBUART_1_Not_Supported
                                        (0362) 
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) USBUART_1_DT_d2h_std_ep:
                                        (0365) ;-----------------------------------------------------------------------------
0549: 81 5F    JMP   USBUART_1_CB_d2h_std_ep_00(0366)     jmp     USBUART_1_CB_d2h_std_ep_00
                                        (0367) 
                                        (0368) USBUART_1_DT_d2h_std_ep_End:
                                        (0369) USBUART_1_DT_d2h_std_ep_Size: equ (USBUART_1_DT_d2h_std_ep_End-USBUART_1_DT_d2h_std_ep) / 2
                                        (0370) USBUART_1_DT_d2h_std_ep_Dispatch::
054B: 3C 01 00 CMP   [0x1],0x0          (0371)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
054E: B0 0D    JNZ   0x055C             (0372)     JNZ     .configured                ; Jump on configured
                                        (0373) 
0550: 5D 5D    MOV   A,REG[0x5D]        (0374)     MOV     A, REG[USBUART_1_EP0DATA + wIndexHi] ; Is the request for EP0?
0552: 53 1F    MOV   [0x1F],A           (0375)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
0554: 5D 5C    MOV   A,REG[0x5C]        (0376)     MOV     A, REG[USBUART_1_EP0DATA + wIndexLo] ;
0556: 2C 1F    OR    [0x1F],A           (0377)     OR      [USBUART_1_t2], A          ; Use the UM temp var--Selector
0558: A0 03    JZ    0x055C             (0378)     JZ      .ep0_request
                                        (0379) 
055A: 8F 53    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0380)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0381) ; Jump here if the device is configured or EP0 request
                                        (0382) .configured:
                                        (0383) .ep0_request:
055C: 5D 59    MOV   A,REG[0x59]        (0384)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
055E: 39 01    CMP   A,0x1              
0560: D0 04    JNC   0x0565             
0562: 64       ASL   A                  
0563: EF E5    JACC  0x0549             
0565: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0385)     DISPATCHER USBUART_1_DT_d2h_std_ep, USBUART_1_DT_d2h_std_ep_Size, USBUART_1_Not_Supported
                                        (0386) 
                                        (0387) 
                                        (0388) ;-----------------------------------------------------------------------------
                                        (0389) USBUART_1_DT_h2d_std_ep:
                                        (0390) ;-----------------------------------------------------------------------------
0568: 8F 45    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0391)     jmp     USBUART_1_CB_h2d_std_ep_00
056A: 81 57    JMP   USBUART_1_CB_h2d_std_ep_01(0392)     jmp     USBUART_1_CB_h2d_std_ep_01
056C: 8F 41    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0393)     jmp     USBUART_1_CB_h2d_std_ep_02
056E: 81 88    JMP   USBUART_1_CB_h2d_std_ep_03(0394)     jmp     USBUART_1_CB_h2d_std_ep_03
                                        (0395) 
                                        (0396) USBUART_1_DT_h2d_std_ep_End:
                                        (0397) USBUART_1_DT_h2d_std_ep_Size: equ (USBUART_1_DT_h2d_std_ep_End-USBUART_1_DT_h2d_std_ep) / 2
                                        (0398) USBUART_1_DT_h2d_std_ep_Dispatch::
0570: 3C 01 00 CMP   [0x1],0x0          (0399)     CMP     [USBUART_1_Configuration], 0  ; Is the device configured?
0573: B0 0D    JNZ   0x0581             (0400)     JNZ     .configured                ; Jump on configured
                                        (0401) 
0575: 5D 5D    MOV   A,REG[0x5D]        (0402)     MOV     A, REG[USBUART_1_EP0DATA + wIndexHi] ; Is the request for EP0?
0577: 53 1F    MOV   [0x1F],A           (0403)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
0579: 5D 5C    MOV   A,REG[0x5C]        (0404)     MOV     A, REG[USBUART_1_EP0DATA + wIndexLo] ;
057B: 2C 1F    OR    [0x1F],A           (0405)     OR      [USBUART_1_t2], A          ; Use the UM temp var--Selector
057D: A0 03    JZ    0x0581             (0406)     JZ      .ep0_request
                                        (0407) 
057F: 8F 2E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0408)     JMP    _USBUART_1_Not_Supported    ; Stall the request if not configured
                                        (0409) ; Jump here if the device is configured or EP0 request
                                        (0410) .configured:
                                        (0411) .ep0_request:
0581: 5D 59    MOV   A,REG[0x59]        (0412)     MOV     A, REG[USBUART_1_EP0DATA + bRequest]
0583: 39 04    CMP   A,0x4              
0585: D0 04    JNC   0x058A             
0587: 64       ASL   A                  
0588: EF DF    JACC  0x0568             
058A: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...
                                        (0413)     DISPATCHER USBUART_1_DT_h2d_std_ep, USBUART_1_DT_h2d_std_ep_Size, USBUART_1_Not_Supported
                                        (0414) 
                                        (0415) USBUART_1_GetTableEntry_Local_Std:
058D: 7D 09 60 LJMP  USBUART_1_GetTableEntry(0416)     LJMP    USBUART_1_GetTableEntry
                                        (0417) 
                                        (0418) USBUART_1_NoDataStageControlTransfer_Local_Std:
0590: 7D 08 4D LJMP  USBUART_1_NoDataStageControlTransfer|_USBUART_1_InitNoDataStageControlTransfer|USBUART_1_InitNoDataStageControlTransfer(0419)     LJMP    USBUART_1_NoDataStageControlTransfer
                                        (0420) 
                                        (0421) ;-----------------------------------------------
                                        (0422) ; Add custom application code for routines
                                        (0423) ; redefined by USB_APP_SUPPLIED in USB_HID.INC
                                        (0424) ;-----------------------------------------------
                                        (0425) 
                                        (0426)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0427)    ;---------------------------------------------------
                                        (0428)    ; Insert your custom code below this banner
                                        (0429)    ;---------------------------------------------------
                                        (0430) 
                                        (0431)    ;---------------------------------------------------
                                        (0432)    ; Insert your custom code above this banner
                                        (0433)    ;---------------------------------------------------
                                        (0434)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0435) 
                                        (0436) ;-----------------------------------------------------------------------------
                                        (0437) ; FUNCTION NAME: USBUART_1_CB_d2h_std_dev_06
                                        (0438) ;
                                        (0439) ; DESCRIPTION:   Get Device Descriptor
                                        (0440) ;
                                        (0441) ;****************************************************************
                                        (0442) ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                                        (0443) ;****************************************************************
                                        (0444) ;
                                        (0445) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0446) ; bRequest       : GET_DESCRIPTOR                 = 06h
                                        (0447) ; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh
                                        (0448) ; wIndex         : ZERO or LANG_ID                = xxxxh
                                        (0449) ; wLength        : SIZEOF_DESCRIPTOR              = --xxh
                                        (0450) ;
                                        (0451) ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if
                                        (0452) ; the descriptor exists.
                                        (0453) ;
                                        (0454) ; The upper byte of wValue contains the descriptor type and
                                        (0455) ; the lower byte contains the descriptor index. wIndex
                                        (0456) ; contains either 0000h or the Language ID. wLength contains
                                        (0457) ; the descriptor length. The actual descriptor information is
                                        (0458) ; transferred in subsequent data packets.
                                        (0459) ;
                                        (0460) ;****************************************************************
                                        (0461) ;
                                        (0462) ;-----------------------------------------------------------------------------
                                        (0463) ;
                                        (0464) ;  ARGUMENTS:
                                        (0465) ;
                                        (0466) ;  RETURNS:
                                        (0467) ;
                                        (0468) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0469) ;
                                        (0470) ;  THEORY of OPERATION or PROCEDURE:
                                        (0471) ;
                                        (0472) ;-----------------------------------------------------------------------------
                                        (0473) IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                                        (0474) export  USBUART_1_CB_d2h_std_dev_06
                                        (0475) USBUART_1_CB_d2h_std_dev_06:
                                        (0476) ;-----------------------------------------------------------------------------
                                        (0477) ; Dispatch to the proper handler
                                        (0478) ;-----------------------------------------------------------------------------
0593: 5D 5B    MOV   A,REG[0x5B]        (0479)     MOV     A, REG[USBUART_1_EP0DATA+wValueHi] ; Get the descriptor type
0595: 64       ASL   A                  (0480)     ASL     A                          ; Make it into a offset
0596: 39 08    CMP   A,0x8              (0481)     CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
0598: DF 15    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0482)     JNC     USBUART_1_Not_Supported
                                        (0483) 
059A: E0 01    JACC  0x059C             (0484)     JACC    GET_DESCR_DISPATCH
                                        (0485) 
                                        (0486) GET_DESCR_DISPATCH:
059C: 8F 11    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0487)     JMP     USBUART_1_Not_Supported    ; Invalid
059E: 80 28    JMP   0x05C7             (0488)     JMP     USBUART_1_SendDeviceDescr  ; Device Descriptor
05A0: 80 03    JMP   0x05A4             (0489)     JMP     USBUART_1_SendConfigDescr  ; Configuration Descriptor
05A2: 80 34    JMP   0x05D7             (0490)     JMP     USBUART_1_SendStringDescr  ; String Descriptor
                                        (0491) 
                                        (0492) GET_DESCR_DISPATCH_END:
                                        (0493) GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)
                                        (0494) ;-----------------------------------------------------------------------------
                                        (0495) ; Configuration Descriptor Handler
                                        (0496) ;-----------------------------------------------------------------------------
                                        (0497) USBUART_1_SendConfigDescr:
05A4: 93 FF    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0498)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY
05A6: 4B       SWAP  A,X                (0499)     SWAP    A, X
05A7: 01 02    ADD   A,0x2              (0500)     ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
05A9: 4B       SWAP  A,X                (0501)     SWAP    A, X
05AA: 09 00    ADC   A,0x0              (0502)     ADC     A, 0                       ; Don't forget the carry
05AC: 55 1F 20 MOV   [0x1F],0x20        (0503)     MOV    [USBUART_1_t2], USBUART_1_t1; Set up the destination
05AF: 93 E3    CALL  USBUART_1_GETWORD  (0504)     CALL    USBUART_1_GETWORD          ; Get the pointer
                                        (0505) 
05B1: 51 20    MOV   A,[0x20]           (0506)     MOV     A, [USBUART_1_t1]          ; Pointer MSB
05B3: 58 21    MOV   X,[0x21]           (0507)     MOV     X, [USBUART_1_t1+1]        ; Pointer LSB
                                        (0508) 
05B5: 08       PUSH  A                  (0509)     PUSH    A                          ; Save the MSB
                                        (0510) 
05B6: 5D 5A    MOV   A,REG[0x5A]        (0511)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the descriptor index
05B8: 53 1F    MOV   [0x1F],A           (0512)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
05BA: 18       POP   A                  (0513)     POP     A                          ; Need the MSB for the range check
05BB: 08       PUSH  A                  (0514)     PUSH    A                          ; Save the MSB for after the range check
05BC: 28       ROMX                     (0515)     ROMX                               ; First entry is the table size (only a byte)
05BD: 3A 1F    CMP   A,[0x1F]           (0516)     CMP     A, [USBUART_1_t2]          ; Range check
05BF: D0 04    JNC   0x05C4             (0517)     JNC     .range_ok
                                        (0518) 
05C1: 18       POP   A                  (0519)     POP     A                          ; Fix the stack
05C2: 8E EB    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0520)     JMP    USBUART_1_Not_Supported
                                        (0521) 
                                        (0522) .range_ok:
05C4: 18       POP   A                  (0523)     POP     A                          ; Get the MSB back
05C5: 8F C7    JMP   0x058D             (0524)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0525) ;-----------------------------------------------------------------------------
                                        (0526) ; Device Descriptor Handler
                                        (0527) ;-----------------------------------------------------------------------------
                                        (0528) USBUART_1_SendDeviceDescr:
05C7: 5F 1F 00 MOV   [0x1F],[0x0]       (0529)     MOV     [USBUART_1_t2], [USBUART_1_bCurrentDevice]  ; Use the UM temp var--Selector
05CA: 50 01    MOV   A,0x1              (0530)     MOV     A,>USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
05CC: 57 F1    MOV   X,0xF1             (0531)     MOV     X,<USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
05CE: 28       ROMX                     (0532)     ROMX                               ; First entry is the table size (only a byte)
05CF: 3A 1F    CMP   A,[0x1F]           (0533)     CMP     A, [USBUART_1_t2]          ; Range check
05D1: CE DC    JC    _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0534)     JC      USBUART_1_Not_Supported
                                        (0535) 
05D3: 50 01    MOV   A,0x1              (0536)     MOV     A,>USBUART_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
                                        (0537) 
05D5: 8F B7    JMP   0x058D             (0538)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ; String Descriptor Handler
                                        (0541) ;-----------------------------------------------------------------------------
                                        (0542) USBUART_1_SendStringDescr:
05D7: 5D 5A    MOV   A,REG[0x5A]        (0543)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the descriptor index
05D9: 53 1F    MOV   [0x1F],A           (0544)     MOV     [USBUART_1_t2], A          ; Use the UM temp var--Selector
                                        (0545) 
05DB: 50 02    MOV   A,0x2              (0546)     MOV     A,>USBUART_1_StringTable   ; Get the ROM Address MSB
05DD: 57 4F    MOV   X,0x4F             (0547)     MOV     X,<USBUART_1_StringTable   ; Get the ROM Address LSB
05DF: 28       ROMX                     (0548)     ROMX                               ; First entry is the table size (only a byte)
05E0: 3A 1F    CMP   A,[0x1F]           (0549)     CMP     A, [USBUART_1_t2]          ; Range check
05E2: CE CB    JC    _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0550)     JC      USBUART_1_Not_Supported
                                        (0551) 
05E4: 50 02    MOV   A,0x2              (0552)     MOV     A,>USBUART_1_StringTable   ; Get the ROM Address MSB
                                        (0553) 
05E6: 8F A6    JMP   0x058D             (0554)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0555) ENDIF
                                        (0556) ;-----------------------------------------------------------------------------
                                        (0557) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_dev_08
                                        (0558) ;
                                        (0559) ;  DESCRIPTION:   Get Device Configuration
                                        (0560) ;
                                        (0561) ;****************************************************************
                                        (0562) ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                                        (0563) ;****************************************************************
                                        (0564) ;
                                        (0565) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0566) ; bRequest       : GET_CONFIGURATION              = 08h
                                        (0567) ; wValue         : RESERVED                       = 0000h
                                        (0568) ; wIndex         : RESERVED                       = 0000h
                                        (0569) ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h
                                        (0570) ;
                                        (0571) ; The GET_DEVICE_CONFIGURATION request returns the currently
                                        (0572) ; selected device configuration number.
                                        (0573) ;
                                        (0574) ; request_value and request_index contain 0000h. request_length
                                        (0575) ; contains 0001h and the one-byte configuration number is returned
                                        (0576) ; in a separate data transfer.
                                        (0577) ;
                                        (0578) ;-----------------------------------------------------------------------------
                                        (0579) ;
                                        (0580) ;  ARGUMENTS:
                                        (0581) ;
                                        (0582) ;  RETURNS:
                                        (0583) ;
                                        (0584) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0585) ;
                                        (0586) ;  THEORY of OPERATION or PROCEDURE:
                                        (0587) ;
                                        (0588) ;-----------------------------------------------------------------------------
                                        (0589) IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
                                        (0590) .LITERAL
                                        (0591) GetConfigTransferDescrTable:
                                        (0592)     TD_START_TABLE  1                  ; One entry
                                        (0593)     TD_ENTRY    USB_DS_RAM, 1, USBUART_1_Configuration, NULL_PTR  ; Current configuration
                                        (0594) .ENDLITERAL
                                        (0595) export  USBUART_1_CB_d2h_std_dev_08
                                        (0596) USBUART_1_CB_d2h_std_dev_08:
05F1: 55 1F 00 MOV   [0x1F],0x0         (0597)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
05F4: 50 05    MOV   A,0x5              (0598)     MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
05F6: 57 E8    MOV   X,0xE8             (0599)     MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
05F8: 8F 94    JMP   0x058D             (0600)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0601) ENDIF
                                        (0602) ;-----------------------------------------------------------------------------
                                        (0603) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_01
                                        (0604) ;
                                        (0605) ;  DESCRIPTION:   Clear Device Feature
                                        (0606) ;
                                        (0607) ;****************************************************************
                                        (0608) ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                                        (0609) ;****************************************************************
                                        (0610) ;
                                        (0611) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0612) ; bRequest       : CLEAR_FEATURE                  = 01h
                                        (0613) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (0614) ; wIndex         : RESERVED                       = 0000h
                                        (0615) ; wLength        : RESERVED                       = 0000h
                                        (0616) ;
                                        (0617) ; The CLEAR_DEVICE_FEATURE request disables a particular feature
                                        (0618) ; for a device. The only feature supported for a device is the
                                        (0619) ; REMOTE_WAKEUP feature.
                                        (0620) ;
                                        (0621) ;****************************************************************
                                        (0622) ;-----------------------------------------------------------------------------
                                        (0623) ;
                                        (0624) ;  ARGUMENTS:
                                        (0625) ;
                                        (0626) ;  RETURNS:
                                        (0627) ;
                                        (0628) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0629) ;
                                        (0630) ;  THEORY of OPERATION or PROCEDURE:
                                        (0631) ;
                                        (0632) ;-----------------------------------------------------------------------------
                                        (0633) IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                                        (0634) export  USBUART_1_CB_h2d_std_dev_01
                                        (0635) USBUART_1_CB_h2d_std_dev_01:
05FA: 5D 5A    MOV   A,REG[0x5A]        (0636)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0637)                                        ; Check against valid features
                                        (0638)                                        ;  for device recipient
05FC: 39 01    CMP   A,0x1              (0639)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
05FE: BE AF    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0640)     JNZ     USBUART_1_Not_Supported    ;
0600: 26 02 FD AND   [0x2],0xFD         (0641)     AND     [USBUART_1_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
0603: 8F 8C    JMP   0x0590             (0642)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0643) ENDIF
                                        (0644) ;-----------------------------------------------------------------------------
                                        (0645) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_03
                                        (0646) ;
                                        (0647) ;  DESCRIPTION:   Set Device Feature
                                        (0648) ;
                                        (0649) ;****************************************************************
                                        (0650) ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                                        (0651) ;****************************************************************
                                        (0652) ;
                                        (0653) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0654) ; bRequest       : SET_FEATURE                    = 03h
                                        (0655) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (0656) ; wIndex         : RESERVED                       = 0000h
                                        (0657) ; wLength        : RESERVED                       = 0000h
                                        (0658) ;
                                        (0659) ; The SET_DEVICE_FEATURE request enables a particular feature
                                        (0660) ; on a device. The only feature supported for a device is the
                                        (0661) ; REMOTE_WAKEUP feature.
                                        (0662) ;
                                        (0663) ;****************************************************************
                                        (0664) ;-----------------------------------------------------------------------------
                                        (0665) ;
                                        (0666) ;  ARGUMENTS:
                                        (0667) ;
                                        (0668) ;  RETURNS:
                                        (0669) ;
                                        (0670) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0671) ;
                                        (0672) ;  THEORY of OPERATION or PROCEDURE:
                                        (0673) ;
                                        (0674) ;-----------------------------------------------------------------------------
                                        (0675) IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                                        (0676) export  USBUART_1_CB_h2d_std_dev_03
                                        (0677) USBUART_1_CB_h2d_std_dev_03:
0605: 5D 5A    MOV   A,REG[0x5A]        (0678)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0679)                                        ; Check against valid features
                                        (0680)                                        ;  for device recipient
0607: 39 01    CMP   A,0x1              (0681)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
0609: A0 07    JZ    0x0611             (0682)     JZ      .remote_wakeup
                                        (0683) 
060B: 39 02    CMP   A,0x2              (0684)     CMP     A, USB_TEST_MODE           ; Test Mode
060D: A0 08    JZ    0x0616             (0685)     JZ      .test_mode
                                        (0686) ; Flow here for any other selector is invalid for device recipient
060F: 8E 9E    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0687)     JMP     USBUART_1_Not_Supported
                                        (0688) ; Jump here to enable remote wake up
                                        (0689) .remote_wakeup:
0611: 2E 02 02 OR    [0x2],0x2          (0690)     OR      [USBUART_1_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
0614: 80 03    JMP   0x0618             (0691)     JMP     .finish
                                        (0692) ; Jump here to enable test mode
                                        (0693) .test_mode:
0616: 8E 97    JMP   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0694)     JMP     USBUART_1_Not_Supported
                                        (0695) .finish:
0618: 8F 77    JMP   0x0590             (0696)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0697) ENDIF
                                        (0698) ;-----------------------------------------------------------------------------
                                        (0699) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_05
                                        (0700) ;
                                        (0701) ;  DESCRIPTION:   Set Device Address
                                        (0702) ;
                                        (0703) ;****************************************************************
                                        (0704) ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                                        (0705) ;****************************************************************
                                        (0706) ;
                                        (0707) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0708) ; bRequest       : SET_ADDRESS                    = 05h
                                        (0709) ; wValue         : DEVICE_ADDRESS                 = 00xxh
                                        (0710) ; wIndex         : RESERVED                       = 0000h
                                        (0711) ; wLength        : RESERVED                       = 0000h
                                        (0712) ;
                                        (0713) ; The SET_DEVICE_ADDRESS request sets the USB device address
                                        (0714) ; for all future USB accesses.
                                        (0715) ;
                                        (0716) ;****************************************************************
                                        (0717) ;
                                        (0718) ;-----------------------------------------------------------------------------
                                        (0719) ;
                                        (0720) ;  ARGUMENTS:
                                        (0721) ;
                                        (0722) ;  RETURNS:
                                        (0723) ;
                                        (0724) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0725) ;
                                        (0726) ;  THEORY of OPERATION or PROCEDURE:
                                        (0727) ;
                                        (0728) ;-----------------------------------------------------------------------------
                                        (0729) 
                                        (0730) IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                                        (0731) export  USBUART_1_CB_h2d_std_dev_05
                                        (0732) USBUART_1_CB_h2d_std_dev_05:
                                        (0733)       
061A: 55 1E 01 MOV   [0x1E],0x1         (0734)     MOV     [USBUART_1_fDataPending], USB_ADDRESS_CHANGE_PENDING       
061D: 5D 5A    MOV   A,REG[0x5A]        (0735)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]       
061F: 53 0C    MOV   [0xC],A            (0736)     MOV     [USBUART_1_TransferBuffer],A       
                                        (0737)                                                    
0621: 8F 6E    JMP   0x0590             (0738)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0739) ENDIF
                                        (0740) 
                                        (0741) 
                                        (0742) ;-----------------------------------------------------------------------------
                                        (0743) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_dev_09
                                        (0744) ;
                                        (0745) ;  DESCRIPTION:   Set Configuration
                                        (0746) ;
                                        (0747) ;****************************************************************
                                        (0748) ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                                        (0749) ;****************************************************************
                                        (0750) ;
                                        (0751) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0752) ; bRequest       : SET_CONFIGURATION              = 09h
                                        (0753) ; wValue         : CONFIGURATION_VALUE            = --xxh
                                        (0754) ; wIndex         : RESERVED                       = 0000h
                                        (0755) ; wLength        : RESERVED                       = 0000h
                                        (0756) ;
                                        (0757) ; The SET_DEVICE_CONFIGURATION request selects a device
                                        (0758) ; configuration to be activated as the current configuration.
                                        (0759) ;
                                        (0760) ;****************************************************************
                                        (0761) ;-----------------------------------------------------------------------------
                                        (0762) ;
                                        (0763) ;  ARGUMENTS:
                                        (0764) ;
                                        (0765) ;  RETURNS:
                                        (0766) ;
                                        (0767) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0768) ;
                                        (0769) ;  THEORY of OPERATION or PROCEDURE:
                                        (0770) ;
                                        (0771) ;-----------------------------------------------------------------------------
                                        (0772) 
                                        (0773) IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                                        (0774) export  USBUART_1_CB_h2d_std_dev_09
                                        (0775) USBUART_1_CB_h2d_std_dev_09:
0623: 93 80    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0776)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
0625: 55 1F 20 MOV   [0x1F],0x20        (0777)     MOV     [USBUART_1_t2],USBUART_1_t1  ; Set the GETWORD destination
0628: 93 6A    CALL  USBUART_1_GETWORD  (0778)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0779)                                        ; ITempW has the address
062A: 5D 5A    MOV   A,REG[0x5A]        (0780)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the configuration number
062C: 53 1F    MOV   [0x1F],A           (0781)     MOV     [USBUART_1_t2],A           ; Save it
062E: 51 20    MOV   A,[0x20]           (0782)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0630: 58 21    MOV   X,[0x21]           (0783)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0632: 28       ROMX                     (0784)     ROMX                               ; First entry is the table size (only a byte)
0633: 3A 1F    CMP   A,[0x1F]           (0785)     CMP     A, [USBUART_1_t2]          ; Range check
0635: CE 78    JC    _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0786)     JC      USBUART_1_Not_Supported
                                        (0787) 
                                        (0788) ; Refactored from the two loops below
0637: 5F 01 1F MOV   [0x1],[0x1F]       (0789)     MOV     [USBUART_1_Configuration],[USBUART_1_t2]  ; Save the config number
                                        (0790) 
063A: 3C 1F 00 CMP   [0x1F],0x0         (0791)     CMP     [USBUART_1_t2], 0          ; Unconfigure?
063D: A0 25    JZ    0x0663             (0792)     JZ      .unconfigure
                                        (0793) 
                                        (0794) ; Flow here to configure the endpoints
063F: 51 20    MOV   A,[0x20]           (0795)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0641: 58 21    MOV   X,[0x21]           (0796)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0643: 75       INC   X                  (0797)     INC     X                          ; Point to the first table entry
0644: 09 00    ADC   A,0x0              (0798)     ADC     A, 0                       ;
0646: 55 1F 20 MOV   [0x1F],0x20        (0799)     MOV    [USBUART_1_t2], USBUART_1_t1; Set up the destination
0649: 93 49    CALL  USBUART_1_GETWORD  (0800)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0801)                                        ; ITempW has the address
064B: 57 00    MOV   X,0x0              (0802)     MOV     X, 0                       ; Start the index at 0, but we INC first
                                        (0803) .configure_next:
064D: 75       INC   X                  (0804)     INC     X                          ; Do the next one
064E: 10       PUSH  X                  (0805)     PUSH    X                          ; Save the endpoint number
064F: 51 20    MOV   A,[0x20]           (0806)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
0651: 58 21    MOV   X,[0x21]           (0807)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
0653: 28       ROMX                     (0808)     ROMX
0654: 76 21    INC   [0x21]             (0809)     INC     [USBUART_1_t1+1]           ; Point to the next
0656: 0E 20 00 ADC   [0x20],0x0         (0810)     ADC     [USBUART_1_t1], 0          ;
0659: 20       POP   X                  (0811)     POP     X
065A: 90 C7    CALL  0x0723             (0812)     CALL    ConfigureEP                ; X contains the EP number
                                        (0813)                                        ; A contains the EP Direction
065C: 5B       MOV   A,X                (0814)     MOV     A, X                       ;
065D: 39 04    CMP   A,0x4              (0815)     CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
065F: BF ED    JNZ   0x064D             (0816)     JNZ     .configure_next            ; Do another one?
                                        (0817) ; Flow here when we are done
0661: 80 10    JMP   0x0672             (0818)     JMP     .done
0663: 71 10    OR    F,0x10             
                                        (0819) 
                                        (0820) ; Jump here to unconfigure the endpoints
                                        (0821) .unconfigure:
                                        (0822)     M8C_SetBank1	; _EP1MODE is in Bank 1
0665: 57 04    MOV   X,0x4              (0823)     MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
                                        (0824) .unconfigure_next:
0667: 56 22 02 MOV   [X+34],0x2         (0825)     MOV     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
066A: 63 C3 00 MOV   REG[X+0xC3],0x0    (0826)     MOV     REG[X+USBUART_1_EP1MODE-1], USB_MODE_DISABLE ; Disable the endpoint
066D: 79       DEC   X                  (0827)     DEC     X                          ; One more down
066E: BF F8    JNZ   0x0667             (0828)     JNZ     .unconfigure_next          ; Don't unconfigure EP0
0670: 70 EF    AND   F,0xEF             
                                        (0829) 	M8C_SetBank0
                                        (0830) .done:
0672: 8F 1D    JMP   0x0590             (0831)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (0832) ENDIF
                                        (0833) 
                                        (0834) 
                                        (0835) ;-----------------------------------------------------------------------------
                                        (0836) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ifc_00
                                        (0837) ;
                                        (0838) ;  DESCRIPTION:   Get Interface Status
                                        (0839) ;
                                        (0840) ;****************************************************************
                                        (0841) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                                        (0842) ;****************************************************************
                                        (0843) ;
                                        (0844) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                        (0845) ; bRequest       : GET_STATUS                     = 00h
                                        (0846) ; wValue         : RESERVED                       = 0000h
                                        (0847) ; wIndex         : INTERFACE                      = --xxh
                                        (0848) ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h
                                        (0849) ;
                                        (0850) ; The GET_INTERFACE_STATUS request returns status for the
                                        (0851) ; specified interface.
                                        (0852) ;
                                        (0853) ;****************************************************************
                                        (0854) ;-----------------------------------------------------------------------------
                                        (0855) ;
                                        (0856) ;  ARGUMENTS:
                                        (0857) ;
                                        (0858) ;  RETURNS:
                                        (0859) ;
                                        (0860) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0861) ;
                                        (0862) ;  THEORY of OPERATION or PROCEDURE:
                                        (0863) ;
                                        (0864) ;-----------------------------------------------------------------------------
                                        (0865) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
                                        (0866) .LITERAL
                                        (0867) GetInterfaceStatusTransferDescrTable:
                                        (0868)     TD_START_TABLE  1                  ; One entry
                                        (0869)     TD_ENTRY        USB_DS_RAM, 2, USBUART_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0870) .ENDLITERAL
                                        (0871) export  USBUART_1_CB_d2h_std_ifc_00
                                        (0872) USBUART_1_CB_d2h_std_ifc_00:
                                        (0873) 
067D: 55 0C 00 MOV   [0xC],0x0          (0874)     MOV     [USBUART_1_TransferBuffer], 0     ; Zero the transfer buffer
0680: 55 0D 00 MOV   [0xD],0x0          (0875)     MOV     [USBUART_1_TransferBuffer+1], 0  ;
                                        (0876) 
0683: 55 1F 00 MOV   [0x1F],0x0         (0877)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
0686: 50 06    MOV   A,0x6              (0878)     MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
0688: 57 74    MOV   X,0x74             (0879)     MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0880) 
068A: 8F 02    JMP   0x058D             (0881)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0882) ENDIF
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ifc_10
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:   Get Interface
                                        (0887) ;
                                        (0888) ;****************************************************************
                                        (0889) ; STANDARD INTERFACE IN REQUEST: Get_Interface
                                        (0890) ;****************************************************************
                                        (0891) ;
                                        (0892) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                        (0893) ; bRequest       : GET_INTERFACE                  = 0Ah
                                        (0894) ; wValue         : RESERVED                       = 0000h
                                        (0895) ; wIndex         : INTERFACE                      = xxxxh
                                        (0896) ; wLength        : SIZEOF_GET_INTERFACE           = 0001h
                                        (0897) ;
                                        (0898) ; The GET_INTERFACE request returns the selected alternate
                                        (0899) ; setting for the specified interface.
                                        (0900) ;
                                        (0901) ;****************************************************************
                                        (0902) ;-----------------------------------------------------------------------------
                                        (0903) ;
                                        (0904) ;  ARGUMENTS:
                                        (0905) ;
                                        (0906) ;  RETURNS:
                                        (0907) ;
                                        (0908) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0909) ;
                                        (0910) ;  THEORY of OPERATION or PROCEDURE:
                                        (0911) ;
                                        (0912) ;-----------------------------------------------------------------------------
                                        (0913) 
                                        (0914) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
                                        (0915) .LITERAL
                                        (0916) GetInterfaceTransferDescrTable:
                                        (0917)     TD_START_TABLE  1                  ; One entry
                                        (0918)     TD_ENTRY        USB_DS_RAM, 1, USBUART_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0919) .ENDLITERAL
                                        (0920) export  USBUART_1_CB_d2h_std_ifc_10
                                        (0921) USBUART_1_CB_d2h_std_ifc_10:
0695: 5D 5C    MOV   A,REG[0x5C]        (0922)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the interface number
0697: 39 02    CMP   A,0x2              (0923)     CMP     A, 2                       ; Valid interface number? (UM Parameter: NumInterfaces)
0699: DE 14    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0924)     JNC     USBUART_1_Not_Supported
                                        (0925) 
069B: 5C       MOV   X,A                (0926)     MOV     X, A                       ; The interface number is the index into alternates settings table
                                        (0927) 
069C: 52 03    MOV   A,[X+3]            (0928)     MOV     A, [X + USBUART_1_InterfaceSetting]  ; Save the current interface setting
069E: 53 0C    MOV   [0xC],A            (0929)     MOV     [USBUART_1_TransferBuffer], A     ; into the transfer buffer
                                        (0930) 
06A0: 55 1F 00 MOV   [0x1F],0x0         (0931)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
06A3: 50 06    MOV   A,0x6              (0932)     MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
06A5: 57 8C    MOV   X,0x8C             (0933)     MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB
                                        (0934) 
06A7: 8E E5    JMP   0x058D             (0935)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0936) ENDIF
                                        (0937) 
                                        (0938) 
                                        (0939) ;-----------------------------------------------------------------------------
                                        (0940) ;  FUNCTION NAME: USBUART_1_CB_d2h_std_ep_00
                                        (0941) ;
                                        (0942) ;  DESCRIPTION:   Get Endpoint Status
                                        (0943) ;
                                        (0944) ;****************************************************************
                                        (0945) ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                                        (0946) ;****************************************************************
                                        (0947) ;
                                        (0948) ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h
                                        (0949) ; bRequest       : GET_STATUS                     = 00h
                                        (0950) ; wValue         : RESERVED                       = 0000h
                                        (0951) ; wIndex         : ENDPOINT                       = 00xxh
                                        (0952) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
                                        (0953) ;
                                        (0954) ; The GET_ENDPOINT_STATUS request returns status for the specified
                                        (0955) ; endpoint.
                                        (0956) ;
                                        (0957) ;****************************************************************
                                        (0958) ;-----------------------------------------------------------------------------
                                        (0959) ;
                                        (0960) ;  ARGUMENTS:
                                        (0961) ;
                                        (0962) ;  RETURNS:
                                        (0963) ;
                                        (0964) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0965) ;
                                        (0966) ;  THEORY of OPERATION or PROCEDURE:
                                        (0967) ;
                                        (0968) ;-----------------------------------------------------------------------------
                                        (0969) IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                                        (0970) export  USBUART_1_CB_d2h_std_ep_00
                                        (0971) USBUART_1_CB_d2h_std_ep_00:
06A9: 5D 5C    MOV   A,REG[0x5C]        (0972)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the endpoint number
06AB: 21 7F    AND   A,0x7F             (0973)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
06AD: 39 05    CMP   A,0x5              (0974)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
06AF: DD FE    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0975)     JNC     USBUART_1_Not_Supported
                                        (0976) 
06B1: 5C       MOV   X,A                (0977)     MOV     X, A                       ; The endpoint number is the index
                                        (0978) 
06B2: 55 1F 00 MOV   [0x1F],0x0         (0979)     MOV     [USBUART_1_t2], 0          ; Use the UM temp var--Selector
                                        (0980) 
06B5: 55 0D 00 MOV   [0xD],0x0          (0981)     MOV     [USBUART_1_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
06B8: 52 05    MOV   A,[X+5]            (0982)     MOV     A, [X + USBUART_1_EndpointStatus]  ; Get the status
06BA: 53 0C    MOV   [0xC],A            (0983)     MOV     [USBUART_1_TransferBuffer], A  ; Save it in the report
                                        (0984) 
06BC: 50 04    MOV   A,0x4              (0985)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
06BE: 57 B5    MOV   X,0xB5             (0986)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0987) 
06C0: 8E CC    JMP   0x058D             (0988)     JMP     USBUART_1_GetTableEntry_Local_Std
                                        (0989) ENDIF
                                        (0990) 
                                        (0991) ;-----------------------------------------------------------------------------
                                        (0992) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_ep_01
                                        (0993) ;
                                        (0994) ;  DESCRIPTION:   Clear Endpoint Feature
                                        (0995) ;
                                        (0996) ;****************************************************************
                                        (0997) ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                                        (0998) ;****************************************************************
                                        (0999) ;
                                        (1000) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (1001) ; bRequest       : CLEAR_FEATURE                  = 01h
                                        (1002) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (1003) ; wIndex         : ENDPOINT                       = 00xxh
                                        (1004) ; wLength        : RESERVED                       = 0000h
                                        (1005) ;
                                        (1006) ; The CLEAR_ENDPOINT_FEATURE request disables a particular
                                        (1007) ; feature for an endpoint.
                                        (1008) ;
                                        (1009) ; The only feature supported for an endpoint is the EP_HALT
                                        (1010) ; feature.
                                        (1011) ;
                                        (1012) ;****************************************************************
                                        (1013) ;-----------------------------------------------------------------------------
                                        (1014) ;
                                        (1015) ;  ARGUMENTS:
                                        (1016) ;
                                        (1017) ;  RETURNS:
                                        (1018) ;
                                        (1019) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1020) ;
                                        (1021) ;  THEORY of OPERATION or PROCEDURE:
                                        (1022) ;
                                        (1023) ;-----------------------------------------------------------------------------
                                        (1024) IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                                        (1025) export  USBUART_1_CB_h2d_std_ep_01
                                        (1026) USBUART_1_CB_h2d_std_ep_01:
06C2: 5D 5A    MOV   A,REG[0x5A]        (1027)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the feature selector
06C4: 39 00    CMP   A,0x0              (1028)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
06C6: BD E7    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(1029)     JNZ     USBUART_1_Not_Supported
                                        (1030) 
06C8: 5D 5C    MOV   A,REG[0x5C]        (1031)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
06CA: 21 7F    AND   A,0x7F             (1032)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
06CC: 39 00    CMP   A,0x0              (1033)     CMP     A, 0                       ; Since we can't halt the Control Endpoint
06CE: A0 24    JZ    0x06F3             (1034)     JZ      .done
                                        (1035) 
06D0: 39 05    CMP   A,0x5              (1036)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
06D2: DD DB    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(1037)     JNC     USBUART_1_Not_Supported
                                        (1038) 
06D4: 5C       MOV   X,A                (1039)     MOV     X, A                       ; Endpoint number is the index
06D5: 27 05 FE AND   [X+5],0xFE         (1040)     AND     [X+USBUART_1_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt
                                        (1041) 
06D8: F4 77    INDEX USBUART_1_USB_EP_BIT_LOOKUP(1042)     index   USBUART_1_USB_EP_BIT_LOOKUP	   ; Find bit position for endpoint
06DA: 31 FF    XOR   A,0xFF             (1043)     xor     A, FFh
06DC: 24 1D    AND   [0x1D],A           (1044)     and     [USBUART_1_EPDataToggle], A ; Clear the data toggle for this endpoint
06DE: 49 5C 80 TST   REG[0x5C],0x80     (1045)     TST     REG[USBUART_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
06E1: 71 10    OR    F,0x10             
                                        (1046)     M8C_SetBank1	                      ; For EP1_MODE register
06E3: B0 09    JNZ   0x06ED             (1047)     JNZ     .in
                                        (1048) 
                                        (1049)     ; Mark endpoint as empty so it will be reloaded
06E5: 56 22 00 MOV   [X+34],0x0         (1050)     mov     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_PENDING
06E8: 63 C3 09 MOV   REG[X+0xC3],0x9    (1051)     mov     reg[X + USBUART_1_EP1MODE - 1], USB_MODE_ACK_OUT    ; ACK the endpoint
06EB: 80 07    JMP   0x06F3             (1052)     JMP     .done
                                        (1053) .in:
06ED: 56 22 01 MOV   [X+34],0x1         (1054)     mov     [X+USBUART_1_EndpointAPIStatus], EVENT_PENDING
06F0: 63 C3 0C MOV   REG[X+0xC3],0xC    (1055)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_NAK_IN  ; NAK the endpoint
06F3: 70 EF    AND   F,0xEF             
                                        (1056) .done:
                                        (1057) 	M8C_SetBank0
06F5: 8E 9A    JMP   0x0590             (1058)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (1059) ENDIF
                                        (1060) ;-----------------------------------------------------------------------------
                                        (1061) ;  FUNCTION NAME: USBUART_1_CB_h2d_std_ep_03
                                        (1062) ;
                                        (1063) ;  DESCRIPTION:   Set Endpoint Feature
                                        (1064) ;
                                        (1065) ;****************************************************************
                                        (1066) ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                                        (1067) ;****************************************************************
                                        (1068) ;
                                        (1069) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (1070) ; bRequest       : SET_FEATURE                    = 03h
                                        (1071) ; wValue         : FEATURE_SELECTOR               = --xxh
                                        (1072) ; wIndex         : ENDPOINT                       = 00xxh
                                        (1073) ; wLength        : RESERVED                       = 0000h
                                        (1074) ;
                                        (1075) ; The SET_ENDPOINT_FEATURE request enables a particular feature
                                        (1076) ; for a specific endpoint. The only feature supported for an
                                        (1077) ; endpoint is the EP_HALT feature.
                                        (1078) ;
                                        (1079) ;****************************************************************
                                        (1080) ;-----------------------------------------------------------------------------
                                        (1081) ;
                                        (1082) ;  ARGUMENTS:
                                        (1083) ;
                                        (1084) ;  RETURNS:
                                        (1085) ;
                                        (1086) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1087) ;
                                        (1088) ;  THEORY of OPERATION or PROCEDURE:
                                        (1089) ;
                                        (1090) ;-----------------------------------------------------------------------------
                                        (1091) IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                                        (1092) export  USBUART_1_CB_h2d_std_ep_03
                                        (1093) USBUART_1_CB_h2d_std_ep_03:
06F7: 5D 5A    MOV   A,REG[0x5A]        (1094)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the feature selector
06F9: 39 00    CMP   A,0x0              (1095)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
06FB: BD B2    JNZ   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(1096)     JNZ     USBUART_1_Not_Supported
                                        (1097) 
06FD: 5D 5C    MOV   A,REG[0x5C]        (1098)     MOV     A, REG[USBUART_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
06FF: 21 7F    AND   A,0x7F             (1099)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
0701: 39 00    CMP   A,0x0              (1100)     CMP     A, 0                       ; Never halt the Control Endpoint
0703: A0 1B    JZ    0x071F             (1101)     JZ      .done
                                        (1102) 
0705: 39 05    CMP   A,0x5              (1103)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
0707: DD A6    JNC   _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(1104)     JNC     USBUART_1_Not_Supported
                                        (1105) 
0709: 5C       MOV   X,A                (1106)     MOV     X, A                       ; Endpoint number is the index
                                        (1107) 
070A: 2F 05 01 OR    [X+5],0x1          (1108)     OR      [X+USBUART_1_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
070D: 56 22 02 MOV   [X+34],0x2         (1109)     mov     [X+USBUART_1_EndpointAPIStatus], NO_EVENT_ALLOWED
                                        (1110) 
0710: 49 5C 80 TST   REG[0x5C],0x80     (1111)     TST     REG[USBUART_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
0713: 71 10    OR    F,0x10             
                                        (1112)     M8C_SetBank1	                      ; For EP1_MODE register
0715: B0 06    JNZ   0x071C             (1113)     JNZ     .in
                                        (1114) 
0717: 63 C3 89 MOV   REG[X+0xC3],0x89   (1115)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
071A: 80 04    JMP   0x071F             (1116)     JMP     .done
                                        (1117) .in:
071C: 63 C3 8D MOV   REG[X+0xC3],0x8D   (1118)     MOV     REG[X + USBUART_1_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
071F: 70 EF    AND   F,0xEF             
                                        (1119) .done:
                                        (1120) 	M8C_SetBank0
0721: 8E 6E    JMP   0x0590             (1121)     JMP     USBUART_1_NoDataStageControlTransfer_Local_Std
                                        (1122) ENDIF
                                        (1123) ;-----------------------------------------------------------------------------
                                        (1124) ;  FUNCTION NAME: ConfigureEP
                                        (1125) ;
                                        (1126) ;  DESCRIPTION:   Configure an endpoint
                                        (1127) ;
                                        (1128) ;  ARGUMENTS:    A contains the endpoint direction
                                        (1129) ;                X contains the endpoint number
                                        (1130) ;
                                        (1131) ;  RETURNS:
                                        (1132) ;
                                        (1133) ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                                        (1134) ;
                                        (1135) ;  THEORY of OPERATION or PROCEDURE:
                                        (1136) ;
                                        (1137) ;-----------------------------------------------------------------------------
                                        (1138) ConfigureEP:
0723: 39 7F    CMP   A,0x7F             (1139)     CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
0725: B0 02    JNZ   0x0728             (1140)     JNZ     .enable                    ; Only enable it if it is used
0727: 7F       RET                      (1141)     RET                                ; Quick exit if this endpoint is unused
                                        (1142) 
                                        (1143) ; Jump here to enable an endpoint
                                        (1144) .enable:
0728: 08       PUSH  A                  (1145)     PUSH    A		                        ; Save the endpoint direction
0729: 5B       MOV   A,X                (1146)     MOV     A, X	                      ; We are using a JACC to dispatch to enable the interrupt
072A: 64       ASL   A                  (1147)     ASL     A		                        ;
072B: E0 01    JACC  0x072D             (1148)     JACC    .EP_INT_ENABLE             ;
                                        (1149) 
                                        (1150) 
                                        (1151) .EP_INT_ENABLE:
072D: 80 09    JMP   0x0737             (1152)     JMP     .EP0IntEnable              ; Enable EP0
072F: 80 0C    JMP   0x073C             (1153)     JMP     .EP1IntEnable              ; Enable EP1
0731: 80 0F    JMP   0x0741             (1154)     JMP     .EP2IntEnable              ; Enable EP2
0733: 80 12    JMP   0x0746             (1155)     JMP     .EP3IntEnable              ; Enable EP3
0735: 80 15    JMP   0x074B             (1156)     JMP     .EP4IntEnable              ; Enable EP4
0737: 43 DF 04 OR    REG[0xDF],0x4      
                                        (1157) 
                                        (1158) ; Jump here to enable EP0 Interrupts
                                        (1159) .EP0IntEnable:
                                        (1160)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1161) ;    JMP   .exit2
073A: 80 15    JMP   0x0750             (1162)     JMP   .cont
073C: 43 DF 08 OR    REG[0xDF],0x8      
                                        (1163) .EP1IntEnable:
                                        (1164)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP1_MASK
073F: 80 10    JMP   0x0750             (1165)     JMP   .cont
0741: 43 DF 10 OR    REG[0xDF],0x10     
                                        (1166) .EP2IntEnable:
                                        (1167)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP2_MASK
0744: 80 0B    JMP   0x0750             (1168)     JMP   .cont
0746: 43 DF 20 OR    REG[0xDF],0x20     
                                        (1169) .EP3IntEnable:
                                        (1170)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP3_MASK
0749: 80 06    JMP   0x0750             (1171)     JMP   .cont
074B: 43 DF 40 OR    REG[0xDF],0x40     
                                        (1172) .EP4IntEnable:
                                        (1173)     M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP4_MASK
074E: 80 01    JMP   0x0750             (1174) 	JMP   .cont
                                        (1175) ; Jump or flow here to continue configuring the endpoint
                                        (1176) .cont:
0750: 5B       MOV   A,X                (1177)     MOV     A, X	                      ; Get the endpoint number from X
0751: F3 FE    INDEX USBUART_1_USB_EP_BIT_LOOKUP(1178)     INDEX   USBUART_1_USB_EP_BIT_LOOKUP	 ; Find bit position for endpoint
0753: 31 FF    XOR   A,0xFF             (1179)     XOR     A, FFh
0755: 24 1D    AND   [0x1D],A           (1180)     AND     [USBUART_1_EPDataToggle], A ; Clear the data toggle for this endpoint
0757: 27 05 FE AND   [X+5],0xFE         (1181)     and     [X+USBUART_1_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear any endpoint halts
075A: 71 10    OR    F,0x10             
                                        (1182) 
                                        (1183) ; if endpoint 0 set EP0MODE
                                        (1184) ; then exit
                                        (1185) ;    mov     A, X	                     ; Get the endpoint number from X
                                        (1186) ;    cmp     A, EP0	                   ; Is this endpoint zero?
                                        (1187) ;    jnz     .enable                   ; Only enable it if it is used
                                        (1188)     M8C_SetBank1
075C: 18       POP   A                  (1189)     POP   A                            ; Get the endpoint direction back
075D: 21 80    AND   A,0x80             (1190)     AND   A, USB_DIR_IN                ; Is it an IN endpoint?
075F: B0 09    JNZ   0x0769             (1191)     JNZ   .in                          ; Jump on IN
                                        (1192) ; Flow here for an OUT Endpoint
0761: 63 C3 09 MOV   REG[X+0xC3],0x9    (1193)     mov     reg[X+USBUART_1_EP1MODE-1], USB_MODE_ACK_OUT   ; ACK the endpoint
0764: 56 22 00 MOV   [X+34],0x0         (1194)     MOV   [X+USBUART_1_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
0767: 80 07    JMP   0x076F             (1195)     JMP   .exit1
                                        (1196) ; Jump here for an IN Endpoint
                                        (1197) .in:
0769: 63 C3 0C MOV   REG[X+0xC3],0xC    (1198)     MOV   REG[X+USBUART_1_EP1MODE-1], USB_MODE_NAK_IN ; NAK the endpoint
076C: 56 22 01 MOV   [X+34],0x1         (1199)     MOV   [X+USBUART_1_EndpointAPIStatus], EVENT_PENDING ; For the API
076F: 70 EF    AND   F,0xEF             
                                        (1200) ; Jump or flow here to set the API event and exit
                                        (1201) .exit1:
                                        (1202) 	M8C_SetBank0
                                        (1203) .exit2:
0771: 7F       RET                      (1204)     RET
                                        (1205) 
                                        (1206) 
                                        (1207) ; End of File USBUART_1_std.asm
FILE: lib\usbuart_1_drv.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_drv.asm
                                        (0004) ;;  Version: 1.60, Updated on 2013/5/19 at 10:44:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USBUART control endpoint driver
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "USBUART_1_macros.inc"
                                        (0025) include "USBUART_1.inc"
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export  USBUART_1_EP0_ISR
                                        (0031) export _USBUART_1_EP0_ISR
                                        (0032) export  USBUART_1_InitControlRead
                                        (0033) export _USBUART_1_InitControlRead
                                        (0034) export  USBUART_1_InitControlWrite
                                        (0035) export _USBUART_1_InitControlWrite
                                        (0036) export  USBUART_1_InitNoDataStageControlTransfer
                                        (0037) export _USBUART_1_InitNoDataStageControlTransfer
                                        (0038) export  USBUART_1_NoDataStageControlTransfer
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Macro Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) ;-----------------------------------------------
                                        (0045) ;  Constant Definitions
                                        (0046) ;-----------------------------------------------
                                        (0047) 
                                        (0048) ;-----------------------------------------------
                                        (0049) ; Variable Allocation
                                        (0050) ;-----------------------------------------------
                                        (0051) AREA InterruptRAM (RAM,REL,CON)
                                        (0052) ;----------------------------------------------------------------------------
                                        (0053) ; Current Device
                                        (0054) ;----------------------------------------------------------------------------
                                        (0055) EXPORT USBUART_1_bCurrentDevice, _USBUART_1_bCurrentDevice
                                        (0056)  USBUART_1_bCurrentDevice:
                                        (0057) _USBUART_1_bCurrentDevice:              BLK   1    ;  Current Device
                                        (0058) ;----------------------------------------------------------------------------
                                        (0059) ; Current Configuration
                                        (0060) ;----------------------------------------------------------------------------
                                        (0061) EXPORT USBUART_1_Configuration, _USBUART_1_Configuration
                                        (0062)  USBUART_1_Configuration:
                                        (0063) _USBUART_1_Configuration:               BLK   1    ;  Current Configuration
                                        (0064) ;----------------------------------------------------------------------------
                                        (0065) ; Current Device Status
                                        (0066) ;----------------------------------------------------------------------------
                                        (0067) EXPORT USBUART_1_DeviceStatus, _USBUART_1_DeviceStatus
                                        (0068)  USBUART_1_DeviceStatus:
                                        (0069) _USBUART_1_DeviceStatus:                BLK   1    ;  Current Device Status
                                        (0070) ;----------------------------------------------------------------------------
                                        (0071) ; Interface Setting
                                        (0072) ;----------------------------------------------------------------------------
                                        (0073) EXPORT USBUART_1_InterfaceSetting, _USBUART_1_InterfaceSetting
                                        (0074)  USBUART_1_InterfaceSetting:
                                        (0075) _USBUART_1_InterfaceSetting:            BLK   2    ; Interface Setting
                                        (0076) ;----------------------------------------------------------------------------
                                        (0077) ; Endpoint Status--USB Status
                                        (0078) ;----------------------------------------------------------------------------
                                        (0079) EXPORT USBUART_1_EndpointStatus, _USBUART_1_EndpointStatus
                                        (0080)  USBUART_1_EndpointStatus:
                                        (0081) _USBUART_1_EndpointStatus:              BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0082) ;----------------------------------------------------------------------------
                                        (0083) ; Last Packet Size
                                        (0084) ;----------------------------------------------------------------------------
                                        (0085) EXPORT USBUART_1_LastSize 
                                        (0086)  USBUART_1_LastSize:                    BLK   1    ; Last Packet Size
                                        (0087) ;----------------------------------------------------------------------------
                                        (0088) ; Control Transfer State Machine
                                        (0089) ; State values for Control Write
                                        (0090) ; State values for Control Read
                                        (0091) ;----------------------------------------------------------------------------
                                        (0092) EXPORT USBUART_1_TransferType 
                                        (0093)  USBUART_1_TransferType:                BLK   1    ; Control Transfer State Machine
                                        (0094) ;----------------------------------------------------------------------------
                                        (0095) ; Control Transfer Intermediate Buffer--Shared among the requests
                                        (0096) ;----------------------------------------------------------------------------
                                        (0097) EXPORT USBUART_1_TransferBuffer 
                                        (0098)  USBUART_1_TransferBuffer:              BLK   8
                                        (0099) ;----------------------------------------------------------------------------
                                        (0100) ; Transfer Descriptor Data for Control Transfer
                                        (0101) ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
                                        (0102) ;----------------------------------------------------------------------------
                                        (0103) ; Control Transfer Data Source
                                        (0104) ;   USB_DS_ROM
                                        (0105) ;   USB_DS_RAM
                                        (0106) ;   USB_DS_RAM_AS_NEEDED
                                        (0107) ;----------------------------------------------------------------------------
                                        (0108) EXPORT USBUART_1_CurrentTD, _USBUART_1_CurrentTD
                                        (0109) _USBUART_1_CurrentTD:
                                        (0110)  USBUART_1_CurrentTD:
                                        (0111) EXPORT USBUART_1_DataSource, _USBUART_1_DataSource
                                        (0112) _USBUART_1_DataSource:
                                        (0113)  USBUART_1_DataSource:                  BLK   1
                                        (0114) ;----------------------------------------------------------------------------
                                        (0115) ; Control Transfer Data Size
                                        (0116) ;----------------------------------------------------------------------------
                                        (0117) EXPORT USBUART_1_TransferSize, _USBUART_1_TransferSize
                                        (0118) _USBUART_1_TransferSize:
                                        (0119)  USBUART_1_TransferSize:                BLK   2
                                        (0120) ;----------------------------------------------------------------------------
                                        (0121) ; Control Transfer Data Pointer
                                        (0122) ;   Source for Control Read
                                        (0123) ;   Destination for Control Write
                                        (0124) ;----------------------------------------------------------------------------
                                        (0125) EXPORT USBUART_1_DataPtr, _USBUART_1_DataPtr
                                        (0126) _USBUART_1_DataPtr: 
                                        (0127)  USBUART_1_DataPtr:                     BLK   2
                                        (0128) ;----------------------------------------------------------------------------
                                        (0129) ; Transfer Completion Notification
                                        (0130) ;----------------------------------------------------------------------------
                                        (0131) EXPORT USBUART_1_StatusBlockPtr, _USBUART_1_StatusBlockPtr
                                        (0132) _USBUART_1_StatusBlockPtr: 
                                        (0133)  USBUART_1_StatusBlockPtr:              BLK   2
                                        (0134) 
                                        (0135) ;----------------------------------------------------------------------------
                                        (0136) ; Control Transfer _TransferByteCount (Actually transferred)
                                        (0137) ;----------------------------------------------------------------------------
                                        (0138)  USBUART_1_TransferByteCount:              BLK   2
                                        (0139) 
                                        (0140) ;----------------------------------------------------------------------------
                                        (0141) ; Control Endpoint Data toggle
                                        (0142) EXPORT USBUART_1_EPDataToggle, _USBUART_1_EPDataToggle
                                        (0143)  _USBUART_1_EPDataToggle:
                                        (0144)  USBUART_1_EPDataToggle:
                                        (0145)  USBUART_1_EP0DataToggle:               BLK   1
                                        (0146) ;----------------------------------------------------------------------------
                                        (0147) ; Control Endpoint Data Pending Flag
                                        (0148) EXPORT USBUART_1_fDataPending
                                        (0149)  USBUART_1_fDataPending:                BLK   1
                                        (0150) ;----------------------------------------------------------------------------
                                        (0151) ; Control Endpoint Data Pending Flag
                                        (0152) ;EXPORT USBUART_1_PendingData
                                        (0153) ;  USBUART_1_PendingData:               BLK   1
                                        (0154) ;----------------------------------------------------------------------------
                                        (0155) ; Temporary Data registers
                                        (0156) EXPORT USBUART_1_t2, USBUART_1_t1, USBUART_1_t0
                                        (0157)  USBUART_1_t2:                          BLK   1    ; Temporary shared by the UM
                                        (0158)  USBUART_1_t1:                          BLK   1    ; Temporary shared by the UM
                                        (0159)  USBUART_1_t0:                          BLK   1    ; Temporary shared by the UM
                                        (0160) 
                                        (0161) ;EXPORT USBUART_1_IntState
                                        (0162) ; USBUART_1_IntState:                   BLK  1
                                        (0163) ;EXPORT USBUART_1_StackPointer
                                        (0164) ; USBUART_1_StackPointer:               BLK  1
                                        (0165) ;EXPORT USBUART_1_TempMode
                                        (0166) ; USBUART_1_TempMode:                   BLK 1
                                        (0167) ;----------------------------------------------------------------------------
                                        (0168) ; Endpoint Transfer--API Status
                                        (0169) ;----------------------------------------------------------------------------
                                        (0170) EXPORT USBUART_1_EndpointAPIStatus, _USBUART_1_EndpointAPIStatus
                                        (0171)  USBUART_1_EndpointAPIStatus:
                                        (0172) _USBUART_1_EndpointAPIStatus:           BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0173) 
                                        (0174) AREA UserModules (ROM, REL)
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) ;  FUNCTION NAME: USBUART_1_EP0_ISR
                                        (0177) 
                                        (0178) ;
                                        (0179) ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                                        (0180) ;                 dispatches all SETUP, IN, and OUT transfers to the proper
                                        (0181) ;                 dispatch routines for all supported USB requests.
                                        (0182) ;
                                        (0183) ;-----------------------------------------------------------------------------
                                        (0184) ;
                                        (0185) ;  ARGUMENTS:   n/a
                                        (0186) ;
                                        (0187) ;  RETURNS:     n/a
                                        (0188) ;
                                        (0189) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0190) ;
                                        (0191) ;  THEORY of OPERATION or PROCEDURE:
                                        (0192) ;
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194)  USBUART_1_EP0_ISR:
                                        (0195) _USBUART_1_EP0_ISR:
0772: 08       PUSH  A                  (0196)     PUSH A
0773: 10       PUSH  X                  (0197)     PUSH X
0774: 5D D5    MOV   A,REG[0xD5]        
0776: 08       PUSH  A                  
0777: 5D D4    MOV   A,REG[0xD4]        
0779: 08       PUSH  A                  
077A: 62 D5 00 MOV   REG[0xD5],0x0      
077D: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0198)     REG_PRESERVE MVW_PP
                                        (0199)     REG_PRESERVE MVR_PP
                                        (0200) 
                                        (0201)     RAM_SETPAGE_MVW 0
                                        (0202)     RAM_SETPAGE_MVR 0
                                        (0203) 
                                        (0204)     ; Dispatch to setup/in/out handlers
0780: 5D 56    MOV   A,REG[0x56]        (0205)     MOV  A, reg[USBUART_1_EP0MODE]      ; Get the mode reg
                                        (0206) 
0782: 5C       MOV   X,A                (0207)     MOV     X, A ; store for later
                                        (0208)     ; Check EP0_CR for the following cases:
                                        (0209)     ; bit 7 is set but ack is not set or mode is not 1 => invalid setup
                                        (0210)     ; bit 7 is not set, bit 5 or 6 is set, but bit 4 is not set => invalid in/out
0783: 21 9F    AND   A,0x9F             (0211)     AND     A, 9Fh
0785: 39 91    CMP   A,0x91             (0212)     CMP     A, 91h
0787: A0 43    JZ    0x07CB             (0213)     JZ      USBUART_1_EP0_Setup
                                        (0214)     ; Check if setup bit is set--if so then invalid EP0_CR reg read so exit
0789: 21 80    AND   A,0x80             (0215)     AND     A, 80h
                                        (0216)     ; Getting here means there is an invalid setup; exit without modifying the mode
078B: B0 36    JNZ   0x07C2             (0217)     JNZ     USBUART_1_EP0_ISR_EXIT
                                        (0218)     ; Getting here means the setup bit is not set, now check in/out
078D: 5B       MOV   A,X                (0219)     MOV     A, X   ; restore EP0_CR reg as read
078E: 21 70    AND   A,0x70             (0220)     AND     A, 70h
0790: 39 50    CMP   A,0x50             (0221)     CMP     A, 50h
0792: A0 62    JZ    0x07F5             (0222)     JZ      USBUART_1_EP0_IN
0794: 39 30    CMP   A,0x30             (0223)     CMP     A, 30h
0796: A0 6C    JZ    0x0803             (0224)     JZ      USBUART_1_EP0_OUT
                                        (0225)     ; Getting here means there is an invalid in/out; exit without modifying the mode
0798: 80 29    JMP   0x07C2             (0226)     JMP     USBUART_1_EP0_ISR_EXIT  
                                        (0227) 
                                        (0228) ; ISR Exit Point to update the mode register
                                        (0229) ;   mode and count have been pushed onto the stack
                                        (0230) EXPORT USBUART_1_EP0_UPD_MODE_EXIT
                                        (0231) USBUART_1_EP0_UPD_MODE_EXIT:
079A: 53 21    MOV   [0x21],A           (0232)     MOV     [USBUART_1_t0], A                    ; store EP0_CNT reg value for later
079C: 5D 56    MOV   A,REG[0x56]        (0233)     MOV     A, REG[USBUART_1_EP0MODE]            ; unlock registers  
079E: 21 80    AND   A,0x80             (0234)     AND     A, 80h                                      ; Check if SETUP bit is set
07A0: B0 21    JNZ   0x07C2             (0235)     JNZ     USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR	
07A2: 51 21    MOV   A,[0x21]           (0236)     MOV     A, [USBUART_1_t0]                    ; restore EP0_CNT reg value
07A4: 60 57    MOV   REG[0x57],A        (0237)     MOV     REG[USBUART_1_EP0CNT], A             ; Update the count register
07A6: 5D 57    MOV   A,REG[0x57]        (0238)     MOV     A, REG[USBUART_1_EP0CNT]             ; writing check
07A8: 3A 21    CMP   A,[0x21]           (0239)     CMP     A, [USBUART_1_t0]                    ; if writing was not succesful,
07AA: B0 17    JNZ   0x07C2             (0240)     JNZ     USBUART_1_EP0_ISR_EXIT               ;         then abort the ISR    
                                        (0241) 
07AC: 5A 21    MOV   [0x21],X           (0242)     MOV     [USBUART_1_t0], X                     ; store EP0_MODE reg value for later
                                        (0243) .ReWriteMODE:
07AE: 5D 56    MOV   A,REG[0x56]        (0244)     MOV     A, REG[USBUART_1_EP0MODE]             ; unblock registers    
07B0: 21 80    AND   A,0x80             (0245)     AND     A, 80h                                      ; Check if SETUP bit is set
07B2: B0 0F    JNZ   0x07C2             (0246)     JNZ     USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0247)     
07B4: 51 21    MOV   A,[0x21]           (0248)     MOV     A, [USBUART_1_t0]                     ; restore the new MODE
07B6: 60 56    MOV   REG[0x56],A        (0249)     MOV     REG[USBUART_1_EP0MODE], A             ; Update the mode regiter
                                        (0250)     
07B8: 5D 56    MOV   A,REG[0x56]        (0251)     MOV     A, REG[USBUART_1_EP0MODE]             ; writing check
07BA: 21 0F    AND   A,0xF              (0252)     AND     A,  0Fh                                     ; clear 7-4 bits
07BC: 3A 21    CMP   A,[0x21]           (0253)     CMP     A, [USBUART_1_t0]                     ; if writing was succesful,
07BE: A0 03    JZ    0x07C2             (0254)     JZ      USBUART_1_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0255)                                                          ; if writing was not succesful,
07C0: 8F ED    JMP   0x07AE             (0256)     JMP      .ReWriteMODE                                 ;           then repeat write operation   
07C2: 18       POP   A                  
07C3: 60 D4    MOV   REG[0xD4],A        
07C5: 18       POP   A                  
07C6: 60 D5    MOV   REG[0xD5],A        
                                        (0257) 
                                        (0258) ; Common Exit Point
                                        (0259) USBUART_1_EP0_ISR_EXIT:
                                        (0260)     REG_RESTORE MVR_PP
                                        (0261)     REG_RESTORE MVW_PP
07C8: 20       POP   X                  (0262)     POP  X                              ;
07C9: 18       POP   A                  (0263)     POP  A                              ; Restore Context
07CA: 7E       RETI                     (0264)     RETI
                                        (0265) 
                                        (0266) 
                                        (0267) ;-----------------------------------------------------------------------------
                                        (0268) ;  FUNCTION NAME: USBUART_1_EP0_Setup
                                        (0269) ;
                                        (0270) ;  DESCRIPTION:   Dispatch a USB SETUP
                                        (0271) ;
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273)  USBUART_1_EP0_Setup:
                                        (0274) _USBUART_1_EP0_Setup:
                                        (0275) ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
07CB: 5D 56    MOV   A,REG[0x56]        (0276)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
07CD: 60 56    MOV   REG[0x56],A        (0277)     MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
07CF: 5D 56    MOV   A,REG[0x56]        (0278)     MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
07D1: 21 80    AND   A,0x80             (0279)     AND     A, 80h                              ; Check if SETUP bit is set
07D3: BF EE    JNZ   0x07C2             (0280)     JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
07D5: 08       PUSH  A                  (0281)     PUSH    A                          ; Save the mode register
07D6: 50 02    MOV   A,0x2              (0282)     MOV     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
07D8: 91 F3    CALL  0x09CD             (0283)     CALL    USBUART_1_UpdateStatusBlock
07DA: 18       POP   A                  (0284)     POP     A                          ; Restore the mode register
07DB: 5D 57    MOV   A,REG[0x57]        (0285)     MOV    A, REG[USBUART_1_EP0CNT]          ; Get the count reg
07DD: 39 4A    CMP   A,0x4A             (0286)     CMP    A, (USB_CNT_VALID | 0x0A)
07DF: A0 03    JZ    0x07E3             (0287)     JZ      .dispatch
                                        (0288) 
07E1: 82 5C    JMP   0x0A3E             (0289)     JMP    USBUART_1_Not_Supported_Local_Drv
                                        (0290) 
                                        (0291) 
                                        (0292) ;-----------------------------------------------------------------------------
                                        (0293) ; Jump here to dispatch the request
                                        (0294) ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
                                        (0295) ; 7,6,5,1,0 determine what the request is. Bits [2:4] are default to zero. The below code
                                        (0296) ; re-organizes [bmRequestType] to the following format:
                                        (0297) ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
                                        (0298) ; "re-organization", the firmware will jump to an appropriate table to handle the request.
                                        (0299) ;-----------------------------------------------------------------------------
                                        (0300) .dispatch:
07E3: 5D 58    MOV   A,REG[0x58]        (0301)     MOV     A, REG[USBUART_1_EP0DATA+bmRequestType]   ; Get bmRequestType
07E5: 21 E3    AND   A,0xE3             (0302)     AND     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
07E7: 08       PUSH  A                  (0303)     PUSH    A                                ; store value on the stack
07E8: 67       ASR   A                  (0304)     ASR     A                                ; move bits 7-6-5 into 4-3-2's place
07E9: 67       ASR   A                  (0305)     ASR     A                                ; "asr" instruction shift all bits one place to the right.
07EA: 67       ASR   A                  (0306)     ASR     A                                ; Bit7 remains the same.
07EB: 53 1F    MOV   [0x1F],A           (0307)     MOV     [USBUART_1_t2], A                ; store shifted value
07ED: 18       POP   A                  (0308)     POP     A                                ; get original value
07EE: 2A 1F    OR    A,[0x1F]           (0309)     OR      A, [USBUART_1_t2]                ; or the two to get the 5-bit field
07F0: 21 1F    AND   A,0x1F             (0310)     AND     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                        (0311)                                              ; Bit0 is loaded with a Zero. This results in multiplying
                                        (0312)                                              ; the accumulator by 2, and the reason to multiply it by 2
                                        (0313)                                              ; is that each "jmp" instruction in the tables is two bytes long.
                                        (0314) 
07F2: 7D 0A 34 LJMP  USBUART_1_bmRequestType_Dispatch(0315)     LJMP USBUART_1_bmRequestType_Dispatch
                                        (0316) 
                                        (0317) 
                                        (0318) ;-----------------------------------------------------------------------------
                                        (0319) ;  FUNCTION NAME: USBUART_1_EP0_IN
                                        (0320) ;
                                        (0321) ;  DESCRIPTION: Handles an IN request.  Depending on the state of the
                                        (0322) ;               enumeration sequence it decides what to do next
                                        (0323) ;
                                        (0324) ;-----------------------------------------------------------------------------
                                        (0325)  USBUART_1_EP0_IN:
                                        (0326) _USBUART_1_EP0_IN:
07F5: 5D 56    MOV   A,REG[0x56]        (0327)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
                                        (0328) ;    MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
                                        (0329) ;    MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
                                        (0330) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0331) ;    JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
07F7: 51 0B    MOV   A,[0xB]            (0332)     MOV  A, [USBUART_1_TransferType]
                                        (0333) USBUART_1_ControlInDispatch:
07F9: E0 01    JACC  0x07FB             (0334)     JACC    USBUART_1_ControlInDispatchTable
                                        (0335) USBUART_1_ControlInDispatchTable:
07FB: 82 42    JMP   0x0A3E             (0336)     JMP     USBUART_1_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
07FD: 80 39    JMP   0x0837             (0337)     JMP     USBUART_1_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
07FF: 80 B9    JMP   0x08B9             (0338)     JMP     USBUART_1_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
0801: 80 C4    JMP   0x08C6             (0339)     JMP     USBUART_1_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0340) 
                                        (0341) 
                                        (0342) ;-----------------------------------------------------------------------------
                                        (0343) ;  FUNCTION NAME: USBUART_1_EP0_OUT
                                        (0344) ;
                                        (0345) ;  DESCRIPTION: HANDles an OUT request.  Depending on the state of the
                                        (0346) ;               enumeration sequence it decides what to do next
                                        (0347) ;
                                        (0348) ;-----------------------------------------------------------------------------
                                        (0349)  USBUART_1_EP0_OUT:
                                        (0350) _USBUART_1_EP0_OUT:
0803: 5D 56    MOV   A,REG[0x56]        (0351)     MOV     A, REG[USBUART_1_EP0MODE]    ; unlock registers
                                        (0352) ;    MOV     REG[USBUART_1_EP0MODE], A ; clear setup bit 
                                        (0353) ;    MOV     A, REG[USBUART_1_EP0MODE]    ; (re)read register
                                        (0354) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0355) ;    JNZ     USBUART_1_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
0805: 51 0B    MOV   A,[0xB]            (0356)     MOV     A, [USBUART_1_TransferType]
0807: E0 01    JACC  0x0809             (0357)     JACC    USBUART_1_ControlOutDispatchTable
                                        (0358) USBUART_1_ControlOutDispatchTable:
0809: 82 34    JMP   0x0A3E             (0359)     JMP     USBUART_1_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
080B: 80 2D    JMP   0x0839             (0360)     JMP     USBUART_1_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
080D: 80 5E    JMP   0x086C             (0361)     JMP     USBUART_1_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
080F: 80 D0    JMP   0x08E0             (0362)     JMP     USBUART_1_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0363) 
                                        (0364) ;-----------------------------------------------------------------------------
                                        (0365) ;  FUNCTION NAME: USBUART_1_InitControlRead
                                        (0366) ;
                                        (0367) ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
                                        (0368) ;                 not called.  It assumes a transfer descriptor has been loaded
                                        (0369) ;                 into the driver USBUART_1_CurrentTD data structure.
                                        (0370) ;
                                        (0371) ;-----------------------------------------------------------------------------
                                        (0372)  USBUART_1_InitControlRead:
                                        (0373) _USBUART_1_InitControlRead:
0811: 53 0A    MOV   [0xA],A            (0374)     MOV     [USBUART_1_LastSize], A    ; Save the packet size?
0813: 91 CE    CALL  0x09E3             (0375)     CALL    USBUART_1_InitializeStatusBlock
0815: 55 0B 02 MOV   [0xB],0x2          (0376)     MOV     [USBUART_1_TransferType], USB_TRANS_STATE_CONTROL_READ
                                        (0377) 
                                        (0378)     ; Check the transfer size against the request size
0818: 5D 5F    MOV   A,REG[0x5F]        (0379)     MOV    A, REG[USBUART_1_EP0DATA+wLengthHi] ; MSB of wLength
081A: 3A 15    CMP   A,[0x15]           (0380)     CMP    A, [USBUART_1_TransferSize]
081C: B0 07    JNZ   0x0824             (0381)     JNZ    .L1
                                        (0382) 
081E: 5D 5E    MOV   A,REG[0x5E]        (0383)     MOV    A, REG[USBUART_1_EP0DATA+wLengthLo] ; LSB of wLength
0820: 3A 16    CMP   A,[0x16]           (0384)     CMP    A, [USBUART_1_TransferSize+1]
0822: A0 09    JZ    0x082C             (0385)     JZ     .L9
                                        (0386) .L1:
0824: D0 07    JNC   0x082C             (0387)     JNC    .L9
                                        (0388) ;
0826: 53 16    MOV   [0x16],A           (0389)     MOV    [USBUART_1_TransferSize+1], A ;
0828: 5D 5F    MOV   A,REG[0x5F]        (0390)     MOV    A, REG[USBUART_1_EP0DATA+wLengthHi] ;
082A: 53 15    MOV   [0x15],A           (0391)     MOV    [USBUART_1_TransferSize], A ;
                                        (0392) .L9:
082C: 55 1B 00 MOV   [0x1B],0x0         (0393)     MOV    [USBUART_1_TransferByteCount], 0 ;
082F: 55 1C 00 MOV   [0x1C],0x0         (0394)     MOV    [USBUART_1_TransferByteCount+1], 0 ;
                                        (0395) 
0832: 2E 1D 01 OR    [0x1D],0x1         (0396)     OR     [USBUART_1_EP0DataToggle], 1 ; setup EP0 data toggle
0835: 80 B4    JMP   0x08EA             (0397)     JMP    USBUART_1_LoadEndpoint      ;
                                        (0398) ;-----------------------------------------------------------------------------
                                        (0399) ;  FUNCTION NAME: USBUART_1_ControlReadDataStage
                                        (0400) ;
                                        (0401) ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
                                        (0402) ;                 must be JUMPed to, not called.  It assumes a transfer descriptor
                                        (0403) ;                 has been loaded into the driver USBUART_1_CurrentTD
                                        (0404) ;                 data structure.
                                        (0405) ;
                                        (0406) ;-----------------------------------------------------------------------------
                                        (0407)  USBUART_1_ControlReadDataStage:
0837: 80 B2    JMP   0x08EA             (0408)     JMP     USBUART_1_LoadEndpoint
                                        (0409) 
                                        (0410) ;-----------------------------------------------------------------------------
                                        (0411) ;  FUNCTION NAME: USBUART_1_ControlReadStatusStage
                                        (0412) ;
                                        (0413) ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
                                        (0414) ;                 must be JUMPed to, not called.  It handles short or 0 packet
                                        (0415) ;                 It assumes a transfer descriptor has been loaded into the
                                        (0416) ;                 driver USBUART_1_CurrentTD data structure.
                                        (0417) ;
                                        (0418) ;-----------------------------------------------------------------------------
                                        (0419)  USBUART_1_ControlReadStatusStage:
0839: 51 0A    MOV   A,[0xA]            (0420)     MOV    A, [USBUART_1_LastSize]     ; Get the number of bytes from the last transfer
083B: 04 1C    ADD   [0x1C],A           (0421)     ADD    [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
083D: 0E 1B 00 ADC   [0x1B],0x0         (0422)     ADC    [USBUART_1_TransferByteCount], 0 ;
0840: 50 01    MOV   A,0x1              (0423)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
0842: 91 89    CALL  0x09CD             (0424)     CALL   USBUART_1_UpdateStatusBlock
0844: 55 0B 00 MOV   [0xB],0x0          (0425)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE
0847: 50 00    MOV   A,0x0              (0426)     MOV    A, 0                        ; Count Register
0849: 57 03    MOV   X,0x3              (0427)     MOV    X, USB_MODE_STALL_IN_OUT
084B: 8F 4E    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0428)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: USBUART_1_NoDataStageControlTransfer
                                        (0431) ;                 USBUART_1_InitNoDataStageControlTransfer
                                        (0432) ;
                                        (0433) ;  DESCRIPTION:   This routine processes the status stage of a no data control
                                        (0434) ;                 write.  It must be JUMPed to, not called.
                                        (0435) ;
                                        (0436) ;-----------------------------------------------------------------------------
                                        (0437)  USBUART_1_NoDataStageControlTransfer:
                                        (0438) _USBUART_1_InitNoDataStageControlTransfer:
                                        (0439)  USBUART_1_InitNoDataStageControlTransfer:
084D: 91 94    CALL  0x09E3             (0440)     CALL    USBUART_1_InitializeStatusBlock
                                        (0441) 
084F: 55 0B 06 MOV   [0xB],0x6          (0442)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0443) 
0852: 50 00    MOV   A,0x0              (0444)     MOV    A, 0                        ; Count Register
0854: 57 06    MOV   X,0x6              (0445)     MOV    X, USB_MODE_STATUS_IN_ONLY
0856: 8F 43    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0446)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0447) 
                                        (0448) 
                                        (0449) ;-----------------------------------------------------------------------------
                                        (0450) ;  FUNCTION NAME: USBUART_1_InitControlWrite
                                        (0451) ;
                                        (0452) ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
                                        (0453) ;                 to, not called.  It assumes a transfer descriptor has been loaded
                                        (0454) ;                 into the driver USBUART_1_CurrentTD data structure.
                                        (0455) ;
                                        (0456) ;-----------------------------------------------------------------------------
                                        (0457)  USBUART_1_InitControlWrite:
                                        (0458) _USBUART_1_InitControlWrite:
0858: 51 14    MOV   A,[0x14]           (0459)     MOV     A, [USBUART_1_DataSource]  ; Need to make sure the destination is not ROM
085A: 39 00    CMP   A,0x0              (0460)     CMP     A, USB_DS_ROM
085C: A1 E1    JZ    0x0A3E             (0461)     JZ      USBUART_1_Not_Supported_Local_Drv
                                        (0462) 
085E: 91 83    CALL  0x09E3             (0463)     CALL    USBUART_1_InitializeStatusBlock
                                        (0464) 
0860: 55 0B 04 MOV   [0xB],0x4          (0465)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_CONTROL_WRITE
                                        (0466) 
0863: 2E 1D 01 OR    [0x1D],0x1         (0467)     OR     [USBUART_1_EP0DataToggle], 1 ; setup EP0 data toggle
                                        (0468) 
0866: 50 00    MOV   A,0x0              (0469)     MOV    A, 0                        ; Count Register
0868: 57 0B    MOV   X,0xB              (0470)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
086A: 8F 2F    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0471)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0472) 
                                        (0473) 
                                        (0474) ;-----------------------------------------------------------------------------
                                        (0475) ;  FUNCTION NAME: USBUART_1_ControlWriteDataStage
                                        (0476) ;
                                        (0477) ;  DESCRIPTION:   This routine processes the data stage of a control
                                        (0478) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0479) ;                 transfer descriptor has been loaded into the driver
                                        (0480) ;                 USBUART_1_CurrentTD data structure.
                                        (0481) ;
                                        (0482) ;-----------------------------------------------------------------------------
                                        (0483)  USBUART_1_ControlWriteDataStage:
086C: 36 1D 01 XOR   [0x1D],0x1         (0484)     XOR    [USBUART_1_EP0DataToggle], 1  ; Update data toggle
                                        (0485) 
086F: 5D 57    MOV   A,REG[0x57]        (0486)     MOV    A,REG[USBUART_1_EP0CNT]     ; Get the count
                                        (0487) 
0871: 21 0F    AND   A,0xF              (0488)     AND     A, 0x0F
0873: 11 02    SUB   A,0x2              (0489)     SUB     A, 2                       ; Count include the two byte checksum
                                        (0490) 
0875: 53 1F    MOV   [0x1F],A           (0491)     MOV     [USBUART_1_t2], A          ; Assume we have room to receive the whole packet
                                        (0492) 
0877: 50 00    MOV   A,0x0              (0493)     MOV     A, 0
0879: 3A 15    CMP   A,[0x15]           (0494)     CMP     A, [USBUART_1_TransferSize]  ; If the MSB has anything just use the count
087B: B0 07    JNZ   0x0883             (0495)     JNZ     .L1
                                        (0496) 
087D: 51 1F    MOV   A,[0x1F]           (0497)     MOV     A, [USBUART_1_t2]
087F: 3A 16    CMP   A,[0x16]           (0498)     CMP     A, [USBUART_1_TransferSize+1]  ;
0881: A0 06    JZ    0x0888             (0499)     JZ      .L6
                                        (0500) .L1:
0883: C0 04    JC    0x0888             (0501)     JC      .L6
0885: 5F 1F 16 MOV   [0x1F],[0x16]      (0502)     MOV     [USBUART_1_t2], [USBUART_1_TransferSize+1]
                                        (0503) 
                                        (0504) .L6:
0888: 51 1F    MOV   A,[0x1F]           (0505)     MOV     A, [USBUART_1_t2]
088A: 14 16    SUB   [0x16],A           (0506)     SUB     [USBUART_1_TransferSize+1],A   ; Update the bytes remaining
088C: 1E 15 00 SBB   [0x15],0x0         (0507)     SBB     [USBUART_1_TransferSize], 0  ;
                                        (0508) 
088F: 04 1C    ADD   [0x1C],A           (0509)     ADD     [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
0891: 0E 1B 00 ADC   [0x1B],0x0         (0510)     ADC     [USBUART_1_TransferByteCount], 0 ;
                                        (0511) 
0894: 57 00    MOV   X,0x0              (0512)     MOV     X,0                        ; Start the index at 0
0896: 5D D5    MOV   A,REG[0xD5]        
0898: 08       PUSH  A                  
                                        (0513) 
                                        (0514) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0515)     REG_PRESERVE MVW_PP
0899: 51 17    MOV   A,[0x17]           (0516)     mov     A, [USBUART_1_DataPtr]  ; set proper page for mvi command
089B: 60 D5    MOV   REG[0xD5],A        (0517)     mov     reg[MVW_PP], A
                                        (0518) ENDIF
                                        (0519) .RAM_COPY:
089D: 5E 58    MOV   A,REG[X+0x58]      (0520)     MOV     A, REG[X+USBUART_1_EP0DATA]  ; Get the data
089F: 3F 18    MVI   [0x18],A           (0521)     MVI     [USBUART_1_DataPtr+1], A   ; Store the data, bump the destination
                                        (0522) 
08A1: 75       INC   X                  (0523)     INC     X                          ; Bump the destination offset
08A2: 5B       MOV   A,X                (0524)     MOV     A,X                        ; Are we done?
08A3: 3A 1F    CMP   A,[0x1F]           (0525)     CMP     A, [USBUART_1_t2]
08A5: CF F7    JC    0x089D             (0526)     JC      .RAM_COPY                  ; Not done
08A7: 18       POP   A                  
08A8: 60 D5    MOV   REG[0xD5],A        
                                        (0527) 
                                        (0528) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0529)     REG_RESTORE MVW_PP
                                        (0530) ENDIF
08AA: 50 00    MOV   A,0x0              (0531)     MOV    A, 0                        ; Count Register
08AC: 57 0B    MOV   X,0xB              (0532)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
08AE: 8E EB    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0533)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0534) 
                                        (0535) ; Jump here on data toggle error
                                        (0536) .error:
08B0: 55 0B 00 MOV   [0xB],0x0          (0537)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE  ; This simply aborts the transfer
08B3: 50 00    MOV   A,0x0              (0538)     MOV    A, 0                        ; Count Register
08B5: 57 03    MOV   X,0x3              (0539)     MOV    X, USB_MODE_STALL_IN_OUT
08B7: 8E E2    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0540)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0541) 
                                        (0542) 
                                        (0543) ;-----------------------------------------------------------------------------
                                        (0544) ;  FUNCTION NAME: USBUART_1_ControlWriteStatusStage
                                        (0545) ;
                                        (0546) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0547) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0548) ;                 transfer descriptor has been loaded into the driver
                                        (0549) ;                 USBUART_1_CurrentTD data structure.
                                        (0550) ;
                                        (0551) ;-----------------------------------------------------------------------------
                                        (0552)  USBUART_1_ControlWriteStatusStage:
08B9: 50 01    MOV   A,0x1              (0553)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
08BB: 91 10    CALL  0x09CD             (0554)     CALL   USBUART_1_UpdateStatusBlock
08BD: 55 0B 00 MOV   [0xB],0x0          (0555)     MOV    [USBUART_1_TransferType], USB_TRANS_STATE_IDLE  ; The packet is done
08C0: 50 00    MOV   A,0x0              (0556)     MOV    A, 0                        ; Count Register
08C2: 57 03    MOV   X,0x3              (0557)     MOV    X, USB_MODE_STALL_IN_OUT
08C4: 8E D5    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0558)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0559) 
                                        (0560) 
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: USBUART_1_NoDataControlStatusStage
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0565) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0566) ;                 transfer descriptor has been loaded into the driver
                                        (0567) ;                 USBUART_1_CurrentTD data structure.
                                        (0568) ;
                                        (0569) ;                 USB Device Addressing happens here because we can't change
                                        (0570) ;                 the SIE Address before the Status IN is received.
                                        (0571) ;
                                        (0572) ;-----------------------------------------------------------------------------
                                        (0573)  USBUART_1_NoDataControlStatusStage:
08C6: 50 01    MOV   A,0x1              (0574)     MOV     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
08C8: 91 03    CALL  0x09CD             (0575)     CALL    USBUART_1_UpdateStatusBlock
                                        (0576)     ; Dispatch to the proper handler
08CA: 3C 1E 01 CMP   [0x1E],0x1         (0577)     CMP     [USBUART_1_fDataPending], USB_ADDRESS_CHANGE_PENDING
08CD: B0 09    JNZ   0x08D7             (0578)     JNZ     .L1
                                        (0579) 
                                        (0580)     ; USB ADDRESS CHANGE
08CF: 51 0C    MOV   A,[0xC]            (0581)     MOV     A, [USBUART_1_TransferBuffer]  ; Get the pending data
                                        (0582) 
08D1: 29 80    OR    A,0x80             (0583)     OR      A, USB_ADDR_ENABLE         ; Set the enable bit
08D3: 60 4A    MOV   REG[0x4A],A        (0584)     MOV     REG[USBUART_1_ADDR], A     ; Update the SIE address
08D5: 80 01    JMP   0x08D7             (0585)     JMP     .EXIT
                                        (0586) .L1:
                                        (0587) 
                                        (0588) .EXIT:
08D7: 55 1E 00 MOV   [0x1E],0x0         (0589)     MOV     [USBUART_1_fDataPending], 0  ; Clear data pending
                                        (0590) 
08DA: 50 00    MOV   A,0x0              (0591)     MOV    A, 0                        ; Count Register
08DC: 57 06    MOV   X,0x6              (0592)     MOV    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
08DE: 8E BB    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0593)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0594) 
                                        (0595) 
                                        (0596) ;-----------------------------------------------------------------------------
                                        (0597) ;  FUNCTION NAME: USBUART_1_NoDataControlError
                                        (0598) ;
                                        (0599) ;  DESCRIPTION:   This routine handles the condition when we expected a
                                        (0600) ;                 status IN, but receive an OUT
                                        (0601) ;
                                        (0602) ;-----------------------------------------------------------------------------
                                        (0603)  USBUART_1_NoDataControlError:
08E0: 50 03    MOV   A,0x3              (0604)     MOV    A, USB_XFER_ERROR           ; Return Transaction Error
08E2: 90 E9    CALL  0x09CD             (0605)     CALL   USBUART_1_UpdateStatusBlock
08E4: 50 00    MOV   A,0x0              (0606)     MOV    A, 0                        ; Count Register
08E6: 57 03    MOV   X,0x3              (0607)     MOV    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
08E8: 8E B1    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0608)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0609) 
                                        (0610) 
                                        (0611) ;-----------------------------------------------------------------------------
                                        (0612) ;  FUNCTION NAME: USBUART_1_LoadEndpoint
                                        (0613) ;
                                        (0614) ;  DESCRIPTION: Moves data from either RAM OR ROM - depending on the request
                                        (0615) ;               type AND then places the appropriate number of bytes -
                                        (0616) ;               depending on the request size into the endpoint FIFO.
                                        (0617) ;               It finally sets up the endpoint to send data.
                                        (0618) ;
                                        (0619) USBUART_1_LoadEndpoint:
08EA: 51 0A    MOV   A,[0xA]            (0620)     MOV     A, [USBUART_1_LastSize]    ; Get the number of bytes from the last transfer
08EC: 04 1C    ADD   [0x1C],A           (0621)     ADD     [USBUART_1_TransferByteCount + 1], A ; Update the transfer byte count
08EE: 0E 1B 00 ADC   [0x1B],0x0         (0622)     ADC     [USBUART_1_TransferByteCount], 0 ;
08F1: 51 15    MOV   A,[0x15]           (0623)     MOV     A,  [USBUART_1_TransferSize] ; Check to see if we have any
08F3: 2A 16    OR    A,[0x16]           (0624)     OR      A,  [USBUART_1_TransferSize+1] ;  more data to send
08F5: B0 0E    JNZ   0x0904             (0625)     JNZ     .cont                      ; Jump if we have to send more data
                                        (0626) 
                                        (0627) ; Flow here if there is no more data to send (kvn restored following two lines to fix mod 8 descriptor issue
                                        (0628) ;                                             (no zero length EPt0 termination packets are sent with these lines gone)
08F7: 3C 0A 08 CMP   [0xA],0x8          (0629)     cmp     [USBUART_1_LastSize], 8    ; Was it a full packet?
08FA: A0 52    JZ    0x094D             (0630)     JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
                                        (0631) 
                                        (0632) ; Flow here if we are entering the status stage
08FC: 50 00    MOV   A,0x0              (0633)     MOV    A, 0                        ; Count Register
08FE: 53 0A    MOV   [0xA],A            (0634)     MOV    [USBUART_1_LastSize], A     ; Clear the byte count
0900: 57 02    MOV   X,0x2              (0635)     MOV    X, USB_MODE_STATUS_OUT_ONLY ; Only ACK the Status Out
0902: 8E 97    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0636)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0637) 
                                        (0638) ; Jump here to determine how many bytes should we transfer
                                        (0639) .cont:
0904: 3C 15 00 CMP   [0x15],0x0         (0640)     CMP     [USBUART_1_TransferSize], 0  ; Check the MSB
0907: B0 0A    JNZ   0x0912             (0641)     JNZ     .L1
                                        (0642) 
0909: 3C 16 08 CMP   [0x16],0x8         (0643)     CMP     [USBUART_1_TransferSize+1], 8  ; Check the LSB
090C: D0 05    JNC   0x0912             (0644)     JNC     .L1
                                        (0645) 
090E: 51 16    MOV   A,[0x16]           (0646)     MOV     A,[USBUART_1_TransferSize+1]   ; Transfer all the remaining data
0910: 80 03    JMP   0x0914             (0647)     JMP     .L3
                                        (0648) 
                                        (0649) .L1:
0912: 50 08    MOV   A,0x8              (0650)     MOV     A, 8                       ; Just transfer the next 8 bytes
                                        (0651) 
                                        (0652) .L3:
                                        (0653) 
0914: 14 16    SUB   [0x16],A           (0654)     SUB     [USBUART_1_TransferSize+1],A   ; Update the bytes remaining
0916: 1E 15 00 SBB   [0x15],0x0         (0655)     SBB     [USBUART_1_TransferSize],0
                                        (0656) 
0919: 53 1F    MOV   [0x1F],A           (0657)     MOV     [USBUART_1_t2],A           ; Save the count
091B: 57 00    MOV   X,0x0              (0658)     MOV     X,0
                                        (0659) 
091D: 3C 14 00 CMP   [0x14],0x0         (0660)     CMP     [USBUART_1_DataSource],USB_DS_ROM  ; RAM or ROM copy?
0920: B0 17    JNZ   0x0938             (0661)     JNZ     .RAM_COPY
                                        (0662) 
                                        (0663) ; Copy data from a ROM source
                                        (0664) .ROM_COPY:
0922: 10       PUSH  X                  (0665)     PUSH    X                          ; Save the destination offset
0923: 51 17    MOV   A,[0x17]           (0666)     MOV     A,[USBUART_1_DataPtr]      ; Get the transfer source MSB
0925: 58 18    MOV   X,[0x18]           (0667)     MOV     X,[USBUART_1_DataPtr+1]    ; Set the transfer source LSB
0927: 76 18    INC   [0x18]             (0668)     INC     [USBUART_1_DataPtr+1]      ; Increment the data pointer
0929: 0E 17 00 ADC   [0x17],0x0         (0669)     ADC     [USBUART_1_DataPtr], 0     ;   MSB if necessary
                                        (0670) 
092C: 28       ROMX                     (0671)     ROMX                               ; Get the data byte
                                        (0672) 
092D: 20       POP   X                  (0673)     POP     X                          ; Get the destination offset
092E: 61 58    MOV   REG[X+0x58],A      (0674)     MOV     REG[X + USBUART_1_EP0DATA], A ; Load the data
0930: 75       INC   X                  (0675)     INC     X                          ; Bump the destination offset
0931: 5B       MOV   A,X                (0676)     MOV     A,X                        ; Are we done?
0932: 3A 1F    CMP   A,[0x1F]           (0677)     CMP     A, [USBUART_1_t2]
0934: CF ED    JC    0x0922             (0678)     JC      .ROM_COPY                  ; Not done
0936: 80 16    JMP   0x094D             (0679)     JMP     .START_TRANSFER            ; Otherwise go start the transfer
0938: 5D D4    MOV   A,REG[0xD4]        
093A: 08       PUSH  A                  
                                        (0680) 
                                        (0681) ; Copy data from a RAM source
                                        (0682) .RAM_COPY:
                                        (0683) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0684)     REG_PRESERVE MVR_PP
093B: 51 17    MOV   A,[0x17]           (0685)     mov     A, [USBUART_1_DataPtr]  ; set proper page for mvi command
093D: 60 D4    MOV   REG[0xD4],A        (0686)     mov     reg[MVR_PP], A
                                        (0687) ENDIF
                                        (0688) .CP1:
093F: 3E 18    MVI   A,[0x18]           (0689)     MVI     A, [USBUART_1_DataPtr+1]   ; Get the data, bump the source
                                        (0690) 
0941: 61 58    MOV   REG[X+0x58],A      (0691)     MOV     REG[X +USBUART_1_EP0DATA], A ; Load the data
0943: 75       INC   X                  (0692)     INC     X                          ; Bump the destination offset
0944: 5B       MOV   A,X                (0693)     MOV     A,X                        ; Are we done?
0945: 3A 1F    CMP   A,[0x1F]           (0694)     CMP     A, [USBUART_1_t2]
0947: CF F7    JC    0x093F             (0695)     jc      .CP1                       ; Not done
0949: 18       POP   A                  
094A: 60 D4    MOV   REG[0xD4],A        
                                        (0696) 
                                        (0697) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0698)     REG_RESTORE MVR_PP
094C: 5B       MOV   A,X                (0699)     mov     A, X                       ; Restore A
                                        (0700) ENDIF
                                        (0701) 
                                        (0702) ;; Set up the IN transfer count/mode/etc
                                        (0703) ;    A contains the byte count
                                        (0704) .START_TRANSFER:
094D: 53 0A    MOV   [0xA],A            (0705)     MOV     [USBUART_1_LastSize], A    ; Save the packet size
                                        (0706) 
094F: 50 01    MOV   A,0x1              (0707)     MOV     A, 1
0951: 22 1D    AND   A,[0x1D]           (0708)     AND     A, [USBUART_1_EP0DataToggle]
0953: A0 03    JZ    0x0957             (0709)     JZ      .BYPASS_T1
0955: 50 80    MOV   A,0x80             (0710)     MOV     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
                                        (0711) 
                                        (0712) .BYPASS_T1:
0957: 2A 0A    OR    A,[0xA]            (0713)     OR      A, [USBUART_1_LastSize]
0959: 36 1D 01 XOR   [0x1D],0x1         (0714)     XOR     [USBUART_1_EP0DataToggle], 1    ; Update the data toggle for next time
                                        (0715) 
095C: 57 0F    MOV   X,0xF              (0716)     MOV    X, USB_MODE_ACK_IN_STATUS_OUT  ; Set the mode register
095E: 8E 3B    JMP   USBUART_1_EP0_UPD_MODE_EXIT(0717)     JMP    USBUART_1_EP0_UPD_MODE_EXIT
                                        (0718) 
                                        (0719) 
                                        (0720) ;-----------------------------------------------------------------------------
                                        (0721) ;  FUNCTION NAME: USBUART_1_GetTableEntry
                                        (0722) ;
                                        (0723) ;  DESCRIPTION: This function figures out based on the various bytes in the
                                        (0724) ;               setup packet where to get the data from or put the data to.
                                        (0725) ;               Transfer Data structures are defined each of the supported
                                        (0726) ;               control transfers, this function finds the right one and
                                        (0727) ;               saves it in the CurrentTD structure in RAM.  It then
                                        (0728) ;               calls InitControlRead or InitControlWrite to being the
                                        (0729) ;               transaction.
                                        (0730) ;
                                        (0731) ;-----------------------------------------------------------------------------
                                        (0732) EXPORT USBUART_1_GetTableEntry
                                        (0733) USBUART_1_GetTableEntry:
                                        (0734) 
0960: 75       INC   X                  (0735)     INC     X                          ; Point to the first table entry
0961: 09 00    ADC   A,0x0              (0736)     ADC     A, 0                       ;
0963: 08       PUSH  A                  
0964: 65 1F    ASL   [0x1F]             
0966: 65 1F    ASL   [0x1F]             
0968: 65 1F    ASL   [0x1F]             
096A: 18       POP   A                  
                                        (0737) 
                                        (0738)     TD_INDEX_TO_OFFSET USBUART_1_t2 ; Convert the index
                                        (0739) 
096B: 4B       SWAP  A,X                (0740)     SWAP    A, X
096C: 02 1F    ADD   A,[0x1F]           (0741)     ADD     A, [USBUART_1_t2]
096E: 4B       SWAP  A,X                (0742)     SWAP    A, X
096F: 09 00    ADC   A,0x0              (0743)     ADC     A, 0                       ; A:X now points to the descriptor table entry we want
                                        (0744) 
                                        (0745) ; Flow here to load the Transfer Descriptor (TD_ENTRY)
0971: 55 1F 14 MOV   [0x1F],0x14        (0746)     MOV     [USBUART_1_t2], USBUART_1_CurrentTD  ; Use Temp as MVI pointer
0974: 90 26    CALL  USBUART_1_GETBYTE  (0747)     CALL     USBUART_1_GETBYTE         ; Get the descriptor data source
0976: 90 1C    CALL  USBUART_1_GETWORD  (0748)     CALL     USBUART_1_GETWORD         ; Get the descriptor size
0978: 90 1A    CALL  USBUART_1_GETWORD  (0749)     CALL     USBUART_1_GETWORD         ; Get the descriptor address
097A: 90 18    CALL  USBUART_1_GETWORD  (0750)     CALL     USBUART_1_GETWORD         ; Get the Status Pointer
                                        (0751) ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
097C: 5D 58    MOV   A,REG[0x58]        (0752)     MOV    A, REG[USBUART_1_EP0DATA+bmRequestType] ; Get bmRequestType
097E: 21 80    AND   A,0x80             (0753)     AND     A,0x80                          ; Control Read or Write
0980: A0 03    JZ    0x0984             (0754)     JZ      .control_write
                                        (0755) 
0982: 8E 8E    JMP   _USBUART_1_InitControlRead(0756)     JMP     USBUART_1_InitControlRead
                                        (0757) 
                                        (0758) .control_write:
0984: 8E D3    JMP   _USBUART_1_InitControlWrite(0759)     JMP     USBUART_1_InitControlWrite
                                        (0760) 
                                        (0761) 
                                        (0762) ;-----------------------------------------------------------------------------
                                        (0763) ;  FUNCTION NAME: USBUART_1_LOOKUP
                                        (0764) ;
                                        (0765) ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
                                        (0766) ;
                                        (0767) ;-----------------------------------------------------------------------------
                                        (0768) ;
                                        (0769) ;  ARGUMENTS:    A:X Point to the lookup table
                                        (0770) ;                USBUART_1_t2 contain the table index
                                        (0771) ;
                                        (0772) ;  RETURNS:      Address of the LT_ENTRY in A:X
                                        (0773) ;
                                        (0774) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0775) ;
                                        (0776) ;  THEORY of OPERATION or PROCEDURE:
                                        (0777) ;
                                        (0778) ;-----------------------------------------------------------------------------
                                        (0779) EXPORT USBUART_1_LOOKUP
                                        (0780) USBUART_1_LOOKUP:
0986: 75       INC   X                  (0781)     INC     X                          ; Point to the first table entry
0987: 09 00    ADC   A,0x0              (0782)     ADC     A, 0                       ;
0989: 65 1F    ASL   [0x1F]             
098B: 65 1F    ASL   [0x1F]             
                                        (0783) 
                                        (0784)     LT_INDEX_TO_OFFSET USBUART_1_t2    ; Convert the index
098D: 4B       SWAP  A,X                (0785)     SWAP    A, X
098E: 02 1F    ADD   A,[0x1F]           (0786)     ADD     A, [USBUART_1_t2]          ;
0990: 4B       SWAP  A,X                (0787)     SWAP    A, X
0991: 09 00    ADC   A,0x0              (0788)     ADC     A, 0
0993: 7F       RET                      (0789)     RET
                                        (0790) 
                                        (0791) 
                                        (0792) ;-----------------------------------------------------------------------------
                                        (0793) ;  FUNCTION NAME: USBUART_1_GETWORD/USBUART_1_GETBYTE
                                        (0794) ;
                                        (0795) ;  DESCRIPTION:    Get a word value from ROM
                                        (0796) ;
                                        (0797) ;-----------------------------------------------------------------------------
                                        (0798) ;
                                        (0799) ;  ARGUMENTS:    A:X is the ROM Address
                                        (0800) ;                USBUART_1_t2 is the destination address
                                        (0801) ;
                                        (0802) ;  RETURNS:      USBUART_1_t1
                                        (0803) ;
                                        (0804) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0805) ;                USES USBUART_1_t2
                                        (0806) ;                A:X points to the subsequent ROM location
                                        (0807) ;  THEORY of OPERATION or PROCEDURE:
                                        (0808) ;
                                        (0809) ;-----------------------------------------------------------------------------
                                        (0810) EXPORT USBUART_1_GETWORD
                                        (0811) USBUART_1_GETWORD:
                                        (0812) 
0994: 08       PUSH  A                  (0813)     PUSH    A                          ; Don't loose the pointer MSB
0995: 28       ROMX                     (0814)     ROMX                               ; Data source flag
0996: 3F 1F    MVI   [0x1F],A           (0815)     MVI     [USBUART_1_t2], A          ; Save the data source
0998: 18       POP   A                  (0816)     POP     A                          ; Get the MSB back
0999: 75       INC   X                  (0817)     INC     X                          ; Point to the next  entry
099A: 09 00    ADC   A,0x0              (0818)     ADC     A, 0                       ;
                                        (0819) 
                                        (0820) EXPORT USBUART_1_GETBYTE
                                        (0821) USBUART_1_GETBYTE:
                                        (0822) 
099C: 08       PUSH  A                  (0823)     PUSH    A                          ; Don't loose the pointer MSB
099D: 28       ROMX                     (0824)     ROMX                               ; Data source flag
099E: 3F 1F    MVI   [0x1F],A           (0825)     MVI     [USBUART_1_t2], A          ; Save the data source
09A0: 18       POP   A                  (0826)     POP     A                          ; Get the MSB back
09A1: 75       INC   X                  (0827)     INC     X                          ; Point to the next  entry
09A2: 09 00    ADC   A,0x0              (0828)     ADC     A, 0                       ;
09A4: 7F       RET                      (0829)     RET
                                        (0830) 
                                        (0831) 
                                        (0832) ;-----------------------------------------------------------------------------
                                        (0833) ;  FUNCTION NAME: USBUART_1_GET_DEVICE_TABLE_ENTRY
                                        (0834) ;
                                        (0835) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0836) ;                  Not intended for use by C functions
                                        (0837) ;
                                        (0838) ;-----------------------------------------------------------------------------
                                        (0839) ;
                                        (0840) ;  ARGUMENTS:
                                        (0841) ;
                                        (0842) ;  RETURNS:        A:X points the current DEVICE_TABLE entry
                                        (0843) ;                  Carry flag is set if the current device index is out of range
                                        (0844) ;
                                        (0845) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0846) ;
                                        (0847) ;  THEORY of OPERATION or PROCEDURE:
                                        (0848) ;
                                        (0849) ;-----------------------------------------------------------------------------
                                        (0850) EXPORT USBUART_1_GET_DEVICE_TABLE_ENTRY
                                        (0851) USBUART_1_GET_DEVICE_TABLE_ENTRY:
09A5: 5F 1F 00 MOV   [0x1F],[0x0]       (0852)     MOV     [USBUART_1_t2], [USBUART_1_bCurrentDevice]  ; Use the UM temp var--Selector
                                        (0853) 
09A8: 50 01    MOV   A,0x1              (0854)     MOV     A,>USBUART_1_DEVICE_LOOKUP ; Get the ROM Address MSB
09AA: 57 C5    MOV   X,0xC5             (0855)     MOV     X,<USBUART_1_DEVICE_LOOKUP ; Get the ROM Address LSB
09AC: 28       ROMX                     (0856)     ROMX                               ; First entry is the table size (only a byte)
09AD: 3A 1F    CMP   A,[0x1F]           (0857)     CMP     A, [USBUART_1_t2]          ; Range check
09AF: 50 01    MOV   A,0x1              (0858)     MOV     A,>USBUART_1_DEVICE_LOOKUP ; Get the ROM Address MSB
09B1: C0 03    JC    0x09B5             (0859)     JC      .exit
                                        (0860) ; Flow here if the index is valid
09B3: 9F D1    CALL  USBUART_1_LOOKUP   (0861)     CALL    USBUART_1_LOOKUP           ; Look up the configuration
                                        (0862) ; Jump or flow here on exit
                                        (0863) .exit:
09B5: 7F       RET                      (0864)     RET
                                        (0865) 
                                        (0866) 
                                        (0867) ;-----------------------------------------------------------------------------
                                        (0868) ;  FUNCTION NAME: USBUART_1_GET_CONFIG_TABLE_ENTRY
                                        (0869) ;
                                        (0870) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0871) ;                  Not intended for use by C functions
                                        (0872) ;                  Does not do range checking on
                                        (0873) ;
                                        (0874) ;-----------------------------------------------------------------------------
                                        (0875) ;
                                        (0876) ;  ARGUMENTS:
                                        (0877) ;
                                        (0878) ;  RETURNS:        A:X points the current CONFIG_TABLE entry
                                        (0879) ;                  Carry flag is set if the current device index is out of range
                                        (0880) ;
                                        (0881) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0882) ;
                                        (0883) ;  THEORY of OPERATION or PROCEDURE:
                                        (0884) ;
                                        (0885) ;-----------------------------------------------------------------------------
                                        (0886) EXPORT USBUART_1_GET_CONFIG_TABLE_ENTRY
                                        (0887) USBUART_1_GET_CONFIG_TABLE_ENTRY:
09B6: 9F ED    CALL  USBUART_1_GET_DEVICE_TABLE_ENTRY(0888)     CALL    USBUART_1_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
09B8: 55 1F 20 MOV   [0x1F],0x20        (0889)     MOV     [USBUART_1_t2],USBUART_1_t1  ; Set the GETWORD destination
09BB: 9F D7    CALL  USBUART_1_GETWORD  (0890)     CALL    USBUART_1_GETWORD          ; Get the pointer to the CONFIG_LOOKUP table
                                        (0891)                                        ; ITempW has the address
09BD: 5D 5A    MOV   A,REG[0x5A]        (0892)     MOV     A, REG[USBUART_1_EP0DATA+wValueLo]  ; Get the configuration number
09BF: 53 1F    MOV   [0x1F],A           (0893)     MOV     [USBUART_1_t2],A           ; Save it
09C1: 51 20    MOV   A,[0x20]           (0894)     MOV     A, [USBUART_1_t1]          ; Get the CONFIG_LOOKUP ROM Address MSB
09C3: 58 21    MOV   X,[0x21]           (0895)     MOV     X, [USBUART_1_t1+1]        ; Get the CONFIG_LOOKUP ROM Address LSB
                                        (0896) 
                                        (0897) ; A:X Points to the CONFIG_LOOKUP, so get the current entry
09C5: 5F 1F 01 MOV   [0x1F],[0x1]       (0898)     MOV     [USBUART_1_t2], [USBUART_1_Configuration] ; Get the configuration number
09C8: 7A 1F    DEC   [0x1F]             (0899)     DEC     [USBUART_1_t2]             ; We don't populate the 0th entry
09CA: 9F BA    CALL  USBUART_1_LOOKUP   (0900)     CALL    USBUART_1_LOOKUP           ; Look up the configuration
09CC: 7F       RET                      (0901)     RET
                                        (0902) 
                                        (0903) 
                                        (0904) ;-----------------------------------------------------------------------------
                                        (0905) ;  FUNCTION NAME: USBUART_1_UpdateStatusBlock
                                        (0906) ;
                                        (0907) ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
                                        (0908) ;                  block is updated with the completion code from the
                                        (0909) ;                  argument (A) and the _TransferByteCount.
                                        (0910) ;
                                        (0911) ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
                                        (0912) ;                  to make sure no other updates are made to the StatusBlock by
                                        (0913) ;                  the USB User Module.
                                        (0914) ;
                                        (0915) ;-----------------------------------------------------------------------------
                                        (0916) ;
                                        (0917) ;  ARGUMENTS:      A contains the Completion Status Code
                                        (0918) ;
                                        (0919) ;  RETURNS:        None
                                        (0920) ;
                                        (0921) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0922) ;
                                        (0923) ;  THEORY of OPERATION or PROCEDURE:
                                        (0924) ;
                                        (0925) ;-----------------------------------------------------------------------------
                                        (0926) USBUART_1_UpdateStatusBlock:
09CD: 58 1A    MOV   X,[0x1A]           (0927)     MOV     X, [USBUART_1_StatusBlockPtr + 1] ;
09CF: 4B       SWAP  A,X                (0928)     SWAP    A, X                       ; Don't loose the completion code
09D0: 39 00    CMP   A,0x0              (0929)     CMP     A, 0                       ; NULL?
09D2: A0 0F    JZ    0x09E2             (0930)     JZ      .done                      ; No update on NULL
                                        (0931) ; Flow here to update the VSR Completion Status Block
09D4: 4B       SWAP  A,X                (0932)     SWAP    A, X                       ; Completion code A, Pointer in X
09D5: 54 00    MOV   [X+0],A            (0933)     MOV     [X + 0], A                 ; Update the completion Code
09D7: 51 1B    MOV   A,[0x1B]           (0934)     MOV     A, [USBUART_1_TransferByteCount] ; Actual Byte Count MSB
09D9: 54 01    MOV   [X+1],A            (0935)     MOV     [X + 1], A
09DB: 51 1C    MOV   A,[0x1C]           (0936)     MOV     A, [USBUART_1_TransferByteCount + 1] ; Actual Byte Count LSB
09DD: 54 02    MOV   [X+2],A            (0937)     MOV     [X + 2], A
09DF: 55 1A 00 MOV   [0x1A],0x0         (0938)     MOV     [USBUART_1_StatusBlockPtr + 1], 0 ; Clear the Block Pointer
                                        (0939) .done:
09E2: 7F       RET                      (0940)     RET                                ; All done
                                        (0941) 
                                        (0942) 
                                        (0943) ;-----------------------------------------------------------------------------
                                        (0944) ;  FUNCTION NAME: USBUART_1_InitializeStatusBlock
                                        (0945) ;
                                        (0946) ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
                                        (0947) ;                  The completion code is set to USB_XFER_IDLE.
                                        (0948) ;
                                        (0949) ;-----------------------------------------------------------------------------
                                        (0950) ;
                                        (0951) ;  ARGUMENTS:      None
                                        (0952) ;
                                        (0953) ;  RETURNS:        None
                                        (0954) ;
                                        (0955) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0956) ;
                                        (0957) ;  THEORY of OPERATION or PROCEDURE:
                                        (0958) ;
                                        (0959) ;-----------------------------------------------------------------------------
                                        (0960) USBUART_1_InitializeStatusBlock:
09E3: 51 1A    MOV   A,[0x1A]           (0961)     MOV     A, [USBUART_1_StatusBlockPtr + 1] ;
09E5: 39 00    CMP   A,0x0              (0962)     CMP     A, 0                       ; NULL?
09E7: A0 0B    JZ    0x09F3             (0963)     JZ      .done                      ; No update on NULL
                                        (0964) ; Flow here to initialize the Completion Status Block
09E9: 4B       SWAP  A,X                (0965)     SWAP    A, X                       ; Pointer in X
09EA: 56 00 00 MOV   [X+0],0x0          (0966)     MOV     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
09ED: 55 1B 00 MOV   [0x1B],0x0         (0967)     MOV     [USBUART_1_TransferByteCount], 0 ; Clear the byte count
09F0: 55 1C 00 MOV   [0x1C],0x0         (0968)     MOV     [USBUART_1_TransferByteCount + 1], 0 ;
                                        (0969) .done:
09F3: 7F       RET                      (0970)     RET                                ; All done
09F4: 8B 0A    JMP   USBUART_1_DT_h2d_std_dev_Dispatch
09F6: 8B 3F    JMP   USBUART_1_DT_h2d_std_ifc_Dispatch
09F8: 8B 77    JMP   USBUART_1_DT_h2d_std_ep_Dispatch
09FA: 80 43    JMP   0x0A3E             
09FC: 80 41    JMP   0x0A3E             
09FE: 80 9A    JMP   USBUART_1_DT_h2d_cls_ifc_Dispatch
0A00: 80 3D    JMP   0x0A3E             
0A02: 80 3B    JMP   0x0A3E             
0A04: 80 39    JMP   0x0A3E             
0A06: 80 37    JMP   0x0A3E             
0A08: 80 35    JMP   0x0A3E             
0A0A: 80 33    JMP   0x0A3E             
0A0C: 80 31    JMP   0x0A3E             
0A0E: 80 2F    JMP   0x0A3E             
0A10: 80 2D    JMP   0x0A3E             
0A12: 80 2B    JMP   0x0A3E             
0A14: 8A CA    JMP   USBUART_1_DT_d2h_std_dev_Dispatch
0A16: 8B 0A    JMP   USBUART_1_DT_d2h_std_ifc_Dispatch
0A18: 8B 32    JMP   USBUART_1_DT_d2h_std_ep_Dispatch
0A1A: 80 23    JMP   0x0A3E             
0A1C: 80 21    JMP   0x0A3E             
0A1E: 80 CA    JMP   USBUART_1_DT_d2h_cls_ifc_Dispatch
0A20: 80 1D    JMP   0x0A3E             
0A22: 80 1B    JMP   0x0A3E             
0A24: 80 19    JMP   0x0A3E             
0A26: 80 17    JMP   0x0A3E             
0A28: 80 15    JMP   0x0A3E             
0A2A: 80 13    JMP   0x0A3E             
0A2C: 80 11    JMP   0x0A3E             
0A2E: 80 0F    JMP   0x0A3E             
0A30: 80 0D    JMP   0x0A3E             
0A32: 80 0B    JMP   0x0A3E             
0A34: 39 20    CMP   A,0x20             
0A36: D0 04    JNC   0x0A3B             
0A38: 64       ASL   A                  
0A39: EF BA    JACC  USBUART_1_DT_bmRequestType
0A3B: 7D 0A 3E LJMP  0x0A3E             
                                        (0971) 
                                        (0972) 
                                        (0973) ;-----------------------------------------------------------------------------
                                        (0974) ;  FUNCTION NAME: ;  USB 1st Tier Dispatch Jump Table (based on bmRequestType)
                                        (0975) ;
                                        (0976) ;  DESCRIPTION:
                                        (0977) ;
                                        (0978) ;-----------------------------------------------------------------------------
                                        (0979) ;
                                        (0980) ;  ARGUMENTS:
                                        (0981) ;
                                        (0982) ;  RETURNS:
                                        (0983) ;
                                        (0984) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0985) ;
                                        (0986) ;  THEORY of OPERATION or PROCEDURE:
                                        (0987) ;
                                        (0988) ;-----------------------------------------------------------------------------
                                        (0989) MACRO BMREQUEST_DISPATCH
                                        (0990) IF (USB_CB_@0_@1_@2 & 1)
                                        (0991)     JMP     USBUART_1_DT_@0_@1_@2_Dispatch
                                        (0992) ELSE
                                        (0993)     JMP     USBUART_1_Not_Supported_Local_Drv
                                        (0994) ENDIF
                                        (0995) ENDM
                                        (0996) 
                                        (0997) USBUART_1_DT_bmRequestType::
                                        (0998)     BMREQUEST_DISPATCH    h2d,std,dev
                                        (0999)     BMREQUEST_DISPATCH    h2d,std,ifc
                                        (1000)     BMREQUEST_DISPATCH    h2d,std,ep
                                        (1001)     BMREQUEST_DISPATCH    h2d,std,oth
                                        (1002)     BMREQUEST_DISPATCH    h2d,cls,dev
                                        (1003)     BMREQUEST_DISPATCH    h2d,cls,ifc
                                        (1004)     BMREQUEST_DISPATCH    h2d,cls,ep
                                        (1005)     BMREQUEST_DISPATCH    h2d,cls,oth
                                        (1006)     BMREQUEST_DISPATCH    h2d,vnd,dev
                                        (1007)     BMREQUEST_DISPATCH    h2d,vnd,ifc
                                        (1008)     BMREQUEST_DISPATCH    h2d,vnd,ep
                                        (1009)     BMREQUEST_DISPATCH    h2d,vnd,oth
                                        (1010)     BMREQUEST_DISPATCH    h2d,rsv,dev
                                        (1011)     BMREQUEST_DISPATCH    h2d,rsv,ifc
                                        (1012)     BMREQUEST_DISPATCH    h2d,rsv,ep
                                        (1013)     BMREQUEST_DISPATCH    h2d,rsv,oth
                                        (1014)     BMREQUEST_DISPATCH    d2h,std,dev
                                        (1015)     BMREQUEST_DISPATCH    d2h,std,ifc
                                        (1016)     BMREQUEST_DISPATCH    d2h,std,ep
                                        (1017)     BMREQUEST_DISPATCH    d2h,std,oth
                                        (1018)     BMREQUEST_DISPATCH    d2h,cls,dev
                                        (1019)     BMREQUEST_DISPATCH    d2h,cls,ifc
                                        (1020)     BMREQUEST_DISPATCH    d2h,cls,ep
                                        (1021)     BMREQUEST_DISPATCH    d2h,cls,oth
                                        (1022)     BMREQUEST_DISPATCH    d2h,vnd,dev
                                        (1023)     BMREQUEST_DISPATCH    d2h,vnd,ifc
                                        (1024)     BMREQUEST_DISPATCH    d2h,vnd,ep
                                        (1025)     BMREQUEST_DISPATCH    d2h,vnd,oth
                                        (1026)     BMREQUEST_DISPATCH    d2h,rsv,dev
                                        (1027)     BMREQUEST_DISPATCH    d2h,rsv,ifc
                                        (1028)     BMREQUEST_DISPATCH    d2h,rsv,ep
                                        (1029)     BMREQUEST_DISPATCH    d2h,rsv,oth
                                        (1030) USBUART_1_DT_End:
                                        (1031) USBUART_1_DT_Size: equ (USBUART_1_DT_End-USBUART_1_DT_bmRequestType) / 2
                                        (1032) USBUART_1_bmRequestType_Dispatch::
                                        (1033)     DISPATCHER USBUART_1_DT_bmRequestType, USBUART_1_DT_Size, USBUART_1_Not_Supported_Local_Drv
                                        (1034) 
                                        (1035) USBUART_1_Not_Supported_Local_Drv:
0A3E: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(1036)         LJMP     USBUART_1_Not_Supported
                                        (1037) 
                                        (1038) 
                                        (1039) ;-----------------------------------------------
                                        (1040) ; Add custom application code for routines
                                        (1041) ;-----------------------------------------------
                                        (1042) 
                                        (1043)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (1044)    ;---------------------------------------------------
                                        (1045)    ; Insert your custom code below this banner
                                        (1046)    ;---------------------------------------------------
                                        (1047) 
                                        (1048)    ;---------------------------------------------------
                                        (1049)    ; Insert your custom code above this banner
                                        (1050)    ;---------------------------------------------------
                                        (1051)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1052) 
                                        (1053) ; End of File USBUART_1_drv.asm
FILE: lib\usbuart_1_cls_cdc.asm         (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1_cls_cdc.asm
                                        (0004) ;;  Version: 1.60, Updated on 2013/5/19 at 10:44:50
                                        (0005) ;; Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Communication Device Class (CDC) request implementation
                                        (0008) ;;
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "USBUART_1_macros.inc"
                                        (0015) include "USBUART_1.inc"
                                        (0016) include "memory.inc"
                                        (0017) 
                                        (0018) IF (USBUART_1_bSerialNumberType & 1)   ;if serial number automatic
                                        (0019) AREA SSCParmBlk(RAM,ABS)
                                        (0020) SSCParameterBlk:              blk      8     ; reserve 8 bytes: F8 - FF for supervisory operation
                                        (0021) ENDIF
                                        (0022) 
                                        (0023) AREA InterruptRAM (RAM,REL,CON)
                                        (0024) 
                                        (0025) DummyBuffer:
                                        (0026) 	BLK 8	; dummy buffer for SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE requests
                                        (0027) 
                                        (0028) IF (USBUART_1_bSerialNumberType & 1)   ;if serial number automatic
                                        (0029) EXPORT USBUART_1_SerialString
                                        (0030) USBUART_1_SerialString:
                                        (0031)     BLK 1   ; bLength
                                        (0032)     BLK 1   ; bDescriptorType = 3 (STRING)
                                        (0033)     BLK 24  ; 12 symbols in unicode
                                        (0034) ENDIF
                                        (0035) 
                                        (0036) EXPORT USBUART_1_LineCoding
                                        (0037) EXPORT _USBUART_1_LineCoding
                                        (0038) USBUART_1_LineCoding:
                                        (0039) _USBUART_1_LineCoding:
                                        (0040) 	BLK	4	;dwDTERate		Data terminal rate, in bits per second
                                        (0041) 	BLK 1	;bCharFormat		Stop bits (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                        (0042) 	BLK	1	;bParityType		Parity (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                        (0043) 	BLK 1	;bDataBits			Data bits (5,6,7,8 or 16)
                                        (0044) 
                                        (0045) EXPORT USBUART_1_LineControlBitmap
                                        (0046) EXPORT _USBUART_1_LineControlBitmap
                                        (0047) USBUART_1_LineControlBitmap::
                                        (0048) _USBUART_1_LineControlBitmap:
                                        (0049)     BLK 2   ; Line control bitmap
                                        (0050)     		;	D15..D2 - reserved
                                        (0051)     		;   D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                        (0052)     		;	D0 - DTR (0 = not present, 1 = present)
                                        (0053) 
                                        (0054) AREA UserModules (ROM, REL)
                                        (0055) 
                                        (0056) .LITERAL
                                        (0057) GetSetEncapsulatedCommand:
                                        (0058) 	TD_START_TABLE	1
                                        (0059) 	TD_ENTRY		USB_DS_RAM, 8, DummyBuffer, NULL_PTR
                                        (0060) 
                                        (0061) GetSetLineCodingTable:
                                        (0062)     TD_START_TABLE  1
                                        (0063)     TD_ENTRY        USB_DS_RAM, 7, USBUART_1_LineCoding, NULL_PTR
                                        (0064) .ENDLITERAL
                                        (0065) 
                                        (0066) ;-----------------------------------------------------------------------------
                                        (0067) ;  USB 2nd Tier Dispatch Jump Tables for CDC Requests (based on bRequest)
                                        (0068) ;-----------------------------------------------------------------------------
                                        (0069) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                        (0070) ;
                                        (0071) ;  DESCRIPTION:   The following tables dispatch to the Class request handler
                                        (0072) ;                 functions.  (Assumes bmRequestType(5:6) is 1, Class)
                                        (0073) ;-----------------------------------------------------------------------------
                                        (0074) USBUART_1_DT_h2d_cls_ifc:
0A53: 80 A1    JMP   0x0AF5             (0075)     jmp     USBUART_1_CB_h2d_cls_ifc_00			;00
0A55: 80 E8    JMP   0x0B3E             (0076)     jmp     USBUART_1_Not_Supported_Local1		;01
0A57: 80 E6    JMP   0x0B3E             (0077)     jmp     USBUART_1_Not_Supported_Local1		;02
0A59: 80 E4    JMP   0x0B3E             (0078)     jmp     USBUART_1_Not_Supported_Local1		;03
0A5B: 80 E2    JMP   0x0B3E             (0079)     jmp     USBUART_1_Not_Supported_Local1		;04
0A5D: 80 E0    JMP   0x0B3E             (0080)     jmp     USBUART_1_Not_Supported_Local1		;05
0A5F: 80 DE    JMP   0x0B3E             (0081)     jmp     USBUART_1_Not_Supported_Local1		;06
0A61: 80 DC    JMP   0x0B3E             (0082)     jmp     USBUART_1_Not_Supported_Local1		;07
0A63: 80 DA    JMP   0x0B3E             (0083)     jmp     USBUART_1_Not_Supported_Local1		;08
0A65: 80 D8    JMP   0x0B3E             (0084)     jmp     USBUART_1_Not_Supported_Local1		;09
0A67: 80 D6    JMP   0x0B3E             (0085)     jmp     USBUART_1_Not_Supported_Local1		;0A
0A69: 80 D4    JMP   0x0B3E             (0086)     jmp     USBUART_1_Not_Supported_Local1		;0B
0A6B: 80 D2    JMP   0x0B3E             (0087)     jmp     USBUART_1_Not_Supported_Local1		;0C
0A6D: 80 D0    JMP   0x0B3E             (0088)     jmp     USBUART_1_Not_Supported_Local1		;0D
0A6F: 80 CE    JMP   0x0B3E             (0089)     jmp     USBUART_1_Not_Supported_Local1		;0E
0A71: 80 CC    JMP   0x0B3E             (0090)     jmp     USBUART_1_Not_Supported_Local1		;0F
0A73: 80 CA    JMP   0x0B3E             (0091)     jmp     USBUART_1_Not_Supported_Local1		;10
0A75: 80 C8    JMP   0x0B3E             (0092)     jmp     USBUART_1_Not_Supported_Local1		;11
0A77: 80 C6    JMP   0x0B3E             (0093)     jmp     USBUART_1_Not_Supported_Local1		;12
0A79: 80 C4    JMP   0x0B3E             (0094)     jmp     USBUART_1_Not_Supported_Local1		;13
0A7B: 80 C2    JMP   0x0B3E             (0095)     jmp     USBUART_1_Not_Supported_Local1		;14
0A7D: 80 C0    JMP   0x0B3E             (0096)     jmp     USBUART_1_Not_Supported_Local1		;15
0A7F: 80 BE    JMP   0x0B3E             (0097)     jmp     USBUART_1_Not_Supported_Local1		;16
0A81: 80 BC    JMP   0x0B3E             (0098)     jmp     USBUART_1_Not_Supported_Local1		;17
0A83: 80 BA    JMP   0x0B3E             (0099)     jmp     USBUART_1_Not_Supported_Local1		;18
0A85: 80 B8    JMP   0x0B3E             (0100)     jmp     USBUART_1_Not_Supported_Local1		;19
0A87: 80 B6    JMP   0x0B3E             (0101)     jmp     USBUART_1_Not_Supported_Local1		;1A
0A89: 80 B4    JMP   0x0B3E             (0102)     jmp     USBUART_1_Not_Supported_Local1		;1B
0A8B: 80 B2    JMP   0x0B3E             (0103)     jmp     USBUART_1_Not_Supported_Local1		;1C
0A8D: 80 B0    JMP   0x0B3E             (0104)     jmp     USBUART_1_Not_Supported_Local1		;1D
0A8F: 80 AE    JMP   0x0B3E             (0105)     jmp     USBUART_1_Not_Supported_Local1		;1E
0A91: 80 AC    JMP   0x0B3E             (0106)     jmp     USBUART_1_Not_Supported_Local1		;1F
0A93: 80 70    JMP   0x0B04             (0107)     jmp     USBUART_1_CB_h2d_cls_ifc_20			;20
0A95: 80 A8    JMP   0x0B3E             (0108)     jmp     USBUART_1_Not_Supported_Local1		;21
0A97: 80 7B    JMP   0x0B13             (0109)     jmp     USBUART_1_CB_h2d_cls_ifc_22			;22
                                        (0110) USBUART_1_DT_h2d_cls_ifc_End:
                                        (0111) USBUART_1_DT_h2d_cls_ifc_Size: equ (USBUART_1_DT_h2d_cls_ifc_End-USBUART_1_DT_h2d_cls_ifc) / 2
                                        (0112) 
                                        (0113) USBUART_1_DT_h2d_cls_ifc_Dispatch::
0A99: 5D 59    MOV   A,REG[0x59]        (0114)     mov   A, REG[USBUART_1_EP0DATA + bRequest]       ; Get the request number
0A9B: 39 23    CMP   A,0x23             
0A9D: D0 04    JNC   0x0AA2             
0A9F: 64       ASL   A                  
0AA0: EF B2    JACC  0x0A53             
0AA2: 7D 0B 3E LJMP  0x0B3E             
                                        (0115)     DISPATCHER USBUART_1_DT_h2d_cls_ifc, USBUART_1_DT_h2d_cls_ifc_Size, USBUART_1_Not_Supported_Local1
                                        (0116) 
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) USBUART_1_DT_d2h_cls_ifc:
0AA5: 80 98    JMP   0x0B3E             (0119)     jmp     USBUART_1_Not_Supported_Local1		;00
0AA7: 80 78    JMP   0x0B20             (0120)     jmp     USBUART_1_CB_d2h_cls_ifc_01			;01
0AA9: 80 94    JMP   0x0B3E             (0121)     jmp     USBUART_1_Not_Supported_Local1		;02
0AAB: 80 92    JMP   0x0B3E             (0122)     jmp     USBUART_1_Not_Supported_Local1		;03
0AAD: 80 90    JMP   0x0B3E             (0123)     jmp     USBUART_1_Not_Supported_Local1		;04
0AAF: 80 8E    JMP   0x0B3E             (0124)     jmp     USBUART_1_Not_Supported_Local1		;05
0AB1: 80 8C    JMP   0x0B3E             (0125)     jmp     USBUART_1_Not_Supported_Local1		;06
0AB3: 80 8A    JMP   0x0B3E             (0126)     jmp     USBUART_1_Not_Supported_Local1		;07
0AB5: 80 88    JMP   0x0B3E             (0127)     jmp     USBUART_1_Not_Supported_Local1		;08
0AB7: 80 86    JMP   0x0B3E             (0128)     jmp     USBUART_1_Not_Supported_Local1		;09
0AB9: 80 84    JMP   0x0B3E             (0129)     jmp     USBUART_1_Not_Supported_Local1		;0A
0ABB: 80 82    JMP   0x0B3E             (0130)     jmp     USBUART_1_Not_Supported_Local1		;0B
0ABD: 80 80    JMP   0x0B3E             (0131)     jmp     USBUART_1_Not_Supported_Local1		;0C
0ABF: 80 7E    JMP   0x0B3E             (0132)     jmp     USBUART_1_Not_Supported_Local1		;0D
0AC1: 80 7C    JMP   0x0B3E             (0133)     jmp     USBUART_1_Not_Supported_Local1		;0E
0AC3: 80 7A    JMP   0x0B3E             (0134)     jmp     USBUART_1_Not_Supported_Local1		;0F
0AC5: 80 78    JMP   0x0B3E             (0135)     jmp     USBUART_1_Not_Supported_Local1		;10
0AC7: 80 76    JMP   0x0B3E             (0136)     jmp     USBUART_1_Not_Supported_Local1		;11
0AC9: 80 74    JMP   0x0B3E             (0137)     jmp     USBUART_1_Not_Supported_Local1		;12
0ACB: 80 72    JMP   0x0B3E             (0138)     jmp     USBUART_1_Not_Supported_Local1		;13
0ACD: 80 70    JMP   0x0B3E             (0139)     jmp     USBUART_1_Not_Supported_Local1		;14
0ACF: 80 6E    JMP   0x0B3E             (0140)     jmp     USBUART_1_Not_Supported_Local1		;15
0AD1: 80 6C    JMP   0x0B3E             (0141)     jmp     USBUART_1_Not_Supported_Local1		;16
0AD3: 80 6A    JMP   0x0B3E             (0142)     jmp     USBUART_1_Not_Supported_Local1		;17
0AD5: 80 68    JMP   0x0B3E             (0143)     jmp     USBUART_1_Not_Supported_Local1		;18
0AD7: 80 66    JMP   0x0B3E             (0144)     jmp     USBUART_1_Not_Supported_Local1		;19
0AD9: 80 64    JMP   0x0B3E             (0145)     jmp     USBUART_1_Not_Supported_Local1		;1A
0ADB: 80 62    JMP   0x0B3E             (0146)     jmp     USBUART_1_Not_Supported_Local1		;1B
0ADD: 80 60    JMP   0x0B3E             (0147)     jmp     USBUART_1_Not_Supported_Local1		;1C
0ADF: 80 5E    JMP   0x0B3E             (0148)     jmp     USBUART_1_Not_Supported_Local1		;1D
0AE1: 80 5C    JMP   0x0B3E             (0149)     jmp     USBUART_1_Not_Supported_Local1		;1E
0AE3: 80 5A    JMP   0x0B3E             (0150)     jmp     USBUART_1_Not_Supported_Local1		;1F
0AE5: 80 58    JMP   0x0B3E             (0151)     jmp     USBUART_1_Not_Supported_Local1		;20
0AE7: 80 47    JMP   0x0B2F             (0152)     jmp     USBUART_1_CB_d2h_cls_ifc_21			;21
                                        (0153) USBUART_1_DT_d2h_cls_ifc_End:
                                        (0154) USBUART_1_DT_d2h_cls_ifc_Size: equ (USBUART_1_DT_d2h_cls_ifc_End-USBUART_1_DT_d2h_cls_ifc) / 2
                                        (0155) 
                                        (0156) USBUART_1_DT_d2h_cls_ifc_Dispatch::
0AE9: 5D 59    MOV   A,REG[0x59]        (0157)     mov   A, REG[USBUART_1_EP0DATA + bRequest]       ; Get the request number
0AEB: 39 22    CMP   A,0x22             
0AED: D0 04    JNC   0x0AF2             
0AEF: 64       ASL   A                  
0AF0: EF B4    JACC  0x0AA5             
0AF2: 7D 0B 3E LJMP  0x0B3E             
                                        (0158)     DISPATCHER USBUART_1_DT_d2h_cls_ifc, USBUART_1_DT_d2h_cls_ifc_Size, USBUART_1_Not_Supported_Local1
                                        (0159) 
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_00
                                        (0162) ;-----------------------------------------------------------------------------
                                        (0163) ; CDC INTERFACE REQUEST: Send_Encapsulated_Command
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0166) ; bRequest       : SET_ENCAPSULATED_COMMAND		     	= 00h
                                        (0167) ; wValue         : Zero		                    		= 0000h
                                        (0168) ; wIndex         : INTERFACE                      		= --xxh
                                        (0169) ; wLength        : Amount of data, in bytes associated with recipient
                                        (0170) ; Data			 : Control protocol-based command (Dummy buffer)
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) USBUART_1_CB_h2d_cls_ifc_00:
0AF5: 5D 5C    MOV   A,REG[0x5C]        (0173)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0AF7: 39 02    CMP   A,0x2              (0174)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0AF9: D0 44    JNC   0x0B3E             (0175)     jnc   USBUART_1_Not_Supported_Local1
0AFB: 53 1F    MOV   [0x1F],A           (0176)     mov   [USBUART_1_t2], A                  ; Selector
0AFD: 50 0A    MOV   A,0xA              (0177)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0AFF: 57 41    MOV   X,0x41             (0178)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0B01: 7D 09 60 LJMP  USBUART_1_GetTableEntry(0179)     ljmp   USBUART_1_GetTableEntry
                                        (0180) 
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_20
                                        (0183) ;-----------------------------------------------------------------------------
                                        (0184) ; CDC INTERFACE REQUEST: Set_Line_Coding
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0187) ; bRequest       : SET_LINE_CODING				     	= 20h
                                        (0188) ; wValue         : Zero		                    		= 0000h
                                        (0189) ; wIndex         : INTERFACE                      		= --xxh
                                        (0190) ; wLength        : Report Size                    		= 0007h
                                        (0191) ; Data			 : Line Coding Structure
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) USBUART_1_CB_h2d_cls_ifc_20:
0B04: 5D 5C    MOV   A,REG[0x5C]        (0194)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B06: 39 02    CMP   A,0x2              (0195)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B08: D0 35    JNC   0x0B3E             (0196)     jnc   USBUART_1_Not_Supported_Local1
0B0A: 53 1F    MOV   [0x1F],A           (0197)     mov   [USBUART_1_t2], A                  ; Selector
0B0C: 50 0A    MOV   A,0xA              (0198)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0B0E: 57 4A    MOV   X,0x4A             (0199)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0B10: 7D 09 60 LJMP  USBUART_1_GetTableEntry(0200)     ljmp   USBUART_1_GetTableEntry
                                        (0201) 
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ; FUNCTION NAME: USBUART_1_CB_h2d_cls_ifc_22
                                        (0204) ;-----------------------------------------------------------------------------
                                        (0205) ; CDC INTERFACE REQUEST: Set_Control_Line_State
                                        (0206) ;-----------------------------------------------------------------------------
                                        (0207) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                        (0208) ; bRequest       : SET_CONTROL_LINE_STATE		     	= 22h
                                        (0209) ; wValue         : Control Signal Bitmap           		= xxxxh
                                        (0210) ; wIndex         : INTERFACE                      		= --xxh
                                        (0211) ; wLength        : Report Size                    		= 0000h
                                        (0212) ; Data			 : Line Coding Structure
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) USBUART_1_CB_h2d_cls_ifc_22:
0B13: 5D 5C    MOV   A,REG[0x5C]        (0215)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B15: 39 02    CMP   A,0x2              (0216)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B17: D0 26    JNC   0x0B3E             (0217)     jnc   USBUART_1_Not_Supported_Local1
0B19: 5D 5A    MOV   A,REG[0x5A]        (0218)     mov   A, REG[USBUART_1_EP0DATA+wValueLo] ; Get the bitmap
0B1B: 53 37    MOV   [0x37],A           (0219)     mov   [USBUART_1_LineControlBitmap+1], A
0B1D: 7D 08 4D LJMP  USBUART_1_NoDataStageControlTransfer|_USBUART_1_InitNoDataStageControlTransfer|USBUART_1_InitNoDataStageControlTransfer(0220)     ljmp   USBUART_1_NoDataStageControlTransfer
                                        (0221) 
                                        (0222) ;-----------------------------------------------------------------------------
                                        (0223) ;  FUNCTION NAME: USBUART_1_CB_d2h_cls_ifc_01
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ; CDC INTERFACE REQUEST: Get_Encapsulated_Response
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                        (0228) ; bRequest       : GET_ENCAPSULATED_RESPONSE	     	= 01h
                                        (0229) ; wValue         : Zero		               				= 0000h
                                        (0230) ; wIndex         : INTERFACE                      		= --xxh
                                        (0231) ; wLength        : Amount of data, in bytes associated with recipient
                                        (0232) ; Data			 : Control protocol-based data (Dummy buffer)
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) USBUART_1_CB_d2h_cls_ifc_01:
0B20: 5D 5C    MOV   A,REG[0x5C]        (0235)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B22: 39 02    CMP   A,0x2              (0236)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B24: D0 19    JNC   0x0B3E             (0237)     jnc   USBUART_1_Not_Supported_Local1
0B26: 53 1F    MOV   [0x1F],A           (0238)     mov   [USBUART_1_t2], A                  ; Selector
0B28: 50 0A    MOV   A,0xA              (0239)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0B2A: 57 41    MOV   X,0x41             (0240)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0B2C: 7D 09 60 LJMP  USBUART_1_GetTableEntry(0241)     ljmp   USBUART_1_GetTableEntry
                                        (0242) 
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: USBUART_1_CB_d2h_cls_ifc_21
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ; CDC INTERFACE REQUEST: Get_Line_Coding
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                        (0249) ; bRequest       : GET_LINE_CODING				     	= 21h
                                        (0250) ; wValue         : Zero		               				= 0000h
                                        (0251) ; wIndex         : INTERFACE                      		= --xxh
                                        (0252) ; wLength        : Report Size                    		= 0007h
                                        (0253) ; Data			 : Line Coding Structure
                                        (0254) ;
                                        (0255) ;-----------------------------------------------------------------------------
                                        (0256) USBUART_1_CB_d2h_cls_ifc_21:
                                        (0257) 
0B2F: 5D 5C    MOV   A,REG[0x5C]        (0258)     mov   A, REG[USBUART_1_EP0DATA+wIndexLo] ; Get the interface number
0B31: 39 02    CMP   A,0x2              (0259)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0B33: D0 0A    JNC   0x0B3E             (0260)     jnc   USBUART_1_Not_Supported_Local1
0B35: 53 1F    MOV   [0x1F],A           (0261)     mov   [USBUART_1_t2], A                  ; Selector
0B37: 50 0A    MOV   A,0xA              (0262)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0B39: 57 4A    MOV   X,0x4A             (0263)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0B3B: 7D 09 60 LJMP  USBUART_1_GetTableEntry(0264)     ljmp   USBUART_1_GetTableEntry
                                        (0265) 
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267) ;  FUNCTION NAME: USBUART_1_Not_Supported_Local1
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  Handle requests that are not supported
                                        (0270) ;-----------------------------------------------------------------------------
                                        (0271) USBUART_1_Not_Supported_Local1:
0B3E: 7D 04 AE LJMP  _USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_02|USBUART_1_CB_h2d_std_ep_00|USBUART_1_Not_Supported|USBUART_1_CB_d2h_std_ifc_03|USBUART_1_CB_h2d_std_dev_08|USBUART_1_CB_h2d_std_ep_02|USBUART_1_CB_h2d_std_dev_07|USBUART_1_CB_d2h_std_ifc_04|...(0272) 	ljmp USBUART_1_Not_Supported
FILE: lib\usbuart_1.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;  FILENAME: USBUART_1.asm
0B56: 70 BF    AND   F,0xBF             (0003) ;;  Version: 1.60, Updated on 2013/5/19 at 10:44:50
0B58: 62 D3 00 MOV   REG[0xD3],0x0      
0B5B: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0004) ;;  Generated by PSoC Designer 5.4.2946
                                        (0005) ;;
                                        (0006) ;;  DESCRIPTION: USBUART User Module Descriptors
                                        (0007) ;;
                                        (0008) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0009) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0010) ;;        This means it is the caller's responsibility to preserve any values
                                        (0011) ;;        in the X and A registers that are still needed after the API
                                        (0012) ;;        function returns. Even though these registers may be preserved now,
                                        (0013) ;;        there is no guarantee they will be preserved in future releases.
                                        (0014) ;;-----------------------------------------------------------------------------
                                        (0015) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0016) ;;*****************************************************************************
                                        (0017) ;;*****************************************************************************
                                        (0018) include "m8c.inc"
                                        (0019) include "m8ssc.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "USBUART_1_macros.inc"
                                        (0022) include "USBUART_1.inc"
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Global Symbols
                                        (0026) ;-----------------------------------------------
                                        (0027) EXPORT USBUART_1_Start
                                        (0028) EXPORT _USBUART_1_Start
                                        (0029) EXPORT USBUART_1_Stop
                                        (0030) EXPORT _USBUART_1_Stop
                                        (0031) EXPORT USBUART_1_Init
                                        (0032) EXPORT _USBUART_1_Init
                                        (0033) 
                                        (0034) EXPORT USBUART_1_Write
                                        (0035) EXPORT _USBUART_1_Write
                                        (0036) EXPORT _USBUART_1_CWrite
                                        (0037) EXPORT USBUART_1_CWrite
                                        (0038) EXPORT USBUART_1_PutString
                                        (0039) EXPORT _USBUART_1_PutString
                                        (0040) EXPORT USBUART_1_CPutString
                                        (0041) EXPORT _USBUART_1_CPutString
                                        (0042) EXPORT USBUART_1_PutChar
                                        (0043) EXPORT _USBUART_1_PutChar
                                        (0044) EXPORT USBUART_1_PutCRLF
                                        (0045) EXPORT _USBUART_1_PutCRLF
                                        (0046) EXPORT USBUART_1_PutSHexByte
                                        (0047) EXPORT _USBUART_1_PutSHexByte
                                        (0048) EXPORT USBUART_1_PutSHexInt
                                        (0049) EXPORT _USBUART_1_PutSHexInt
                                        (0050) 
                                        (0051) EXPORT USBUART_1_bGetRxCount
                                        (0052) EXPORT _USBUART_1_bGetRxCount
                                        (0053) EXPORT USBUART_1_bTxIsReady
                                        (0054) EXPORT _USBUART_1_bTxIsReady
                                        (0055) 
                                        (0056) EXPORT USBUART_1_Read
                                        (0057) EXPORT _USBUART_1_Read
                                        (0058) EXPORT USBUART_1_ReadAll
                                        (0059) EXPORT _USBUART_1_ReadAll
                                        (0060) EXPORT USBUART_1_ReadChar
                                        (0061) EXPORT _USBUART_1_ReadChar
                                        (0062) 
                                        (0063) EXPORT USBUART_1_dwGetDTERate
                                        (0064) EXPORT _USBUART_1_dwGetDTERate
                                        (0065) EXPORT USBUART_1_bGetCharFormat
                                        (0066) EXPORT _USBUART_1_bGetCharFormat
                                        (0067) EXPORT USBUART_1_bGetParityType
                                        (0068) EXPORT _USBUART_1_bGetParityType
                                        (0069) EXPORT USBUART_1_bGetDataBits
                                        (0070) EXPORT _USBUART_1_bGetDataBits
                                        (0071) EXPORT USBUART_1_bGetDataBits
                                        (0072) EXPORT _USBUART_1_bGetDataBits
                                        (0073) EXPORT USBUART_1_bGetLineControlBitmap
                                        (0074) EXPORT _USBUART_1_bGetLineControlBitmap
                                        (0075) EXPORT USBUART_1_SendStateNotify
                                        (0076) EXPORT _USBUART_1_SendStateNotify
                                        (0077) 
                                        (0078) EXPORT USBUART_1_bCheckUSBActivity
                                        (0079) EXPORT _USBUART_1_bCheckUSBActivity
                                        (0080) EXPORT USBUART_1_SetPowerStatus
                                        (0081) EXPORT _USBUART_1_SetPowerStatus
                                        (0082) 
                                        (0083) 
                                        (0084) AREA InterruptRAM (RAM,REL,CON)
                                        (0085) ;-----------------------------------------------
                                        (0086) ;  Variable Allocation
                                        (0087) ;-----------------------------------------------
                                        (0088) EXPORT USBUART_1_APITemp
                                        (0089)  USBUART_1_APITemp:                     BLK   2 ; Two bytes of temporary  storage shared by the API  functions
                                        (0090) 
                                        (0091) 
                                        (0092) AREA UserModules (ROM, REL)
                                        (0093) export USBUART_1_USB_EP_BIT_LOOKUP
                                        (0094) 
                                        (0095) .LITERAL
                                        (0096) USBUART_1_HEX_STR:
                                        (0097)      DS    "0123456789ABCDEF"
                                        (0098) USBUART_1_USB_EP_BIT_LOOKUP:  ;
                                        (0099)     DB     01H                       ; EP0
                                        (0100)     DB     02H                       ; EP1
                                        (0101)     DB     04H                       ; EP2
                                        (0102)     DB     08H                       ; EP3
                                        (0103)     DB     010H                      ; EP4
                                        (0104) .ENDLITERAL
                                        (0105) 
                                        (0106) .SECTION
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;  FUNCTION NAME: USBUART_1_Start
                                        (0109) ;
                                        (0110) ;  DESCRIPTION:    Starts the USB User Module
                                        (0111) ;                    Sets the device selection
                                        (0112) ;                    Set the configuration to unconfigured
                                        (0113) ;                    Enables the SIE for Address 0
                                        (0114) ;                    Enables the USB pullup ( D+ for full speed)
                                        (0115) ;
                                        (0116) ;-----------------------------------------------------------------------------
                                        (0117) ;
                                        (0118) ;  ARGUMENTS:    A  is the operation voltage
                                        (0119) ;
                                        (0120) ;  RETURNS:		 Nothing
                                        (0121) ;
                                        (0122) ;  SIDE EFFECTS:
                                        (0123) ;    The A and X registers may be modified by this or future implementations
                                        (0124) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0125) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0126) ;    responsibility to preserve their values across calls to fastcall16
                                        (0127) ;    functions.
                                        (0128) ;
                                        (0129)  USBUART_1_Start:
                                        (0130) _USBUART_1_Start:
                                        (0131)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0132)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0133) 
                                        (0134) IF (USBUART_1_bSerialNumberType & USBUART_1_SERIAL_AUTO)   ;if serial number automatic
                                        (0135)     push    A   ;save incoming parameter
                                        (0136) ;Generate the serial number
                                        (0137)     RAM_SETPAGE_CUR 0
                                        (0138)     RAM_SETPAGE_MVW 0
                                        (0139)     RAM_SETPAGE_MVR 0
                                        (0140)     mov     [bSSC_TABLE_TableId],0x00
                                        (0141)     SSC_Action(0x06)
                                        (0142)     ; the USBUART_1_SerialString is located in the InterruptROM area so it located on page 0.
                                        (0143)     mov     [bSSC_KEY1], <USBUART_1_SerialString ; prepare for mvi
                                        (0144)     mov     A, 26
                                        (0145)     mvi     [bSSC_KEY1], A ; string descriptor length 26 bytes
                                        (0146)     mov     A, 3
                                        (0147)     mvi     [bSSC_KEY1], A ; descriptor type 3 = string
                                        (0148)     mov     [bSSC_KEY1+1], bSSC_TABLE_TableId
                                        (0149)     mov     X, 6 ;loop for all 6 byes with S/N
                                        (0150) .SNCopyLoop:
                                        (0151)     mvi     A, [bSSC_KEY1+1] ;get S/N byte
                                        (0152)     push    A
                                        (0153)     asr     A ; select lower nibble
                                        (0154)     asr     A
                                        (0155)     asr     A
                                        (0156)     asr     A
                                        (0157)     and     A, 0x0F ; clear high bits
                                        (0158)     index   USBUART_1_HEX_STR ; get ASCII
                                        (0159)     mvi     [bSSC_KEY1], A ; save character
                                        (0160)     mov     A, 0
                                        (0161)     mvi     [bSSC_KEY1], A ; save 0x00 for Unicode high byte
                                        (0162)     pop     A
                                        (0163)     and     A, 0x0F ;clear high bits
                                        (0164)     index   USBUART_1_HEX_STR ; get ASCII
                                        (0165)     mvi     [bSSC_KEY1], A ; save character
                                        (0166)     mov     A, 0
                                        (0167)     mvi     [bSSC_KEY1], A ; save 0x00 for Unicode high byte
                                        (0168)     dec     X
                                        (0169)     jnz     .SNCopyLoop
                                        (0170)     pop     A   ;restore incoming parameter
                                        (0171) ENDIF
                                        (0172)     RAM_SETPAGE_IDX >USBUART_1_bCurrentDevice ; Set the IDX_PP to the right page
                                        (0173) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0174) 
                                        (0175) ;Start User Module
0B5E: 55 00 00 MOV   [0x0],0x0          (0176)     mov     [USBUART_1_bCurrentDevice], 0 ; The app selects the desired device
                                        (0177) 
0B61: 55 0B 00 MOV   [0xB],0x0          (0178)     mov     [USBUART_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0B64: 55 01 00 MOV   [0x1],0x0          (0179)     mov     [USBUART_1_Configuration], 0 ; Unconfigured
0B67: 55 02 00 MOV   [0x2],0x0          (0180)     mov     [USBUART_1_DeviceStatus], 0; Clears device status
                                        (0181) 
0B6A: 55 1D 00 MOV   [0x1D],0x0         (0182)     mov     [USBUART_1_EPDataToggle], 0    ; Clear all EP data toggles
0B6D: 62 6C 00 MOV   REG[0x6C],0x0      (0183)     mov     reg[TMP_DR0], 0	           ; EP1 start address in PMA space
0B70: 62 6D 40 MOV   REG[0x6D],0x40     (0184) 	mov     reg[TMP_DR1], 64              ; EP2 start address in PMA space
0B73: 62 6E 80 MOV   REG[0x6E],0x80     (0185) 	mov     reg[TMP_DR2], 128             ; EP3 start address in PMA space
0B76: 62 6F C0 MOV   REG[0x6F],0xC0     (0186) 	mov     reg[TMP_DR3], 192             ; EP4 start address in PMA space
                                        (0187) 
                                        (0188) ; Flow here to enable the SIE
0B79: 62 4A 80 MOV   REG[0x4A],0x80     (0189)     mov     reg[USBUART_1_ADDR], USB_ADDR_ENABLE ; Enable Address 0
0B7C: 62 4B 00 MOV   REG[0x4B],0x0      (0190) 	mov     reg[USBUART_1_USBIO_CR0], USB_AUTO_DPDM
0B7F: 71 10    OR    F,0x10             
                                        (0191) 
                                        (0192)     M8C_SetBank1
0B81: 60 C1    MOV   REG[0xC1],A        (0193) 	mov     reg[USBUART_1_USB_CR1], A
0B83: 70 EF    AND   F,0xEF             
                                        (0194) 	M8C_SetBank0
0B85: 62 56 03 MOV   REG[0x56],0x3      (0195)     mov     reg[USBUART_1_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
0B88: 43 DF 05 OR    REG[0xDF],0x5      
                                        (0196)     M8C_EnableIntMask USBUART_1_INT_REG, (USBUART_1_INT_RESET_MASK | USBUART_1_INT_EP0_MASK)
                                        (0197) 
                                        (0198) ;   Enable the pullup so we can start to rock and roll
0B8B: 62 4C 04 MOV   REG[0x4C],0x4      (0199)     mov     reg[USBUART_1_USBIO_CR1], USB_PULLUP_ENABLE ; Pullup D+
0B8E: 70 3F    AND   F,0x3F             
0B90: 71 C0    OR    F,0xC0             
                                        (0200) 
                                        (0201)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0202) 	RAM_EPILOGUE RAM_USE_CLASS_4
0B92: 7F       RET                      (0203)     RET
0B93: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0204) .ENDSECTION
                                        (0205) 
                                        (0206) .SECTION
                                        (0207) ;-----------------------------------------------------------------------------
                                        (0208) ;  FUNCTION NAME: USBUART_1_Stop
                                        (0209) ;
                                        (0210) ;  DESCRIPTION: Performs all necessary shutdown tasks required for the USBUART
                                        (0211) ;               User Module.
                                        (0212) ;
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;
                                        (0215) ;  ARGUMENTS: None
                                        (0216) ;
                                        (0217) ;  RETURNS:   Nothing
                                        (0218) ;
                                        (0219) ;  SIDE EFFECTS:
                                        (0220) ;    The A and X registers may be modified by this or future implementations
                                        (0221) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0222) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0223) ;    responsibility to preserve their values across calls to fastcall16
                                        (0224) ;    functions.
                                        (0225) ;
                                        (0226)  USBUART_1_Stop:
                                        (0227) _USBUART_1_Stop:
                                        (0228)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0229) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0230) 
0B96: 55 00 00 MOV   [0x0],0x0          (0231)     mov     [USBUART_1_bCurrentDevice], 0 ; The app selects the desired device
                                        (0232) 
0B99: 55 0B 00 MOV   [0xB],0x0          (0233)     mov     [USBUART_1_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0B9C: 55 01 00 MOV   [0x1],0x0          (0234)     mov     [USBUART_1_Configuration], 0 ; Unconfigured
0B9F: 55 02 00 MOV   [0x2],0x0          (0235)     mov     [USBUART_1_DeviceStatus], 0; Clears device status
0BA2: 62 4A 00 MOV   REG[0x4A],0x0      (0236)     mov     reg[USBUART_1_ADDR], 0     ; Clear the address and Address 0
0BA5: 41 4C FB AND   REG[0x4C],0xFB     (0237) 	and     reg[USBUART_1_USBIO_CR1], ~USB_PULLUP_ENABLE ; Release D+
0BA8: 62 DF 00 MOV   REG[0xDF],0x0      (0238)     mov     reg[USBUART_1_INT_REG], 0x00 ; Enable the interrupt
                                        (0239) 
                                        (0240) 	RAM_EPILOGUE RAM_USE_CLASS_4
0BAB: 7F       RET                      (0241)     RET
0BAC: 71 10    OR    F,0x10             
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: USBUART_1_bCheckUSBActivity
                                        (0247) ;
                                        (0248) ;  DESCRIPTION: Checks for USB Bus Activity.
                                        (0249) ;
                                        (0250) ;-----------------------------------------------------------------------------
                                        (0251) ;
                                        (0252) ;  ARGUMENTS: Nothing
                                        (0253) ;
                                        (0254) ;  RETURNS:   A is a flag that indicates bus activity
                                        (0255) ;
                                        (0256) ;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
                                        (0257) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0258) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0259) ;    responsibility to preserve their values across calls to fastcall16
                                        (0260) ;    functions.
                                        (0261) ;
                                        (0262)  USBUART_1_bCheckUSBActivity:
                                        (0263) _USBUART_1_bCheckUSBActivity:
                                        (0264)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0265)     M8C_SetBank1
0BAE: 5D C1    MOV   A,REG[0xC1]        (0266)     mov    A, reg[USBUART_1_USB_CR1]   ; USB Activity bit indicates activity
0BB0: 21 04    AND   A,0x4              (0267)     and    A, USB_BUS_ACTIVITY         ; Activity?
0BB2: A0 08    JZ    0x0BBB             (0268)     jz     .no_activity                ; Jump on no activity?
                                        (0269) ; Flow here on bus activity
0BB4: 41 C1 FB AND   REG[0xC1],0xFB     (0270)     and    reg[USBUART_1_USB_CR1], ~USB_BUS_ACTIVITY  ; Clear the activity flag
0BB7: 50 01    MOV   A,0x1              (0271)     mov    A, 1                        ; Return true
0BB9: 80 03    JMP   0x0BBD             (0272)     jmp    .done
                                        (0273) ; Jump here on no activity
                                        (0274) .no_activity:
0BBB: 50 00    MOV   A,0x0              (0275)     mov    A, 0                        ; Return false
0BBD: 70 EF    AND   F,0xEF             
                                        (0276) ; Jump or flow here to clear the activity bit, then return
                                        (0277) .done:
                                        (0278)     M8C_SetBank0
                                        (0279) 	RAM_EPILOGUE RAM_USE_CLASS_1
0BBF: 7F       RET                      (0280)     ret
0BC0: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) .SECTION
                                        (0284) ;-----------------------------------------------------------------------------
                                        (0285) ;  FUNCTION NAME: USBUART_1_bGetRxCount
                                        (0286) ;
                                        (0287) ;  DESCRIPTION: This function returns the number of bytes that were received
                                        (0288) ;               from the PC and are waiting in the RX buffer.
                                        (0289) ;
                                        (0290) ;-----------------------------------------------------------------------------
                                        (0291) ;
                                        (0292) ;  ARGUMENTS:
                                        (0293) ;	none
                                        (0294) ;
                                        (0295) ;  RETURNS:
                                        (0296) ;	If RX associated endpoint has EVENT_PENDING status return ()in A register) the values stored in the
                                        (0297) ;  	Count registers of the Endpoint; otherwise return zero.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS:
                                        (0300) ;    The A and X registers may be modified by this or future implementations
                                        (0301) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0302) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0303) ;    responsibility to preserve their values across calls to fastcall16
                                        (0304) ;    functions.
                                        (0305) ;
                                        (0306)  USBUART_1_bGetRxCount:
                                        (0307) _USBUART_1_bGetRxCount:
                                        (0308)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0309) 	RAM_SETPAGE_CUR >USBUART_1_EndpointAPIStatus ; Set the IDX_PP to the right page
0BC3: 51 25    MOV   A,[0x25]           (0310) 	mov     A, [USBUART_1_EndpointAPIStatus+3]	; Get the state
0BC5: 39 01    CMP   A,0x1              (0311) 	cmp 	A, EVENT_PENDING
0BC7: A0 05    JZ    0x0BCD             (0312) 	jz		.ev_pending
0BC9: 50 00    MOV   A,0x0              (0313) 	mov		A, 0
0BCB: 80 21    JMP   0x0BED             (0314) 	jmp		.exit
                                        (0315) .ev_pending:
0BCD: 5D 53    MOV   A,REG[0x53]        (0316)     mov     A, reg[USBUART_1_EP3CNT0]  ; Here is the count
0BCF: 11 02    SUB   A,0x2              (0317) 	sub		A, 2
0BD1: 39 00    CMP   A,0x0              (0318)     cmp     A, 0 ; check if event pending but no data to receive. This happens sometimes on XP SP3.
0BD3: B0 19    JNZ   0x0BED             (0319)     jnz     .exit	
                                        (0320)     ; Clear and re-enable endpoint after receive zero length data
0BD5: 55 25 00 MOV   [0x25],0x0         (0321) 	mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0BD8: 62 53 40 MOV   REG[0x53],0x40     (0322) 	mov     reg[USBUART_1_EP3CNT0], 64
0BDB: 71 10    OR    F,0x10             
                                        (0323) 	M8C_SetBank1
0BDD: 62 6E 80 MOV   REG[0x6E],0x80     (0324) 	mov		reg[TMP_DR2], 128
0BE0: 5D 6E    MOV   A,REG[0x6E]        (0325)     mov     A, reg[TMP_DR2]
0BE2: 60 43    MOV   REG[0x43],A        (0326) 	mov     reg[PMA3_WA], A
0BE4: 5D C6    MOV   A,REG[0xC6]        (0327)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0BE6: 62 C6 09 MOV   REG[0xC6],0x9      (0328)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0BE9: 50 00    MOV   A,0x0              (0329) 	mov 	A, 0;	; No error and no bytes left in EP
0BEB: 70 EF    AND   F,0xEF             
                                        (0330)     M8C_SetBank0
                                        (0331) ; Jump or flow here for a common exit
                                        (0332) .exit:
                                        (0333)     RAM_EPILOGUE RAM_USE_CLASS_4
0BED: 7F       RET                      (0334)     ret
                                        (0335) .ENDSECTION
                                        (0336) 
                                        (0337) .SECTION
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) ;  FUNCTION NAME: USBUART_1_Write,  USBUART_1_CWrite
                                        (0340) ;
                                        (0341) ;  DESCRIPTION:    Send specified numbers of data
                                        (0342) ;
                                        (0343) ;-----------------------------------------------------------------------------
                                        (0344) ;
                                        (0345) ;  ARGUMENTS:
                                        (0346) ;     [SP-6] Count to send
                                        (0347) ;     [SP-5] MSB of data array address
                                        (0348) ;     [SP-4] LSB of data array address
                                        (0349) ;
                                        (0350) ;  RETURNS:
                                        (0351) ;     none
                                        (0352) ;
                                        (0353) ;  SIDE EFFECTS:
                                        (0354) ;    The A and X registers may be modified by this or future implementations
                                        (0355) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0356) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0357) ;    responsibility to preserve their values across calls to fastcall16
                                        (0358) ;    functions.
                                        (0359) ;
                                        (0360) ;    Currently only the page pointer registers listed below are modified:
                                        (0361) ;          CUR_PP
                                        (0362) ;          IDX_PP
                                        (0363) ;
                                        (0364) MEM_TYPE:	equ -1
                                        (0365) ; -2 and -3 is the return address to caller
                                        (0366) DATA_LSB:   equ -4           ; LSB pointer of data
                                        (0367) DATA_MSB:   equ -5           ; MSB pointer of data
                                        (0368) CNTLEN: equ -6			 ; Length of data to send
                                        (0369) 
                                        (0370)  USBUART_1_CWrite:
                                        (0371) _USBUART_1_CWrite:
0BEE: 50 01    MOV   A,0x1              (0372) 	mov		A, 1 ;Set MEM_TYPE
0BF0: 08       PUSH  A                  (0373) 	push	A
0BF1: 80 04    JMP   0x0BF6             (0374) 	jmp		USBUART_1_Write_Start
                                        (0375)  USBUART_1_Write:
                                        (0376) _USBUART_1_Write:
0BF3: 50 00    MOV   A,0x0              (0377) 	mov		A, 0 ;Set MEM_TYPE
0BF5: 08       PUSH  A                  (0378) 	push	A
0BF6: 70 BF    AND   F,0xBF             
0BF8: 62 D0 00 MOV   REG[0xD0],0x0      
0BFB: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0379) USBUART_1_Write_Start:
                                        (0380)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0381)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0382) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0383)     RAM_SETPAGE_IDX2STK
                                        (0384)     ;Should we toggle the data bit??
                                        (0385)     ;SET THE COUNT AND TOGGLE
0BFE: 4F       MOV   X,SP               (0386) 	mov     X, SP
0BFF: 52 FA    MOV   A,[X-6]            (0387) 	mov     A, [X+CNTLEN]                 ; Get the Count
0C01: 53 38    MOV   [0x38],A           (0388) 	mov     [USBUART_1_APITemp], A        ; Save the count
                                        (0389) 
0C03: 50 04    MOV   A,0x4              (0390)     mov     A, 04h                     ; EP2
0C05: 34 1D    XOR   [0x1D],A           (0391) 	xor     [USBUART_1_EPDataToggle], A
0C07: 22 1D    AND   A,[0x1D]           (0392)     and     A, [USBUART_1_EPDataToggle]
0C09: A0 06    JZ    0x0C10             (0393)     jz      .toggle0
                                        (0394) 
0C0B: 55 39 80 MOV   [0x39],0x80        (0395)     mov      [USBUART_1_APITemp+1], USB_CNT_TOGGLE ; Set the data toggle
0C0E: 80 04    JMP   0x0C13             (0396)     jmp     .toggle_done
                                        (0397) 
                                        (0398) .toggle0:
0C10: 55 39 00 MOV   [0x39],0x0         (0399)     mov     [USBUART_1_APITemp+1], 0
                                        (0400) 
                                        (0401) .toggle_done:
0C13: 52 FA    MOV   A,[X-6]            (0402) 	mov     A, [X+CNTLEN]                  ;Get count
0C15: 60 51    MOV   REG[0x51],A        (0403)     mov     reg[USBUART_1_EP2CNT0], A   ; Write it into the register
0C17: 51 39    MOV   A,[0x39]           (0404)     mov     A, [USBUART_1_APITemp+1]    ; Retrieve the saved toggle
0C19: 60 50    MOV   REG[0x50],A        (0405) 	mov     reg[USBUART_1_EP2CNT1], A      ; Write it into the register
0C1B: 71 10    OR    F,0x10             
                                        (0406) 
                                        (0407) ; It's Time to move the data
                                        (0408) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (0409)    M8C_SetBank1
0C1D: 5D 6D    MOV   A,REG[0x6D]        (0410)    mov   A, reg[TMP_DR1]                ; Get the address of ep from tmp register
0C1F: 49 F7 01 TST   REG[0xF7],0x1      (0411)    tst   reg[CPU_F], 0x01
0C22: A0 09    JZ    0x0C2C             (0412)    jz    .DontTouchGIE1
0C24: 70 FE    AND   F,0xFE             
                                        (0413)    M8C_DisableGInt
0C26: 60 40    MOV   REG[0x40],A        (0414)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0C28: 71 01    OR    F,0x1              
                                        (0415)    M8C_EnableGInt
0C2A: 80 03    JMP   0x0C2E             (0416)    jmp   .Continue1
                                        (0417) .DontTouchGIE1:
0C2C: 60 40    MOV   REG[0x40],A        (0418)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0C2E: 70 EF    AND   F,0xEF             
                                        (0419) .Continue1:
                                        (0420) 	M8C_SetBank0
                                        (0421) 
                                        (0422) ; Now we are y to start moving data
0C30: 52 FA    MOV   A,[X-6]            (0423) 	mov     A, [X+CNTLEN]                  ; Check the count
0C32: A0 2C    JZ    0x0C5F             (0424) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                        (0425) 
0C34: 2F FF 00 OR    [X-1],0x0          (0426) 	or	 	[X+MEM_TYPE], 0
0C37: B0 14    JNZ   0x0C4C             (0427) 	jnz		.start_send_rom
                                        (0428) 
0C39: 52 FC    MOV   A,[X-4]            (0429) 	mov     A, [X+DATA_LSB]
0C3B: 08       PUSH  A                  (0430) 	push    A
                                        (0431) IF SYSTEM_LARGE_MEMORY_MODEL
0C3C: 52 FB    MOV   A,[X-5]            (0432) 	mov     A, [X+DATA_MSB]
0C3E: 60 D3    MOV   REG[0xD3],A        (0433) 	mov     reg[IDX_PP], A
                                        (0434) ENDIF
0C40: 20       POP   X                  (0435) 	pop     X
                                        (0436) 
                                        (0437) .loop_ram:
0C41: 52 00    MOV   A,[X+0]            (0438) 	mov		A, [X]
0C43: 60 40    MOV   REG[0x40],A        (0439) 	mov     reg[PMA0_DR], A
0C45: 75       INC   X                  (0440) 	inc     X
0C46: 7A 38    DEC   [0x38]             (0441) 	dec     [USBUART_1_APITemp]
0C48: BF F8    JNZ   0x0C41             (0442) 	jnz     .loop_ram
0C4A: 80 14    JMP   0x0C5F             (0443) 	jmp 	.done
                                        (0444) 
                                        (0445) .start_send_rom:
0C4C: 52 FB    MOV   A,[X-5]            (0446) 	mov     A, [X+DATA_MSB]
0C4E: 53 39    MOV   [0x39],A           (0447) 	mov		[USBUART_1_APITemp+1], A
0C50: 59 FC    MOV   X,[X-4]            (0448) 	mov     X, [X+DATA_LSB]
                                        (0449) 
                                        (0450) .loop_rom:
0C52: 28       ROMX                     (0451) 	romx
0C53: 60 40    MOV   REG[0x40],A        (0452) 	mov     reg[PMA0_DR], A
                                        (0453) 
0C55: 75       INC   X                  (0454) 	inc     X	;go next address
0C56: 0E 39 00 ADC   [0x39],0x0         (0455) 	adc		[USBUART_1_APITemp+1], 0 ; don't forget carry
0C59: 51 39    MOV   A,[0x39]           (0456) 	mov 	A, [USBUART_1_APITemp+1] ; prepare MSB of address
                                        (0457) 
0C5B: 7A 38    DEC   [0x38]             (0458) 	dec     [USBUART_1_APITemp]
0C5D: BF F4    JNZ   0x0C52             (0459) 	jnz     .loop_rom
                                        (0460) 
                                        (0461) .done:
0C5F: 55 24 00 MOV   [0x24],0x0         (0462)     mov     [USBUART_1_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0C62: 71 10    OR    F,0x10             
                                        (0463) 
                                        (0464)    M8C_SetBank1
0C64: 5D 6D    MOV   A,REG[0x6D]        (0465)    mov   A, reg[TMP_DR1]               ; Get the value of the PMA start Address
0C66: 49 F7 01 TST   REG[0xF7],0x1      (0466)    tst   reg[CPU_F], 0x01
0C69: A0 09    JZ    0x0C73             (0467)    jz    .DontTouchGIE2
0C6B: 70 FE    AND   F,0xFE             
                                        (0468)    M8C_DisableGInt
0C6D: 60 52    MOV   REG[0x52],A        (0469)    mov   reg[PMA0_RA+2], A             ; Load it into EP PMA so pre-fetch occurs
0C6F: 71 01    OR    F,0x1              
                                        (0470)    M8C_EnableGInt
0C71: 80 03    JMP   0x0C75             (0471)    jmp   .Continue2
                                        (0472) .DontTouchGIE2:
0C73: 60 52    MOV   REG[0x52],A        (0473)    mov   reg[PMA0_RA+2], A             ; Load it into EP PMA so pre-fetch occurs
                                        (0474) .Continue2:
0C75: 62 C5 0D MOV   REG[0xC5],0xD      (0475)    mov   reg[USBUART_1_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0C78: 70 EF    AND   F,0xEF             
                                        (0476) 	M8C_SetBank0
                                        (0477) 
0C7A: 18       POP   A                  (0478) 	pop 	A ; Clean up MEM_TYPE
0C7B: 70 3F    AND   F,0x3F             
0C7D: 71 C0    OR    F,0xC0             
                                        (0479)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0480) 	RAM_EPILOGUE RAM_USE_CLASS_4
0C7F: 7F       RET                      (0481)     ret
0C80: 70 BF    AND   F,0xBF             
0C82: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0482) .ENDSECTION
                                        (0483) 
                                        (0484) .SECTION
                                        (0485) ;-----------------------------------------------------------------------------
                                        (0486) ;  FUNCTION NAME: USBUART_1_PutString
                                        (0487) ;
                                        (0488) ;  DESCRIPTION:    Send NULL terminated string
                                        (0489) ;
                                        (0490) ;-----------------------------------------------------------------------------
                                        (0491) ;
                                        (0492) ;  ARGUMENTS:
                                        (0493) ;     A contains MSB of the string pointer
                                        (0494) ;     X contains LSB of the string pointer
                                        (0495) ;
                                        (0496) ;  RETURNS:
                                        (0497) ;     none
                                        (0498) ;
                                        (0499) ;  SIDE EFFECTS:
                                        (0500) ;    The A and X registers may be modified by this or future implementations
                                        (0501) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0502) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0503) ;    responsibility to preserve their values across calls to fastcall16
                                        (0504) ;    functions.
                                        (0505) ;
                                        (0506) ;    Currently only the page pointer registers listed below are modified:
                                        (0507) ;          CUR_PP
                                        (0508) ;          IDX_PP
                                        (0509) ;
                                        (0510) 
                                        (0511)  USBUART_1_PutString:
                                        (0512) _USBUART_1_PutString:
                                        (0513)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0514)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0515) 	RAM_SETPAGE_CUR >USBUART_1_APITemp    ; Set the CUR_PP to the right page
0C85: 08       PUSH  A                  (0516) 	push	A
0C86: 08       PUSH  A                  (0517) 	push	A	;put MSB of dataPtr  - prepare to Write call
0C87: 10       PUSH  X                  (0518) 	push	X	;put LSB of dataPtr - prepare to Write call
                                        (0519) IF SYSTEM_LARGE_MEMORY_MODEL
0C88: 60 D3    MOV   REG[0xD3],A        (0520) 	mov     reg[IDX_PP], A
                                        (0521) ENDIF
0C8A: 55 38 00 MOV   [0x38],0x0         (0522) 	mov		[USBUART_1_APITemp], 0; init the length counter
                                        (0523) .loop:
0C8D: 52 00    MOV   A,[X+0]            (0524) 	mov		A, [X]
0C8F: A0 06    JZ    0x0C96             (0525) 	jz		.done
0C91: 75       INC   X                  (0526) 	inc		X
0C92: 76 38    INC   [0x38]             (0527) 	inc		[USBUART_1_APITemp]
0C94: 8F F8    JMP   0x0C8D             (0528) 	jmp		.loop
0C96: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0529) .done:
                                        (0530)     RAM_SETPAGE_IDX2STK
0C99: 51 38    MOV   A,[0x38]           (0531) 	mov		A, [USBUART_1_APITemp]
0C9B: 4F       MOV   X,SP               (0532) 	mov		X, SP
0C9C: 54 FD    MOV   [X-3],A            (0533) 	mov 	[X-3], A
0C9E: 7C 0B F3 LCALL _USBUART_1_Write   (0534) 	lcall 	USBUART_1_Write
0CA1: 38 FD    ADD   SP,0xFD            (0535) 	add		SP, 253
0CA3: 70 3F    AND   F,0x3F             
0CA5: 71 C0    OR    F,0xC0             
                                        (0536)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0537) 	RAM_EPILOGUE RAM_USE_CLASS_4
0CA7: 7F       RET                      (0538)     ret
0CA8: 70 BF    AND   F,0xBF             
0CAA: 62 D0 00 MOV   REG[0xD0],0x0      
0CAD: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0539) .ENDSECTION
                                        (0540) 
                                        (0541) .SECTION
                                        (0542) ;-----------------------------------------------------------------------------
                                        (0543) ;  FUNCTION NAME: USBUART_1_CPutString
                                        (0544) ;
                                        (0545) ;  DESCRIPTION:    Send NULL terminated string ROM located string
                                        (0546) ;
                                        (0547) ;-----------------------------------------------------------------------------
                                        (0548) ;
                                        (0549) ;  ARGUMENTS:
                                        (0550) ;     A contains MSB of the string pointer
                                        (0551) ;     X contains LSB of the string pointer
                                        (0552) ;
                                        (0553) ;  RETURNS:
                                        (0554) ;     none
                                        (0555) ;
                                        (0556) ;  SIDE EFFECTS:
                                        (0557) ;    The A and X registers may be modified by this or future implementations
                                        (0558) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0560) ;    responsibility to preserve their values across calls to fastcall16
                                        (0561) ;    functions.
                                        (0562) ;
                                        (0563) ;    Currently only the page pointer registers listed below are modified:
                                        (0564) ;          CUR_PP
                                        (0565) ;          IDX_PP
                                        (0566) ;
                                        (0567) 
                                        (0568)  USBUART_1_CPutString:
                                        (0569) _USBUART_1_CPutString:
                                        (0570)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0571)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0572) 	RAM_SETPAGE_CUR >USBUART_1_APITemp    ; Set the CUR_PP to the right page
                                        (0573) 	RAM_SETPAGE_IDX2STK
0CB0: 08       PUSH  A                  (0574) 	push	A	;reserve placeholder for count - prepare to Write call
0CB1: 08       PUSH  A                  (0575) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CB2: 10       PUSH  X                  (0576) 	push	X	;put LSB of dataPtr - prepare to Write call
0CB3: 55 38 00 MOV   [0x38],0x0         (0577) 	mov		[USBUART_1_APITemp], 0	; init the length counter
0CB6: 53 39    MOV   [0x39],A           (0578) 	mov		[USBUART_1_APITemp+1], A	; store the pointer MSB
                                        (0579) .loop:
0CB8: 28       ROMX                     (0580) 	romx
0CB9: A0 0B    JZ    0x0CC5             (0581) 	jz		.done
0CBB: 75       INC   X                  (0582) 	inc		X	;increment pointer LSB
0CBC: 0E 39 00 ADC   [0x39],0x0         (0583) 	adc 	[USBUART_1_APITemp+1],0 ;don't forget carry
0CBF: 76 38    INC   [0x38]             (0584) 	inc		[USBUART_1_APITemp]	;increment counter
0CC1: 51 39    MOV   A,[0x39]           (0585) 	mov 	A, [USBUART_1_APITemp+1]	;load MSB into A - prepare address for romx
0CC3: 8F F4    JMP   0x0CB8             (0586) 	jmp		.loop
                                        (0587) .done:
0CC5: 51 38    MOV   A,[0x38]           (0588) 	mov		A, [USBUART_1_APITemp]
0CC7: 4F       MOV   X,SP               (0589) 	mov		X, SP
0CC8: 54 FD    MOV   [X-3],A            (0590) 	mov 	[X-3], A
0CCA: 7C 0B EE LCALL _USBUART_1_CWrite  (0591) 	lcall 	USBUART_1_CWrite
0CCD: 38 FD    ADD   SP,0xFD            (0592) 	add		SP, 253
0CCF: 70 3F    AND   F,0x3F             
0CD1: 71 C0    OR    F,0xC0             
                                        (0593)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0594) 	RAM_EPILOGUE RAM_USE_CLASS_4
0CD3: 7F       RET                      (0595)     ret
                                        (0596) .ENDSECTION
                                        (0597) 
                                        (0598) .SECTION
                                        (0599) ;-----------------------------------------------------------------------------
                                        (0600) ;  FUNCTION NAME: USBUART_1_PutChar
                                        (0601) ;
                                        (0602) ;  DESCRIPTION:    Send one character
                                        (0603) ;
                                        (0604) ;-----------------------------------------------------------------------------
                                        (0605) ;
                                        (0606) ;  ARGUMENTS:
                                        (0607) ;     A contains character to send
                                        (0608) ;
                                        (0609) ;  RETURNS:
                                        (0610) ;     none
                                        (0611) ;
                                        (0612) ;  SIDE EFFECTS:
                                        (0613) ;    The A and X registers may be modified by this or future implementations
                                        (0614) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0615) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0616) ;    responsibility to preserve their values across calls to fastcall16
                                        (0617) ;    functions.
                                        (0618) ;
                                        (0619) 
                                        (0620)  USBUART_1_PutChar:
                                        (0621) _USBUART_1_PutChar:
                                        (0622)     RAM_PROLOGUE RAM_USE_CLASS_1
0CD4: 08       PUSH  A                  (0623) 	push 	A	;save character in stack
0CD5: 50 01    MOV   A,0x1              (0624) 	mov 	A, 1;	set 1 byte to transfer
0CD7: 08       PUSH  A                  (0625) 	push	A
                                        (0626) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0CD8: 5D D1    MOV   A,REG[0xD1]        (0627)     mov   	A, reg[STK_PP]
                                        (0628) ELSE
                                        (0629) 	mov 	A, 0
                                        (0630) ENDIF
0CDA: 08       PUSH  A                  (0631) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CDB: 4F       MOV   X,SP               (0632) 	mov 	X, SP
0CDC: 5B       MOV   A,X                (0633) 	mov		A, X
0CDD: 11 03    SUB   A,0x3              (0634) 	sub 	A, 3
0CDF: 08       PUSH  A                  (0635) 	push	A	;put LSB of dataPtr - prepare to Write call
0CE0: 7C 0B F3 LCALL _USBUART_1_Write   (0636) 	lcall 	USBUART_1_Write
0CE3: 38 FC    ADD   SP,0xFC            (0637) 	add		SP, 252
                                        (0638) 	RAM_EPILOGUE RAM_USE_CLASS_1
0CE5: 7F       RET                      (0639)     ret
                                        (0640) .ENDSECTION
                                        (0641) 
                                        (0642) .SECTION
                                        (0643) ;-----------------------------------------------------------------------------
                                        (0644) ;  FUNCTION NAME: USBUART_1_PutCRLF
                                        (0645) ;
                                        (0646) ;  DESCRIPTION:    Send one character
                                        (0647) ;
                                        (0648) ;-----------------------------------------------------------------------------
                                        (0649) ;
                                        (0650) ;  ARGUMENTS:
                                        (0651) ;     none
                                        (0652) ;
                                        (0653) ;  RETURNS:
                                        (0654) ;     none
                                        (0655) ;
                                        (0656) ;  SIDE EFFECTS:
                                        (0657) ;    The A and X registers may be modified by this or future implementations
                                        (0658) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0659) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0660) ;    responsibility to preserve their values across calls to fastcall16
                                        (0661) ;    functions.
                                        (0662) ;
                                        (0663) 
                                        (0664)  USBUART_1_PutCRLF:
                                        (0665) _USBUART_1_PutCRLF:
                                        (0666)     RAM_PROLOGUE RAM_USE_CLASS_1
0CE6: 50 0D    MOV   A,0xD              (0667) 	mov 	A, 0Dh
0CE8: 08       PUSH  A                  (0668) 	push 	A	;save character in stack
0CE9: 50 0A    MOV   A,0xA              (0669) 	mov 	A, 0Ah
0CEB: 08       PUSH  A                  (0670) 	push 	A	;save character in stack
0CEC: 50 02    MOV   A,0x2              (0671) 	mov 	A, 2;	set 2 byte to transfer
0CEE: 08       PUSH  A                  (0672) 	push	A
                                        (0673) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0CEF: 5D D1    MOV   A,REG[0xD1]        (0674)     mov   	A, reg[STK_PP]
                                        (0675) ELSE
                                        (0676) 	mov 	A, 0
                                        (0677) ENDIF
0CF1: 08       PUSH  A                  (0678) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CF2: 4F       MOV   X,SP               (0679) 	mov 	X, SP
0CF3: 5B       MOV   A,X                (0680) 	mov		A, X
0CF4: 11 04    SUB   A,0x4              (0681) 	sub 	A, 4
0CF6: 08       PUSH  A                  (0682) 	push	A	;put LSB of dataPtr - prepare to Write call
0CF7: 7C 0B F3 LCALL _USBUART_1_Write   (0683) 	lcall 	USBUART_1_Write
0CFA: 38 FB    ADD   SP,0xFB            (0684) 	add		SP, 251
                                        (0685) 	RAM_EPILOGUE RAM_USE_CLASS_1
0CFC: 7F       RET                      (0686)     ret
                                        (0687) .ENDSECTION
                                        (0688) 
                                        (0689) .SECTION
                                        (0690) ;-----------------------------------------------------------------------------
                                        (0691) ;  FUNCTION NAME: USBUART_1_PutSHexByte
                                        (0692) ;
                                        (0693) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                        (0694) ;
                                        (0695) ;-----------------------------------------------------------------------------
                                        (0696) ;
                                        (0697) ;  ARGUMENTS:
                                        (0698) ;     A contains byte to send
                                        (0699) ;
                                        (0700) ;  RETURNS:
                                        (0701) ;     none
                                        (0702) ;
                                        (0703) ;  SIDE EFFECTS:
                                        (0704) ;    The A and X registers may be modified by this or future implementations
                                        (0705) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0706) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0707) ;    responsibility to preserve their values across calls to fastcall16
                                        (0708) ;    functions.
                                        (0709) ;
                                        (0710)  USBUART_1_PutSHexByte:
                                        (0711) _USBUART_1_PutSHexByte:
                                        (0712)     RAM_PROLOGUE RAM_USE_CLASS_1
0CFD: 5C       MOV   X,A                (0713) 	mov 	X, A	; Save lower nibble
0CFE: 67       ASR   A                  (0714) 	asr		A   ; Shift high nibble to right
0CFF: 67       ASR   A                  (0715) 	asr		A
0D00: 67       ASR   A                  (0716) 	asr		A
0D01: 67       ASR   A                  (0717) 	asr		A
0D02: 21 0F    AND   A,0xF              (0718) 	and		A,0Fh	; Mask off nibble
0D04: FE 3B    INDEX 0x0B41             (0719) 	index USBUART_1_HEX_STR;  Get Hex value
0D06: 08       PUSH  A                  (0720) 	push 	A
0D07: 5B       MOV   A,X                (0721) 	mov		A, X
0D08: 21 0F    AND   A,0xF              (0722) 	and   	A,0Fh	; Mask off lower nibble
0D0A: FE 35    INDEX 0x0B41             (0723) 	index USBUART_1_HEX_STR	; Get Hex value
0D0C: 08       PUSH  A                  (0724) 	push	A
0D0D: 50 02    MOV   A,0x2              (0725) 	mov		A, 2	; 2 bytes to transfer
0D0F: 08       PUSH  A                  (0726) 	push	A
                                        (0727) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D10: 5D D1    MOV   A,REG[0xD1]        (0728)     mov   	A, reg[STK_PP]
                                        (0729) ELSE
                                        (0730) 	mov 	A, 0
                                        (0731) ENDIF
0D12: 08       PUSH  A                  (0732) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D13: 4F       MOV   X,SP               (0733) 	mov 	X, SP
0D14: 5B       MOV   A,X                (0734) 	mov		A, X
0D15: 11 04    SUB   A,0x4              (0735) 	sub 	A, 4
0D17: 08       PUSH  A                  (0736) 	push	A	;put LSB of dataPtr - prepare to Write call
0D18: 7C 0B F3 LCALL _USBUART_1_Write   (0737) 	lcall 	USBUART_1_Write
0D1B: 38 FB    ADD   SP,0xFB            (0738) 	add		SP, 251
                                        (0739) 	RAM_EPILOGUE RAM_USE_CLASS_1
0D1D: 7F       RET                      (0740)     ret
0D1E: 70 BF    AND   F,0xBF             
0D20: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0741) .ENDSECTION
                                        (0742) 
                                        (0743) .SECTION
                                        (0744) ;-----------------------------------------------------------------------------
                                        (0745) ;  FUNCTION NAME: USBUART_1_PutSHexInt
                                        (0746) ;
                                        (0747) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                        (0748) ;
                                        (0749) ;-----------------------------------------------------------------------------
                                        (0750) ;
                                        (0751) ;  ARGUMENTS:
                                        (0752) ;     A  => LSB of Int
                                        (0753) ;     X  => MSB of Int
                                        (0754) ;
                                        (0755) ;  RETURNS:
                                        (0756) ;     none
                                        (0757) ;
                                        (0758) ;  SIDE EFFECTS:
                                        (0759) ;    The A and X registers may be modified by this or future implementations
                                        (0760) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0761) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0762) ;    responsibility to preserve their values across calls to fastcall16
                                        (0763) ;    functions.
                                        (0764) ;
                                        (0765)  USBUART_1_PutSHexInt:
                                        (0766) _USBUART_1_PutSHexInt:
                                        (0767)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0768) 	RAM_SETPAGE_IDX2STK
0D23: 08       PUSH  A                  (0769) 	push	A	;save LSB
0D24: 5B       MOV   A,X                (0770) 	mov 	A, X
0D25: 67       ASR   A                  (0771) 	asr		A   ; Shift high nibble to right
0D26: 67       ASR   A                  (0772) 	asr		A
0D27: 67       ASR   A                  (0773) 	asr		A
0D28: 67       ASR   A                  (0774) 	asr		A
0D29: 21 0F    AND   A,0xF              (0775) 	and		A,0Fh	; Mask off nibble
0D2B: FE 14    INDEX 0x0B41             (0776) 	index USBUART_1_HEX_STR;  Get Hex value
0D2D: 08       PUSH  A                  (0777) 	push	A
0D2E: 5B       MOV   A,X                (0778) 	mov		A, X	;retrieve lower nibble
0D2F: 21 0F    AND   A,0xF              (0779) 	and   	A,0Fh	; Mask off lower nibble
0D31: FE 0E    INDEX 0x0B41             (0780) 	index USBUART_1_HEX_STR	; Get Hex value
0D33: 08       PUSH  A                  (0781) 	push	A
0D34: 4F       MOV   X,SP               (0782) 	mov 	X, SP
0D35: 52 FD    MOV   A,[X-3]            (0783) 	mov		A, [X-3]	;retrieve LSB
0D37: 5C       MOV   X,A                (0784) 	mov 	X, A	; Save lower nibble
0D38: 67       ASR   A                  (0785) 	asr		A   ; Shift high nibble to right
0D39: 67       ASR   A                  (0786) 	asr		A
0D3A: 67       ASR   A                  (0787) 	asr		A
0D3B: 67       ASR   A                  (0788) 	asr		A
0D3C: 21 0F    AND   A,0xF              (0789) 	and		A,0Fh	; Mask off nibble
0D3E: FE 01    INDEX 0x0B41             (0790) 	index USBUART_1_HEX_STR;  Get Hex value
0D40: 08       PUSH  A                  (0791) 	push	A
0D41: 5B       MOV   A,X                (0792) 	mov		A, X
0D42: 21 0F    AND   A,0xF              (0793) 	and   	A,0Fh	; Mask off lower nibble
0D44: FD FB    INDEX 0x0B41             (0794) 	index USBUART_1_HEX_STR	; Get Hex value
0D46: 08       PUSH  A                  (0795) 	push	A
                                        (0796) 
0D47: 50 04    MOV   A,0x4              (0797) 	mov		A, 4	; 4 bytes to transfer
0D49: 08       PUSH  A                  (0798) 	push	A
                                        (0799) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D4A: 5D D1    MOV   A,REG[0xD1]        (0800)     mov   	A, reg[STK_PP]
                                        (0801) ELSE
                                        (0802) 	mov 	A, 0
                                        (0803) ENDIF
0D4C: 08       PUSH  A                  (0804) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D4D: 4F       MOV   X,SP               (0805) 	mov 	X, SP
0D4E: 5B       MOV   A,X                (0806) 	mov		A, X
0D4F: 11 06    SUB   A,0x6              (0807) 	sub 	A, 6
0D51: 08       PUSH  A                  (0808) 	push	A	;put LSB of dataPtr - prepare to Write call
0D52: 7C 0B F3 LCALL _USBUART_1_Write   (0809) 	lcall 	USBUART_1_Write
0D55: 38 F8    ADD   SP,0xF8            (0810) 	add		SP, 248
0D57: 70 3F    AND   F,0x3F             
0D59: 71 C0    OR    F,0xC0             
                                        (0811) 	RAM_EPILOGUE RAM_USE_CLASS_3
0D5B: 7F       RET                      (0812)     ret
0D5C: 70 BF    AND   F,0xBF             
0D5E: 62 D0 00 MOV   REG[0xD0],0x0      
0D61: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0813) .ENDSECTION
                                        (0814) 
                                        (0815) .SECTION
                                        (0816) ;-----------------------------------------------------------------------------
                                        (0817) ;  FUNCTION NAME: USBUART_1_Read
                                        (0818) ;
                                        (0819) ;  DESCRIPTION:    This function reads from the specified endpoint buffer
                                        (0820) ;                  with the count number of bytes.
                                        (0821) ;
                                        (0822) ;-----------------------------------------------------------------------------
                                        (0823) ;
                                        (0824) ;  ARGUMENTS:
                                        (0825) ;     [SP-5] Count to read
                                        (0826) ;     [SP-4] MSB of data array address to put data in
                                        (0827) ;     [SP-3] LSB of data array address to put data in
                                        (0828) ;
                                        (0829) ;  RETURNS:
                                        (0830) ;     none
                                        (0831) ;
                                        (0832) ;  SIDE EFFECTS:
                                        (0833) ;    The A and X registers may be modified by this or future implementations
                                        (0834) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0835) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0836) ;    responsibility to preserve their values across calls to fastcall16
                                        (0837) ;    functions.
                                        (0838) ;
                                        (0839) ;    Currently only the page pointer registers listed below are modified:
                                        (0840) ;          CUR_PP
                                        (0841) ;          IDX_PP
                                        (0842) ;
                                        (0843) DATA_LSBR:   equ -3           ; MSB pointer of data
                                        (0844) DATA_MSBR:   equ -4           ; LSB pointer of data
                                        (0845) RDCNTLEN:		 equ -5           ; Length of data to send
                                        (0846) 
                                        (0847)  USBUART_1_Read:
                                        (0848) _USBUART_1_Read:
                                        (0849)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0850)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0851) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (0852)     RAM_SETPAGE_IDX2STK
                                        (0853) 
                                        (0854)     ;Get the count value passed
0D64: 4F       MOV   X,SP               (0855) 	mov		X, SP
0D65: 52 FB    MOV   A,[X-5]            (0856) 	mov     A, [X+RDCNTLEN]               ; Get the Count
0D67: 53 38    MOV   [0x38],A           (0857) 	mov     [USBUART_1_APITemp], A        ; Save the count
                                        (0858) 
                                        (0859)     ;Determine which is smaller the requested data or the available data
0D69: 5D 53    MOV   A,REG[0x53]        (0860) 	mov     A, reg[USBUART_1_EP3CNT0]      ; Get the Real count
0D6B: 53 39    MOV   [0x39],A           (0861) 	mov 	[USBUART_1_APITemp+1], A ; set the reminder
0D6D: 11 02    SUB   A,0x2              (0862) 	sub 	A, 2
0D6F: 3A 38    CMP   A,[0x38]           (0863) 	cmp     A, [USBUART_1_APITemp]         ; Are they equal
0D71: A0 07    JZ    0x0D79             (0864) 	jz      .CountCorrect                  ; If they are check if they are 1
0D73: D0 05    JNC   0x0D79             (0865) 	jnc      .CountCorrect                 ;If the requested count is smaller use it
0D75: 50 80    MOV   A,0x80             (0866) 	mov 	A, 80h	; Set error condition and exit
0D77: 80 70    JMP   0x0DE8             (0867) 	jmp 	.exit
0D79: 71 10    OR    F,0x10             
                                        (0868) 
                                        (0869) .CountCorrect:
                                        (0870) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (0871)    M8C_SetBank1
0D7B: 5D 6E    MOV   A,REG[0x6E]        (0872)    mov   A, reg[TMP_DR2]                ; Get the address of ep from tmp register
0D7D: 49 F7 01 TST   REG[0xF7],0x1      (0873)    tst   reg[CPU_F], 0x01
0D80: A0 09    JZ    0x0D8A             (0874)    jz    .DontTouchGIE3
0D82: 70 FE    AND   F,0xFE             
                                        (0875)    M8C_DisableGInt
0D84: 60 50    MOV   REG[0x50],A        (0876)    mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
0D86: 71 01    OR    F,0x1              
                                        (0877)    M8C_EnableGInt
0D88: 80 03    JMP   0x0D8C             (0878)    jmp   .Continue3
                                        (0879) .DontTouchGIE3:
0D8A: 60 50    MOV   REG[0x50],A        (0880)    mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
0D8C: 70 EF    AND   F,0xEF             
                                        (0881) .Continue3:
                                        (0882) 	M8C_SetBank0
                                        (0883) 
                                        (0884) ; Now we are ready to start moving data
0D8E: 51 38    MOV   A,[0x38]           (0885) 	mov     A, [USBUART_1_APITemp]         ; Check the Count register
0D90: A0 28    JZ    0x0DB9             (0886) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                        (0887) 
                                        (0888) .start_send:
0D92: 52 FD    MOV   A,[X-3]            (0889) 	mov     A, [X+DATA_LSBR]               ; Get the LSB of the pointer
0D94: 08       PUSH  A                  (0890) 	push    A                              ; save on stack
                                        (0891) IF SYSTEM_LARGE_MEMORY_MODEL
0D95: 52 FC    MOV   A,[X-4]            (0892) 	mov     A, [X+DATA_MSBR]               ; Get the MSB of the pointer
0D97: 60 D3    MOV   REG[0xD3],A        (0893) 	mov     reg[IDX_PP], A                 ; Use as value for IDX_PP
                                        (0894) ENDIF
0D99: 20       POP   X                  (0895) 	pop     X                              ; Get the LSB again
0D9A: 71 10    OR    F,0x10             
                                        (0896) 
                                        (0897)     ;; 24Mhz read PMA workaround 
                                        (0898)     M8C_SetBank1
0D9C: 5D E0    MOV   A,REG[0xE0]        (0899)     mov     A, reg[OSC_CR0]
0D9E: 08       PUSH  A                  (0900)     push    A
0D9F: 21 F8    AND   A,0xF8             (0901)     and     A, 0xf8 ;clear the clock bits 
0DA1: 29 02    OR    A,0x2              (0902)     or      A, 0x02 ;will set clk to 12Mhz
0DA3: 60 E0    MOV   REG[0xE0],A        (0903)     mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
0DA5: 70 EF    AND   F,0xEF             
                                        (0904)     M8C_SetBank0
                                        (0905) 
                                        (0906) .loop:
0DA7: 5D 40    MOV   A,REG[0x40]        (0907) 	mov     A, reg[PMA0_DR]                ; Get the data from the PMA space
0DA9: 54 00    MOV   [X+0],A            (0908) 	mov		[X], A                            ; save it in data array
0DAB: 75       INC   X                  (0909) 	inc     X                              ; increment the pointer
0DAC: 7A 39    DEC   [0x39]             (0910) 	dec		[USBUART_1_APITemp+1]             ; decrement the reminder
0DAE: 7A 38    DEC   [0x38]             (0911) 	dec     [USBUART_1_APITemp]            ; decrement the counter
0DB0: BF F6    JNZ   0x0DA7             (0912) 	jnz     .loop                          ; wait for count to zero out
                                        (0913) 
                                        (0914)     ;; 24Mhz read PMA workaround (back to previous clock speed)
0DB2: 18       POP   A                  (0915)     pop     A ;recover previous reg[OSC_CR0] value
0DB3: 71 10    OR    F,0x10             
                                        (0916)     M8C_SetBank1
0DB5: 60 E0    MOV   REG[0xE0],A        (0917)     mov     reg[OSC_CR0], A ;clk is now set at previous value (probably 24Mhz)
0DB7: 70 EF    AND   F,0xEF             
0DB9: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0918)     M8C_SetBank0
                                        (0919)     ;; end 24Mhz read PMA workaround 
                                        (0920) 
                                        (0921) .done:
                                        (0922)     RAM_SETPAGE_IDX2STK
0DBC: 4F       MOV   X,SP               (0923) 	mov		X, SP
0DBD: 5D 6E    MOV   A,REG[0x6E]        (0924)     mov     A, reg[TMP_DR2]
0DBF: 03 FB    ADD   A,[X-5]            (0925)     add     A, [X+RDCNTLEN]
0DC1: 60 6E    MOV   REG[0x6E],A        (0926)     mov     reg[TMP_DR2], A
0DC3: 3C 39 02 CMP   [0x39],0x2         (0927) 	cmp 	[USBUART_1_APITemp+1], 2 	; If only 2 bytes of checksum left in EP
0DC6: A0 09    JZ    0x0DD0             (0928) 	jz		.BufferEmpty
0DC8: 51 39    MOV   A,[0x39]           (0929) 	mov		A, [USBUART_1_APITemp+1]		; Prepare count reminder for return
0DCA: 60 53    MOV   REG[0x53],A        (0930) 	mov		reg[USBUART_1_EP3CNT0], A
0DCC: 11 02    SUB   A,0x2              (0931)     sub     A, 2
0DCE: 80 19    JMP   0x0DE8             (0932) 	jmp .exit
                                        (0933) 
                                        (0934) .BufferEmpty:
0DD0: 55 25 00 MOV   [0x25],0x0         (0935)     mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0DD3: 62 53 40 MOV   REG[0x53],0x40     (0936) 	mov     reg[USBUART_1_EP3CNT0], 64
0DD6: 71 10    OR    F,0x10             
                                        (0937) 	M8C_SetBank1
0DD8: 62 6E 80 MOV   REG[0x6E],0x80     (0938) 	mov		reg[TMP_DR2], 128
0DDB: 5D 6E    MOV   A,REG[0x6E]        (0939)     mov     A, reg[TMP_DR2]
0DDD: 60 43    MOV   REG[0x43],A        (0940) 	mov     reg[PMA3_WA], A
0DDF: 5D C6    MOV   A,REG[0xC6]        (0941)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0DE1: 62 C6 09 MOV   REG[0xC6],0x9      (0942)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0DE4: 50 00    MOV   A,0x0              (0943) 	mov 	A, 0;	; No error and no bytes left in EP
0DE6: 70 EF    AND   F,0xEF             
0DE8: 70 3F    AND   F,0x3F             
0DEA: 71 C0    OR    F,0xC0             
                                        (0944)     M8C_SetBank0
                                        (0945) 
                                        (0946) .exit:
                                        (0947)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0948) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DEC: 7F       RET                      (0949)     ret
                                        (0950) .ENDSECTION
                                        (0951) 
                                        (0952) .SECTION
                                        (0953) ;-----------------------------------------------------------------------------
                                        (0954) ;  FUNCTION NAME: USBUART_1_ReadAll
                                        (0955) ;
                                        (0956) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                        (0957) ;
                                        (0958) ;-----------------------------------------------------------------------------
                                        (0959) ;
                                        (0960) ;  ARGUMENTS:
                                        (0961) ;     A - MSB of data array address to put data in
                                        (0962) ;     X - LSB of data array address to put data in
                                        (0963) ;
                                        (0964) ;  RETURNS:
                                        (0965) ;     none
                                        (0966) ;
                                        (0967) ;  SIDE EFFECTS:
                                        (0968) ;    The A and X registers may be modified by this or future implementations
                                        (0969) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0970) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0971) ;    responsibility to preserve their values across calls to fastcall16
                                        (0972) ;    functions.
                                        (0973) ;
                                        (0974) 
                                        (0975)  USBUART_1_ReadAll:
                                        (0976) _USBUART_1_ReadAll:
                                        (0977)     RAM_PROLOGUE RAM_USE_CLASS_2
0DED: 38 01    ADD   SP,0x1             (0978) 	add		SP, 1	; Prepare space for number of bytes
0DEF: 08       PUSH  A                  (0979) 	push	A	;put MSB of dataPtr  - prepare to Write call
0DF0: 10       PUSH  X                  (0980) 	push	X	;put LSB of dataPtr - prepare to Write call
0DF1: 5D 53    MOV   A,REG[0x53]        (0981)    	mov     A, reg[USBUART_1_EP3CNT0]  ; Here is the count
0DF3: 11 02    SUB   A,0x2              (0982) 	sub		A, 2
0DF5: 4F       MOV   X,SP               (0983) 	mov		X, SP
0DF6: 54 FD    MOV   [X-3],A            (0984) 	mov 	[X-3], A ; put the number of bytes
0DF8: 70 3F    AND   F,0x3F             
0DFA: 71 C0    OR    F,0xC0             
                                        (0985) 	RAM_EPILOGUE RAM_USE_CLASS_2
0DFC: 7C 0D 5C LCALL _USBUART_1_Read    (0986) 	lcall 	USBUART_1_Read
                                        (0987) 	RAM_PROLOGUE RAM_USE_CLASS_2
0DFF: 38 FD    ADD   SP,0xFD            (0988) 	add		SP, 253
0E01: 70 3F    AND   F,0x3F             
0E03: 71 C0    OR    F,0xC0             
                                        (0989)    	RAM_EPILOGUE RAM_USE_CLASS_2
0E05: 7F       RET                      (0990)     ret
                                        (0991) .ENDSECTION
                                        (0992) 
                                        (0993) .SECTION
                                        (0994) ;-----------------------------------------------------------------------------
                                        (0995) ;  FUNCTION NAME: USBUART_1_ReadChar
                                        (0996) ;
                                        (0997) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                        (0998) ;
                                        (0999) ;-----------------------------------------------------------------------------
                                        (1000) ;
                                        (1001) ;  ARGUMENTS:
                                        (1002) ;     none
                                        (1003) ;
                                        (1004) ;  RETURNS:
                                        (1005) ;     none
                                        (1006) ;
                                        (1007) ;  SIDE EFFECTS:
                                        (1008) ;    The A and X registers may be modified by this or future implementations
                                        (1009) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1010) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1011) ;    responsibility to preserve their values across calls to fastcall16
                                        (1012) ;    functions.
                                        (1013) ;
                                        (1014) 
                                        (1015)  USBUART_1_ReadChar:
                                        (1016) _USBUART_1_ReadChar:
                                        (1017)     RAM_PROLOGUE RAM_USE_CLASS_1
0E06: 38 01    ADD   SP,0x1             (1018) 	add		SP, 1	; Prepare placeholder in stack
0E08: 50 01    MOV   A,0x1              (1019) 	mov		A, 1
0E0A: 08       PUSH  A                  (1020) 	push	A		; Read one byte
                                        (1021) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0E0B: 5D D1    MOV   A,REG[0xD1]        (1022)     mov   	A, reg[STK_PP]
                                        (1023) ELSE
                                        (1024) 	mov 	A, 0
                                        (1025) ENDIF
0E0D: 08       PUSH  A                  (1026) 	push	A	;put MSB of dataPtr  - prepare to Write call
0E0E: 4F       MOV   X,SP               (1027) 	mov 	X, SP
0E0F: 5B       MOV   A,X                (1028) 	mov		A, X
0E10: 11 03    SUB   A,0x3              (1029) 	sub 	A, 3
0E12: 08       PUSH  A                  (1030) 	push	A	;put LSB of dataPtr - prepare to Write call
0E13: 7C 0D 5C LCALL _USBUART_1_Read    (1031) 	lcall 	USBUART_1_Read
0E16: 38 FD    ADD   SP,0xFD            (1032) 	add		SP, 253
0E18: 5C       MOV   X,A                (1033) 	mov		X, A	;copy status to MSB
0E19: 18       POP   A                  (1034) 	pop		A	; Get the character from the stack;
                                        (1035)     RAM_EPILOGUE RAM_USE_CLASS_1
0E1A: 7F       RET                      (1036)     ret
0E1B: 71 10    OR    F,0x10             
                                        (1037) .ENDSECTION
                                        (1038) 
                                        (1039) .SECTION
                                        (1040) ;-----------------------------------------------------------------------------
                                        (1041) ;  FUNCTION NAME: USBUART_1_bTxIsReady
                                        (1042) ;
                                        (1043) ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
                                        (1044) ;                 an endpoint
                                        (1045) ;
                                        (1046) ;-----------------------------------------------------------------------------
                                        (1047) ;
                                        (1048) ;  ARGUMENTS:
                                        (1049) ;	none
                                        (1050) ;
                                        (1051) ;  RETURNS:       A is 0 if Tx is not ready and non-zero if it is
                                        (1052) ;
                                        (1053) ;  SIDE EFFECTS:
                                        (1054) ;    The A and X registers may be modified by this or future implementations
                                        (1055) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1056) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1057) ;    responsibility to preserve their values across calls to fastcall16
                                        (1058) ;    functions.
                                        (1059) ;
                                        (1060)  USBUART_1_bTxIsReady:
                                        (1061) _USBUART_1_bTxIsReady:
                                        (1062)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (1063) 	M8C_SetBank1
0E1D: 5D C5    MOV   A,REG[0xC5]        (1064)     mov    A, reg[USBUART_1_EP2MODE]
0E1F: 70 EF    AND   F,0xEF             
                                        (1065) 	M8C_SetBank0
0E21: 21 10    AND   A,0x10             (1066)     and    A, 0x10
0E23: 7F       RET                      (1067)     ret                                ; Exit
0E24: 70 BF    AND   F,0xBF             
0E26: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1068)     RAM_EPILOGUE RAM_USE_CLASS_1
                                        (1069) .ENDSECTION
                                        (1070) 
                                        (1071) 
                                        (1072) .SECTION
                                        (1073) ;-----------------------------------------------------------------------------
                                        (1074) ;  FUNCTION NAME: USBUART_1_Init
                                        (1075) ;
                                        (1076) ;  DESCRIPTION:    Try to initialize USBUART device if it already enumerated
                                        (1077) ;
                                        (1078) ;-----------------------------------------------------------------------------
                                        (1079) ;
                                        (1080) ;  ARGUMENTS:  None
                                        (1081) ;
                                        (1082) ;  RETURNS:	1 if successfully initialized, otherwise 0
                                        (1083) ;
                                        (1084) ;  SIDE EFFECTS:
                                        (1085) ;    The A and X registers may be modified by this or future implementations
                                        (1086) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1088) ;    responsibility to preserve their values across calls to fastcall16
                                        (1089) ;    functions.
                                        (1090) ;
                                        (1091)  USBUART_1_Init:
                                        (1092) _USBUART_1_Init:
                                        (1093)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1094)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1095) ; check that USB is configured
                                        (1096) 	RAM_SETPAGE_CUR >USBUART_1_Configuration
0E29: 51 01    MOV   A,[0x1]            (1097)     mov     A,[USBUART_1_Configuration]
0E2B: A0 4C    JZ    0x0E78             (1098) 	jz		.done
0E2D: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1099) ; load zero length dummy packet to EP2
                                        (1100) 	RAM_SETPAGE_CUR >USBUART_1_bCurrentDevice ; Set the CUR_PP to the right page
                                        (1101) 
                                        (1102)     ;SET THE COUNT AND TOGGLE
0E30: 50 04    MOV   A,0x4              (1103)     mov     A, 04h                     ; EP2
0E32: 22 1D    AND   A,[0x1D]           (1104)     and     A, [USBUART_1_EPDataToggle]
0E34: A0 03    JZ    0x0E38             (1105)     jz      .toggle_done
0E36: 50 80    MOV   A,0x80             (1106)     mov     A,  USB_CNT_TOGGLE ; Set the data toggle
                                        (1107) 
                                        (1108) .toggle_done:
0E38: 62 51 00 MOV   REG[0x51],0x0      (1109)     mov     reg[USBUART_1_EP2CNT0], 0   ; Write it into the register
0E3B: 60 50    MOV   REG[0x50],A        (1110) 	mov     reg[USBUART_1_EP2CNT1], A      ; Write it into the register
0E3D: 62 D3 03 MOV   REG[0xD3],0x3      
0E40: 71 10    OR    F,0x10             
                                        (1111) 
                                        (1112)     ; It's Time to move the data
                                        (1113)     ; First we need to determine where, within the PMA, the EP Start Address is
                                        (1114)    RAM_SETPAGE_IDX2STK
                                        (1115)    M8C_SetBank1
0E42: 5D 6D    MOV   A,REG[0x6D]        (1116)    mov   A, reg[TMP_DR1]                ; Get the address of ep from tmp register
0E44: 49 F7 01 TST   REG[0xF7],0x1      (1117)    tst   reg[CPU_F], 0x01
0E47: A0 09    JZ    0x0E51             (1118)    jz    .DontTouchGIE4
0E49: 70 FE    AND   F,0xFE             
                                        (1119)    M8C_DisableGInt
0E4B: 60 40    MOV   REG[0x40],A        (1120)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0E4D: 71 01    OR    F,0x1              
                                        (1121)    M8C_EnableGInt
0E4F: 80 03    JMP   0x0E53             (1122)    jmp   .Continue4
                                        (1123) .DontTouchGIE4:
0E51: 60 40    MOV   REG[0x40],A        (1124)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0E53: 70 EF    AND   F,0xEF             
                                        (1125) .Continue4:
                                        (1126)    M8C_SetBank0
                                        (1127) 
                                        (1128)     ; Now we are ready to start moving data
0E55: 55 24 00 MOV   [0x24],0x0         (1129)     mov     [USBUART_1_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0E58: 71 10    OR    F,0x10             
                                        (1130) 	M8C_SetBank1
0E5A: 5D 6D    MOV   A,REG[0x6D]        (1131) 	mov     A, reg[TMP_DR1]               ; Get the value of the PMA start Address
0E5C: 60 52    MOV   REG[0x52],A        (1132) 	mov     reg[PMA2_RA], A               ; Load it into EP PMA so pre-fetch occurs
0E5E: 62 C5 0D MOV   REG[0xC5],0xD      (1133) 	mov     reg[USBUART_1_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0E61: 70 EF    AND   F,0xEF             
                                        (1134) 	M8C_SetBank0
                                        (1135) 
                                        (1136) ; Enable EP 3
0E63: 55 25 00 MOV   [0x25],0x0         (1137)     mov     [USBUART_1_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0E66: 62 53 40 MOV   REG[0x53],0x40     (1138) 	mov     reg[USBUART_1_EP3CNT0], 64
0E69: 71 10    OR    F,0x10             
                                        (1139) 	M8C_SetBank1
0E6B: 5D 6E    MOV   A,REG[0x6E]        (1140)     mov     A, reg[TMP_DR2]
0E6D: 60 43    MOV   REG[0x43],A        (1141) 	mov     reg[PMA3_WA], A
0E6F: 5D C6    MOV   A,REG[0xC6]        (1142)     mov     A, reg[USBUART_1_EP3MODE]  ; Unlock the mode register
0E71: 62 C6 09 MOV   REG[0xC6],0x9      (1143)     mov     reg[USBUART_1_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0E74: 70 EF    AND   F,0xEF             
                                        (1144)     M8C_SetBank0
                                        (1145) 
                                        (1146) ; prepare return
0E76: 50 01    MOV   A,0x1              (1147) 	mov		A, 1
0E78: 70 3F    AND   F,0x3F             
0E7A: 71 C0    OR    F,0xC0             
                                        (1148) 
                                        (1149) .done:
                                        (1150)     RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1151) 	RAM_EPILOGUE RAM_USE_CLASS_4
0E7C: 7F       RET                      (1152)     ret
0E7D: 70 BF    AND   F,0xBF             
0E7F: 41 DF FB AND   REG[0xDF],0xFB     
0E82: 62 D0 00 MOV   REG[0xD0],0x0      
0E85: 60 D3    MOV   REG[0xD3],A        
                                        (1153) .ENDSECTION
                                        (1154) 
                                        (1155) .SECTION
                                        (1156) ;-----------------------------------------------------------------------------
                                        (1157) ;  FUNCTION NAME: USBUART_1_dwGetDTERate
                                        (1158) ;
                                        (1159) ;  DESCRIPTION:    Return DTE Rate
                                        (1160) ;
                                        (1161) ;-----------------------------------------------------------------------------
                                        (1162) ;
                                        (1163) ;  ARGUMENTS:  None
                                        (1164) ;
                                        (1165) ;  RETURNS:	DWORD containing DTE rate in bits per second
                                        (1166) ;
                                        (1167) ;  SIDE EFFECTS:
                                        (1168) ;    The A and X registers may be modified by this or future implementations
                                        (1169) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1170) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1171) ;    responsibility to preserve their values across calls to fastcall16
                                        (1172) ;    functions.
                                        (1173) ;
                                        (1174) USBUART_1_dwGetDTERate:
                                        (1175) _USBUART_1_dwGetDTERate:
                                        (1176) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1177) 	RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1178) 	; Disable interrupt here
                                        (1179) 	M8C_DisableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1180) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
                                        (1181) 	RAM_SETPAGE_IDX A
0E87: 08       PUSH  A                  (1182) 	push  A
0E88: 51 32    MOV   A,[0x32]           (1183) 	mov   A,[USBUART_1_LineCoding + 3]
0E8A: 54 00    MOV   [X+0],A            (1184) 	mov   [X + 0],A
0E8C: 51 31    MOV   A,[0x31]           (1185) 	mov   A,[USBUART_1_LineCoding + 2]
0E8E: 54 01    MOV   [X+1],A            (1186) 	mov   [X + 1],A
0E90: 51 30    MOV   A,[0x30]           (1187) 	mov   A,[USBUART_1_LineCoding + 1]
0E92: 54 02    MOV   [X+2],A            (1188) 	mov   [X + 2],A
0E94: 51 2F    MOV   A,[0x2F]           (1189) 	mov   A,[USBUART_1_LineCoding]
0E96: 54 03    MOV   [X+3],A            (1190) 	mov   [X + 3],A
0E98: 18       POP   A                  (1191) 	pop   A
0E99: 43 DF 04 OR    REG[0xDF],0x4      
0E9C: 70 3F    AND   F,0x3F             
0E9E: 71 C0    OR    F,0xC0             
                                        (1192) 
                                        (1193) 	M8C_EnableIntMask USBUART_1_INT_REG, USBUART_1_INT_EP0_MASK
                                        (1194) 	RAM_EPILOGUE RAM_USE_CLASS_4
                                        (1195) 	RAM_EPILOGUE RAM_USE_CLASS_3
0EA0: 7F       RET                      (1196) 	ret
0EA1: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1197) .ENDSECTION
                                        (1198) 
                                        (1199) .SECTION
                                        (1200) ;-----------------------------------------------------------------------------
                                        (1201) ;  FUNCTION NAME: USBUART_1_bGetCharFormat
                                        (1202) ;
                                        (1203) ;  DESCRIPTION:    Returns number of stop bits
                                        (1204) ;
                                        (1205) ;-----------------------------------------------------------------------------
                                        (1206) ;
                                        (1207) ;  ARGUMENTS:  None
                                        (1208) ;
                                        (1209) ;  RETURNS:	BYTE containing character format (data bits)
                                        (1210) ;				 (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                        (1211) ;
                                        (1212) ;  SIDE EFFECTS:
                                        (1213) ;    The A and X registers may be modified by this or future implementations
                                        (1214) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1215) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1216) ;    responsibility to preserve their values across calls to fastcall16
                                        (1217) ;    functions.
                                        (1218) ;
                                        (1219) USBUART_1_bGetCharFormat:
                                        (1220) _USBUART_1_bGetCharFormat:
                                        (1221) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1222) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EA4: 51 33    MOV   A,[0x33]           (1223) 	mov A, [USBUART_1_LineCoding+4];
                                        (1224) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EA6: 7F       RET                      (1225) 	ret
0EA7: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1226) .ENDSECTION
                                        (1227) 
                                        (1228) .SECTION
                                        (1229) ;-----------------------------------------------------------------------------
                                        (1230) ;  FUNCTION NAME: USBUART_1_bGetParityType
                                        (1231) ;
                                        (1232) ;  DESCRIPTION:    Return Parity type
                                        (1233) ;
                                        (1234) ;-----------------------------------------------------------------------------
                                        (1235) ;
                                        (1236) ;  ARGUMENTS:  None
                                        (1237) ;
                                        (1238) ;  RETURNS:	Parity type
                                        (1239) ;				 (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                        (1240) ;
                                        (1241) ;  SIDE EFFECTS:
                                        (1242) ;    The A and X registers may be modified by this or future implementations
                                        (1243) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1244) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1245) ;    responsibility to preserve their values across calls to fastcall16
                                        (1246) ;    functions.
                                        (1247) ;
                                        (1248) USBUART_1_bGetParityType:
                                        (1249) _USBUART_1_bGetParityType:
                                        (1250) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1251) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EAA: 51 34    MOV   A,[0x34]           (1252) 	mov A, [USBUART_1_LineCoding+5];
                                        (1253) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EAC: 7F       RET                      (1254) 	ret
0EAD: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1255) .ENDSECTION
                                        (1256) 
                                        (1257) .SECTION
                                        (1258) ;-----------------------------------------------------------------------------
                                        (1259) ;  FUNCTION NAME: USBUART_1_bGetDataBits
                                        (1260) ;
                                        (1261) ;  DESCRIPTION:    Returns data bits (5,6,7,8 or 16)
                                        (1262) ;
                                        (1263) ;-----------------------------------------------------------------------------
                                        (1264) ;
                                        (1265) ;  ARGUMENTS:  None
                                        (1266) ;
                                        (1267) ;  RETURNS:	Data bits
                                        (1268) ;				 (5,6,7,8 or 16)
                                        (1269) ;
                                        (1270) ;  SIDE EFFECTS:
                                        (1271) ;    The A and X registers may be modified by this or future implementations
                                        (1272) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1273) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1274) ;    responsibility to preserve their values across calls to fastcall16
                                        (1275) ;    functions.
                                        (1276) ;
                                        (1277) USBUART_1_bGetDataBits:
                                        (1278) _USBUART_1_bGetDataBits:
                                        (1279) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1280) 	RAM_SETPAGE_CUR >USBUART_1_LineCoding
0EB0: 51 35    MOV   A,[0x35]           (1281) 	mov A, [USBUART_1_LineCoding+6];
                                        (1282) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EB2: 7F       RET                      (1283) 	ret
0EB3: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1284) .ENDSECTION
                                        (1285) 
                                        (1286) .SECTION
                                        (1287) ;-----------------------------------------------------------------------------
                                        (1288) ;  FUNCTION NAME: USBUART_1_bGetLineControl
                                        (1289) ;
                                        (1290) ;  DESCRIPTION:    Return Line Control Bitmap
                                        (1291) ;
                                        (1292) ;-----------------------------------------------------------------------------
                                        (1293) ;
                                        (1294) ;  ARGUMENTS:  None
                                        (1295) ;
                                        (1296) ;  RETURNS:	Line control bitmap
                                        (1297) ;				D7..D2 - reserved
                                        (1298) ;				D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                        (1299) ;				D0 - DTR (0 = not present, 1 = present);
                                        (1300) ;
                                        (1301) ;  SIDE EFFECTS:
                                        (1302) ;    The A and X registers may be modified by this or future implementations
                                        (1303) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1304) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1305) ;    responsibility to preserve their values across calls to fastcall16
                                        (1306) ;    functions.
                                        (1307) ;
                                        (1308) USBUART_1_bGetLineControlBitmap:
                                        (1309) _USBUART_1_bGetLineControlBitmap:
                                        (1310) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1311) 	RAM_SETPAGE_CUR >USBUART_1_LineControlBitmap
0EB6: 51 37    MOV   A,[0x37]           (1312) 	mov A, [USBUART_1_LineControlBitmap+1];
                                        (1313) 	RAM_EPILOGUE RAM_USE_CLASS_4
0EB8: 7F       RET                      (1314) 	ret
0EB9: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1315) .ENDSECTION
                                        (1316) 
                                        (1317) .SECTION
                                        (1318) ;-----------------------------------------------------------------------------
                                        (1319) ;  FUNCTION NAME: USBUART_1_SendStateNotify
                                        (1320) ;
                                        (1321) ;  DESCRIPTION:    Send notification about UART state
                                        (1322) ;
                                        (1323) ;-----------------------------------------------------------------------------
                                        (1324) ;
                                        (1325) ;  ARGUMENTS:
                                        (1326) ;     	A - State bitmap
                                        (1327) ;
                                        (1328) ;  RETURNS:
                                        (1329) ;     none
                                        (1330) ;
                                        (1331) ;  SIDE EFFECTS:
                                        (1332) ;    The A and X registers may be modified by this or future implementations
                                        (1333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1335) ;    responsibility to preserve their values across calls to fastcall16
                                        (1336) ;    functions.
                                        (1337) ;
                                        (1338) ;    Currently only the page pointer registers listed below are modified:
                                        (1339) ;          CUR_PP
                                        (1340) ;          IDX_PP
                                        (1341) ;
                                        (1342) ; -2 and -3 is the return address to caller
                                        (1343)  USBUART_1_SendStateNotify:
                                        (1344) _USBUART_1_SendStateNotify:
                                        (1345)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1346)     RAM_SETPAGE_CUR >USBUART_1_APITemp ; interrupt RAM 0 page
                                        (1347)     ;Should we toggle the data bit??
                                        (1348)     ;SET THE COUNT AND TOGGLE
0EBC: 08       PUSH  A                  (1349) 	push 	A
0EBD: 55 38 0A MOV   [0x38],0xA         (1350) 	mov     [USBUART_1_APITemp], 10       ; Save the count
                                        (1351) 
0EC0: 50 02    MOV   A,0x2              (1352)     mov     A, 02h                     ; EP1
0EC2: 34 1D    XOR   [0x1D],A           (1353)     xor     [USBUART_1_EPDataToggle], A
0EC4: 22 1D    AND   A,[0x1D]           (1354)     and     A, [USBUART_1_EPDataToggle]
0EC6: A0 03    JZ    0x0ECA             (1355)     jz      .toggle_done
0EC8: 50 80    MOV   A,0x80             (1356)     mov     A, USB_CNT_TOGGLE ; Set the data toggle
                                        (1357) 
                                        (1358) .toggle_done:
0ECA: 62 4F 0A MOV   REG[0x4F],0xA      (1359)     mov     reg[USBUART_1_EP1CNT0], 10  ; Write it into the register
0ECD: 60 4E    MOV   REG[0x4E],A        (1360) 	mov     reg[USBUART_1_EP1CNT1], A      ; Write it into the register
0ECF: 71 10    OR    F,0x10             
                                        (1361) 
                                        (1362) ; It's Time to move the data
                                        (1363) ; First we need to determine where, within the PMA, the EP Start Address is
                                        (1364)    M8C_SetBank1
0ED1: 5D 6C    MOV   A,REG[0x6C]        (1365)    mov   A, reg[TMP_DR0]                ; Get the address of ep from tmp register
0ED3: 49 F7 01 TST   REG[0xF7],0x1      (1366)    tst   reg[CPU_F], 0x01
0ED6: A0 09    JZ    0x0EE0             (1367)    jz    .DontTouchGIE5
0ED8: 70 FE    AND   F,0xFE             
                                        (1368)    M8C_DisableGInt
0EDA: 60 40    MOV   REG[0x40],A        (1369)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0EDC: 71 01    OR    F,0x1              
                                        (1370)    M8C_EnableGInt
0EDE: 80 03    JMP   0x0EE2             (1371)    jmp   .Continue5
                                        (1372) .DontTouchGIE5:
0EE0: 60 40    MOV   REG[0x40],A        (1373)    mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
0EE2: 70 EF    AND   F,0xEF             
                                        (1374) .Continue5:
                                        (1375)    M8C_SetBank0
                                        (1376) 
                                        (1377) ; Now we are y to start moving data
0EE4: 62 40 A1 MOV   REG[0x40],0xA1     (1378) 	mov		reg[PMA0_DR], A1h	; bmRequestType
0EE7: 62 40 20 MOV   REG[0x40],0x20     (1379) 	mov		reg[PMA0_DR], 20h	; Serial State
0EEA: 62 40 00 MOV   REG[0x40],0x0      (1380) 	mov		reg[PMA0_DR], 0		; wValue MSB
0EED: 62 40 00 MOV   REG[0x40],0x0      (1381) 	mov		reg[PMA0_DR], 0		; wValue LSB
0EF0: 62 40 00 MOV   REG[0x40],0x0      (1382) 	mov		reg[PMA0_DR], 0		; wIndex MSB
0EF3: 62 40 00 MOV   REG[0x40],0x0      (1383) 	mov		reg[PMA0_DR], 0		; wIndex (Interface)
0EF6: 62 40 00 MOV   REG[0x40],0x0      (1384) 	mov		reg[PMA0_DR], 0		;wLen
0EF9: 62 40 02 MOV   REG[0x40],0x2      (1385) 	mov		reg[PMA0_DR], 2		;wLen
0EFC: 62 40 00 MOV   REG[0x40],0x0      (1386) 	mov		reg[PMA0_DR], 0		;wLen
0EFF: 18       POP   A                  (1387) 	pop		A
0F00: 60 40    MOV   REG[0x40],A        (1388) 	mov		reg[PMA0_DR], A		;State bitmap
                                        (1389) 
0F02: 55 23 00 MOV   [0x23],0x0         (1390)     mov     [USBUART_1_EndpointAPIStatus+1], NO_EVENT_PENDING ; Set the state
0F05: 71 10    OR    F,0x10             
                                        (1391) 
                                        (1392)    M8C_SetBank1
0F07: 5D 6C    MOV   A,REG[0x6C]        (1393)    mov   A, reg[TMP_DR0]               ; Get the value of the PMA start Address
0F09: 49 F7 01 TST   REG[0xF7],0x1      (1394)    tst   reg[CPU_F], 0x01
0F0C: A0 09    JZ    0x0F16             (1395)    jz    .DontTouchGIE6
0F0E: 70 FE    AND   F,0xFE             
                                        (1396)    M8C_DisableGInt
0F10: 60 51    MOV   REG[0x51],A        (1397)    mov   reg[PMA0_RA+1], A             ; Load it into EP PMA so pre-fetch occurs
0F12: 71 01    OR    F,0x1              
                                        (1398)    M8C_EnableGInt
0F14: 80 03    JMP   0x0F18             (1399)    jmp   .Continue6
                                        (1400) .DontTouchGIE6:
0F16: 60 51    MOV   REG[0x51],A        (1401)    mov   reg[PMA0_RA+1], A             ; Load it into EP PMA so pre-fetch occurs
                                        (1402) .Continue6:
0F18: 62 C4 0D MOV   REG[0xC4],0xD      (1403)    mov   reg[USBUART_1_EP1MODE], USB_MODE_ACK_IN ; Enable the endpoint
0F1B: 70 EF    AND   F,0xEF             
                                        (1404)    M8C_SetBank0
                                        (1405) 
                                        (1406)    RAM_EPILOGUE RAM_USE_CLASS_4
0F1D: 7F       RET                      (1407)    ret
0F1E: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1408) .ENDSECTION
                                        (1409) 
                                        (1410) .SECTION
                                        (1411) ;-----------------------------------------------------------------------------
                                        (1412) ;  FUNCTION NAME: USBUART_1_SetPowerStatus
                                        (1413) ;
                                        (1414) ;  DESCRIPTION:    Set The Current Power status.
                                        (1415) ;
                                        (1416) ;-----------------------------------------------------------------------------
                                        (1417) ;
                                        (1418) ;  ARGUMENTS:      A contains the power status
                                        (1419) ;
                                        (1420) ;  RETURNS:        None
                                        (1421) ;
                                        (1422) ;  SIDE EFFECTS:
                                        (1423) ;    The A and X registers may be modified by this or future implementations
                                        (1424) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1425) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1426) ;    responsibility to perserve their values across calls to fastcall16
                                        (1427) ;    functions.
                                        (1428) ;
                                        (1429)  USBUART_1_SetPowerStatus:
                                        (1430) _USBUART_1_SetPowerStatus:
                                        (1431)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1432)     RAM_SETPAGE_CUR >USBUART_1_DeviceStatus
0F21: 39 00    CMP   A,0x0              (1433)     cmp     A, 0
0F23: A0 06    JZ    0x0F2A             (1434)     jz      .bus_powered
0F25: 2E 02 01 OR    [0x2],0x1          (1435)     or      [USBUART_1_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
0F28: 80 04    JMP   0x0F2D             (1436)     jmp     .done
                                        (1437) .bus_powered:
0F2A: 26 02 FE AND   [0x2],0xFE         (1438)     and     [USBUART_1_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
                                        (1439) .done:
                                        (1440)     RAM_EPILOGUE RAM_USE_CLASS_4
0F2D: 7F       RET                      (1441)     ret                                ; All done
FILE: lib\uart_1int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   UART_1INT.asm
                                        (0004) ;;  Version: 5.3, Updated on 2013/5/19 at 10:44:49
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) 
                                        (0014) include "UART_1.inc"
                                        (0015) include "memory.inc"
                                        (0016) include "m8c.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _UART_1_TX_ISR
                                        (0022) export  _UART_1_RX_ISR
                                        (0023) 
                                        (0024) IF (UART_1_RXBUF_ENABLE)
                                        (0025) export  UART_1_aRxBuffer
                                        (0026) export _UART_1_aRxBuffer
                                        (0027) export  UART_1_bRxCnt
                                        (0028) export _UART_1_bRxCnt
                                        (0029) export  UART_1_fStatus
                                        (0030) export _UART_1_fStatus
                                        (0031) ENDIF
                                        (0032) 
                                        (0033) 
                                        (0034) ;-----------------------------------------------
                                        (0035) ; Variable Allocation
                                        (0036) ;-----------------------------------------------
                                        (0037) AREA InterruptRAM (RAM, REL, CON)
                                        (0038) 
                                        (0039) IF (UART_1_RXBUF_ENABLE)
                                        (0040)  UART_1_fStatus:
                                        (0041) _UART_1_fStatus:      BLK  1
                                        (0042)  UART_1_bRxCnt:
                                        (0043) _UART_1_bRxCnt:       BLK  1
                                        (0044) AREA UART_1_RAM (RAM, REL, CON)
                                        (0045)  UART_1_aRxBuffer:
                                        (0046) _UART_1_aRxBuffer:    BLK UART_1_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) AREA InterruptRAM (RAM, REL, CON)
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _UART_1_TX_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;     UART TX interrupt handler for instance UART_1.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _UART_1_TX_ISR:
                                        (0090)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    ;PRESERVE_CPU_CONTEXT
                                        (0107)    ;lcall _My_C_Function
                                        (0108)    ;RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
0F2E: 7E       RETI                     (0115)    reti
                                        (0116) 
                                        (0117) 
                                        (0118) ;-----------------------------------------------------------------------------
                                        (0119) ;  FUNCTION NAME: _UART_1_RX_ISR
                                        (0120) ;
                                        (0121) ;  DESCRIPTION:
                                        (0122) ;     UART RX interrupt handler for instance UART_1.
                                        (0123) ;     This ISR handles the background processing of received characters if
                                        (0124) ;     the buffer is enabled.
                                        (0125) ;
                                        (0126) ;
                                        (0127) ;  The following assumes that the RX buffer feature has been enabled.
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;     There are 3 posible errors that may occur with the serial port.
                                        (0131) ;      1) Parity Error
                                        (0132) ;      2) Framing Error
                                        (0133) ;      3) OverRun Error
                                        (0134) ;
                                        (0135) ;  This user module check for parity and framing error.  If either of these
                                        (0136) ;  two errors are detected, the data is read and ignored.  When an overRun
                                        (0137) ;  error occurs, the last byte was lost, but the current byte is valid.  For
                                        (0138) ;  this reason this error is ignored at this time.  Code could be added to
                                        (0139) ;  this ISR to set a flag if an error condition occurs.
                                        (0140) ;
                                        (0141) ;  THEORY of OPERATION:
                                        (0142) ;     When using the RX buffer feature, the ISR collects received characters
                                        (0143) ;     in a buffer until the user defined command terminator is detected.  After
                                        (0144) ;     the command terminator is detected, the command bit is set and all other
                                        (0145) ;     characters will be ignored until the command bit is reset.  Up to
                                        (0146) ;     buffer_size - 1 characters will be collected waiting for a command
                                        (0147) ;     terminator.  After that, the characters will be discarded, although
                                        (0148) ;     a command determinator will still cause the command bit to be set.
                                        (0149) ;
                                        (0150) ;-----------------------------------------------------------------------------
                                        (0151) _UART_1_RX_ISR:
                                        (0152) 
                                        (0153)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0154)    ;---------------------------------------------------
                                        (0155)    ; Insert your custom assembly code below this banner
                                        (0156)    ;---------------------------------------------------
                                        (0157)    ;   NOTE: interrupt service routines must preserve
                                        (0158)    ;   the values of the A and X CPU registers.
                                        (0159)    
                                        (0160)    ;---------------------------------------------------
                                        (0161)    ; Insert your custom assembly code above this banner
                                        (0162)    ;---------------------------------------------------
                                        (0163)    
                                        (0164)    ;---------------------------------------------------
                                        (0165)    ; Insert a lcall to a C function below this banner
                                        (0166)    ; and un-comment the lines between these banners
                                        (0167)    ;---------------------------------------------------
                                        (0168)    
                                        (0169)    ;PRESERVE_CPU_CONTEXT
                                        (0170)    ;lcall _My_C_Function
                                        (0171)    ;RESTORE_CPU_CONTEXT
                                        (0172)    
                                        (0173)    ;---------------------------------------------------
                                        (0174)    ; Insert a lcall to a C function above this banner
                                        (0175)    ; and un-comment the lines between these banners
                                        (0176)    ;---------------------------------------------------
                                        (0177)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0178) 
                                        (0179) IF (UART_1_RXBUF_ENABLE)
0F2F: 08       PUSH  A                  (0180)    push A
0F30: 10       PUSH  X                  (0181)    push X
0F31: 5D D3    MOV   A,REG[0xD3]        
0F33: 08       PUSH  A                  
                                        (0182)    
                                        (0183)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0184)       REG_PRESERVE IDX_PP
                                        (0185)    ENDIF
                                        (0186)    
0F34: 58 3B    MOV   X,[0x3B]           (0187)    mov  X,[UART_1_bRxCnt]                                  ; Load X with byte counter
0F36: 5D 2F    MOV   A,REG[0x2F]        (0188)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Read the control register
0F38: 08       PUSH  A                  (0189)    push A                                                  ; Store copy for later test
                                        (0190)                                                            ; IF real RX interrupt
0F39: 21 08    AND   A,0x8              (0191)    and  A,UART_1_RX_REG_FULL                               ; Did really really get an IRQ
0F3B: B0 04    JNZ   0x0F40             (0192)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
0F3D: 18       POP   A                  (0193)    pop  A                                                  ; Restore stack
0F3E: 80 5E    JMP   0x0F9D             (0194)    jmp  .RESTORE_IDX_PP
                                        (0195) 
                                        (0196) .UARTRX_ReadRx:
0F40: 18       POP   A                  (0197)    pop  A                                                  ; Restore status flags
                                        (0198)                                                            ; IF there is no error, get data
                                        (0199)                                                            ; Check for parity or framing error
0F41: 21 E0    AND   A,0xE0             (0200)    and  A,UART_1_RX_ERROR
0F43: A0 12    JZ    0x0F56             (0201)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0202) 
0F45: 2C 3A    OR    [0x3A],A           (0203)    or   [UART_1_fStatus],A                                 ; Set error flags (parity,framing,overrun) bits
0F47: 49 2E 00 TST   REG[0x2E],0x0      (0204)    tst  REG[UART_1_RX_BUFFER_REG], 0x00                    ; Read the data buffer to clear it.
0F4A: 21 20    AND   A,0x20             (0205)    and  A,UART_1_RX_FRAMING_ERROR                          ; Check for framing error special case
0F4C: A0 50    JZ    0x0F9D             (0206)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0207) 
                                        (0208)                                                            ; Disable and re-enable RX to reset after
                                        (0209)                                                            ; framing error.
0F4E: 41 2F FE AND   REG[0x2F],0xFE     (0210)    and   REG[UART_1_RX_CONTROL_REG], ~UART_1_RX_ENABLE     ; Disable RX
0F51: 43 2F 01 OR    REG[0x2F],0x1      (0211)    or    REG[UART_1_RX_CONTROL_REG],  UART_1_RX_ENABLE     ; Enable RX
0F54: 80 48    JMP   0x0F9D             (0212)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0213) 
                                        (0214) 
                                        (0215) .UARTRX_NO_ERROR:
0F56: 5D 2E    MOV   A,REG[0x2E]        (0216)    mov  A,REG[UART_1_RX_BUFFER_REG ]                       ; Read the data buffer
                                        (0217) 
                                        (0218)                                                            ; IF buffer not full
0F58: 47 3A 01 TST   [0x3A],0x1         (0219)    tst  [UART_1_fStatus],UART_1_RX_BUF_CMDTERM             ; Check for buffer full
0F5B: B0 41    JNZ   0x0F9D             (0220)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0221) 
0F5D: 39 0D    CMP   A,0xD              (0222)    cmp  A,UART_1_CMD_TERM                                  ; Check for End of command
0F5F: B0 14    JNZ   0x0F74             (0223)    jnz  .UARTRX_CHK_BACKSPACE
0F61: 2E 3A 01 OR    [0x3A],0x1         (0224)    or   [UART_1_fStatus],UART_1_RX_BUF_CMDTERM             ; Set command ready bit
0F64: 62 D3 00 MOV   REG[0xD3],0x0      
0F67: 70 3F    AND   F,0x3F             
0F69: 71 80    OR    F,0x80             
                                        (0225) 
                                        (0226) 
                                        (0227) 
                                        (0228)    RAM_SETPAGE_IDX >UART_1_aRxBuffer
                                        (0229)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0F6B: 56 A5 00 MOV   [X-91],0x0         (0230)    mov  [X + UART_1_aRxBuffer],00h                         ; Zero out last data
0F6E: 70 3F    AND   F,0x3F             
0F70: 71 00    OR    F,0x0              
                                        (0231)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0F72: 80 2A    JMP   0x0F9D             (0232)    jmp  .RESTORE_IDX_PP
                                        (0233) 
                                        (0234) .UARTRX_CHK_BACKSPACE:                                     ; 
                                        (0235) IF(UART_1_BACKSPACE_ENABLE)                                ; Enable if backspace/delete mode
                                        (0236)    cmp  A,UART_1_BACKSPACE_ENABLE                          ; Check for backspace character
                                        (0237)    jnz  .UARTRX_IGNORE                                     ; If not, skip the backspace stuff
                                        (0238)    cmp  [UART_1_bRxCnt],00h                                ; Check if buffer empty
                                        (0239)    jz   .RESTORE_IDX_PP                                    ; 
                                        (0240)    dec  [UART_1_bRxCnt]                                    ; Decrement buffer count by one.
                                        (0241)    jmp  .RESTORE_IDX_PP
                                        (0242) ENDIF                                                      ; 
                                        (0243) 
                                        (0244) .UARTRX_IGNORE:
                                        (0245) IF(UART_1_RX_IGNORE_BELOW)                                 ; Ignore charaters below this value
0F74: 39 20    CMP   A,0x20             (0246)    cmp  A,UART_1_RX_IGNORE_BELOW                           ; If ignore char is set to 0x00, do not
0F76: C0 26    JC    0x0F9D             (0247)    jc   .RESTORE_IDX_PP                                    ; ignore any characters.
0F78: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (0248) ENDIF
                                        (0249) 
                                        (0250) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0251) 	
                                        (0252)    RAM_SETPAGE_IDX >UART_1_aRxBuffer                       ;   using idexed address mode
0F7B: 3C 3B 0F CMP   [0x3B],0xF         (0253)    cmp  [UART_1_bRxCnt],(UART_1_RX_BUFFER_SIZE - 1)
0F7E: C0 11    JC    0x0F90             (0254)    jc   .UARTRX_ISR_GETDATA
0F80: 70 3F    AND   F,0x3F             
0F82: 71 80    OR    F,0x80             
                                        (0255)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0F84: 56 A5 00 MOV   [X-91],0x0         (0256)    mov  [X + UART_1_aRxBuffer],00h                         ; Zero out last data in the buffer
0F87: 70 3F    AND   F,0x3F             
0F89: 71 00    OR    F,0x0              
                                        (0257)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0F8B: 2E 3A 10 OR    [0x3A],0x10        (0258)    or   [UART_1_fStatus],UART_1_RX_BUF_OVERRUN             ; Set error flags (parity,framing,overrun) bits
0F8E: 80 0E    JMP   0x0F9D             (0259)    jmp  .RESTORE_IDX_PP
0F90: 70 3F    AND   F,0x3F             
0F92: 71 80    OR    F,0x80             
                                        (0260) 
                                        (0261) .UARTRX_ISR_GETDATA:                                       ; IF input data == "CR", then end of command
                                        (0262)                                                            ; X is already loaded with pointer
                                        (0263)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0F94: 54 A5    MOV   [X-91],A           (0264)    mov  [X+UART_1_aRxBuffer],A                             ; store data in array
0F96: 70 3F    AND   F,0x3F             
0F98: 71 00    OR    F,0x0              
                                        (0265)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0F9A: 75       INC   X                  (0266)    inc  X                                                  ; Inc the pointer
0F9B: 5A 3B    MOV   [0x3B],X           (0267)    mov  [UART_1_bRxCnt],X                                  ; Restore the pointer
0F9D: 18       POP   A                  
0F9E: 60 D3    MOV   REG[0xD3],A        
                                        (0268)                                                            ; ENDIF max string size
                                        (0269) .RESTORE_IDX_PP:
                                        (0270)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0271)       REG_RESTORE IDX_PP
                                        (0272)    ENDIF
                                        (0273) 
                                        (0274) .END_UARTRX_ISR:
0FA0: 20       POP   X                  (0275)    pop  X
0FA1: 18       POP   A                  (0276)    pop  A
                                        (0277) 
                                        (0278) ENDIF
                                        (0279) 
                                        (0280) UART_1_RX_ISR_END:
0FA2: 7E       RETI                     (0281)    reti
                                        (0282) 
                                        (0283) ; end of file UART_1INT.asm
                                        (0284) 
FILE: lib\uart_1.asm                    (0001) ;;*****************************************************************************
0FA3: 43 E1 04 OR    REG[0xE1],0x4      (0002) ;;*****************************************************************************
0FA6: 43 E1 08 OR    REG[0xE1],0x8      
                                        (0003) ;;  Filename:   UART_1.asm
                                        (0004) ;;  Version: 5.3, Updated on 2013/5/19 at 10:44:49
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                        (0008) ;;                22/24/25/26/27xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "UART_1.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name refence for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  UART_1_SetTxIntMode
                                        (0041) export _UART_1_SetTxIntMode
                                        (0042) export  UART_1_EnableInt
                                        (0043) export _UART_1_EnableInt
                                        (0044) export  UART_1_DisableInt
                                        (0045) export _UART_1_DisableInt
                                        (0046) 
                                        (0047) export  UART_1_Start
                                        (0048) export _UART_1_Start
                                        (0049) export  UART_1_Stop
                                        (0050) export _UART_1_Stop
                                        (0051) export  UART_1_SendData
                                        (0052) export _UART_1_SendData
                                        (0053) export  UART_1_bReadTxStatus
                                        (0054) export _UART_1_bReadTxStatus
                                        (0055) export  UART_1_bReadRxData
                                        (0056) export _UART_1_bReadRxData
                                        (0057) export  UART_1_bReadRxStatus
                                        (0058) export _UART_1_bReadRxStatus
                                        (0059) 
                                        (0060) export  UART_1_IntCntl
                                        (0061) export _UART_1_IntCntl
                                        (0062) 
                                        (0063) export  UART_1_TxIntMode
                                        (0064) export _UART_1_TxIntMode
                                        (0065) 
                                        (0066) export  UART_1_PutSHexByte
                                        (0067) export _UART_1_PutSHexByte
                                        (0068) export  UART_1_PutSHexInt
                                        (0069) export _UART_1_PutSHexInt
                                        (0070) 
                                        (0071) export  UART_1_CPutString
                                        (0072) export _UART_1_CPutString
                                        (0073) export  UART_1_PutString
                                        (0074) export _UART_1_PutString
                                        (0075) export  UART_1_PutChar
                                        (0076) export _UART_1_PutChar
                                        (0077) export  UART_1_Write
                                        (0078) export _UART_1_Write
                                        (0079) export  UART_1_CWrite
                                        (0080) export _UART_1_CWrite
                                        (0081) 
                                        (0082) export  UART_1_cGetChar
                                        (0083) export _UART_1_cGetChar
                                        (0084) export  UART_1_cReadChar
                                        (0085) export _UART_1_cReadChar
                                        (0086) export  UART_1_iReadChar
                                        (0087) export _UART_1_iReadChar
                                        (0088) export  UART_1_PutCRLF
                                        (0089) export _UART_1_PutCRLF
                                        (0090) 
                                        (0091) IF (UART_1_RXBUF_ENABLE)
                                        (0092) export  UART_1_CmdReset
                                        (0093) export _UART_1_CmdReset
                                        (0094) export  UART_1_bCmdCheck
                                        (0095) export _UART_1_bCmdCheck
                                        (0096) export  UART_1_bCmdLength
                                        (0097) export _UART_1_bCmdLength
                                        (0098) export  UART_1_bErrCheck
                                        (0099) export _UART_1_bErrCheck
                                        (0100) 
                                        (0101) export  UART_1_szGetParam
                                        (0102) export _UART_1_szGetParam
                                        (0103) export  UART_1_szGetRestOfParams
                                        (0104) export _UART_1_szGetRestOfParams
                                        (0105) ENDIF
                                        (0106) 
                                        (0107) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0108) ; WARNING WARNING WARNING
                                        (0109) ; The following exports are for backwards compatibility only and should
                                        (0110) ; not be used for new designs. They may be eliminated in a future release.
                                        (0111) ; Their status is "NO FURTHER MAINTENANCE". 
                                        (0112) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0113) export  bUART_1_ReadTxStatus
                                        (0114) export _bUART_1_ReadTxStatus
                                        (0115) export  bUART_1_ReadRxData
                                        (0116) export _bUART_1_ReadRxData
                                        (0117) export  bUART_1_ReadRxStatus
                                        (0118) export _bUART_1_ReadRxStatus
                                        (0119) 	
                                        (0120) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0121) ;             END WARNING
                                        (0122) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0123) 
                                        (0124) ;-----------------------------------------------
                                        (0125) ; Variable Allocation
                                        (0126) ;-----------------------------------------------
                                        (0127) IF (UART_1_RXBUF_ENABLE)
                                        (0128)     
                                        (0129) area UART_1_RAM (RAM, REL, CON)
                                        (0130)     
                                        (0131)  ptrParam:   BLK  1
                                        (0132) 
                                        (0133) ENDIF
                                        (0134) 
                                        (0135) area text (ROM,REL)
                                        (0136) 
                                        (0137) ;-----------------------------------------------
                                        (0138) ;  EQUATES
                                        (0139) ;-----------------------------------------------
                                        (0140) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                        (0141) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                        (0142) 
                                        (0143) area UserModules (ROM, REL, CON)
                                        (0144) 
                                        (0145) ;=============================================================================
                                        (0146) ;=============================================================================
                                        (0147) ;
                                        (0148) ;     Low-Level Commands
                                        (0149) ;
                                        (0150) ;=============================================================================
                                        (0151) ;=============================================================================
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: UART_1_EnableInt
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                        (0159) ;     bit associated with this User Module. Remember to call the global
                                        (0160) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0161) ;-----------------------------------------------------------------------------
                                        (0162) ;
                                        (0163) ;  ARGUMENTS:
                                        (0164) ;     none.
                                        (0165) ;
                                        (0166) ;  RETURNS:
                                        (0167) ;     none.
                                        (0168) ;
                                        (0169) ;  SIDE EFFECTS:
                                        (0170) ;    The A and X registers may be modified by this or future implementations
                                        (0171) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0172) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0173) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0174) ;    functions.
                                        (0175) ;
                                        (0176)  UART_1_EnableInt:
                                        (0177) _UART_1_EnableInt:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0179)    M8C_EnableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
                                        (0180)    M8C_EnableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
                                        (0181)    RAM_EPILOGUE RAM_USE_CLASS_1
0FA9: 7F       RET                      (0182)    ret
0FAA: 41 E1 FB AND   REG[0xE1],0xFB     
0FAD: 41 E1 F7 AND   REG[0xE1],0xF7     
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185)     
                                        (0186) .SECTION
                                        (0187) ;-----------------------------------------------------------------------------
                                        (0188) ;  FUNCTION NAME: UART_1_DisableInt
                                        (0189) ;
                                        (0190) ;  DESCRIPTION:
                                        (0191) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                        (0192) ;     associated with this User Module.
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;     none.
                                        (0197) ;
                                        (0198) ;  RETURNS:
                                        (0199) ;     none.
                                        (0200) ;
                                        (0201) ;  SIDE EFFECTS:
                                        (0202) ;    The A and X registers may be modified by this or future implementations
                                        (0203) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0204) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0205) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0206) ;    functions.
                                        (0207) ;
                                        (0208)  UART_1_DisableInt:
                                        (0209) _UART_1_DisableInt:
                                        (0210)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0211)    M8C_DisableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
                                        (0212)    M8C_DisableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
                                        (0213)    RAM_EPILOGUE RAM_USE_CLASS_1
0FB0: 7F       RET                      (0214)    ret
0FB1: 71 10    OR    F,0x10             
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) 
                                        (0218) .SECTION
                                        (0219) ;-----------------------------------------------------------------------------
                                        (0220) ;  FUNCTION NAME: UART_1_SetTxIntMode(BYTE bTxIntMode)
                                        (0221) ;
                                        (0222) ;  DESCRIPTION:
                                        (0223) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;
                                        (0226) ;  ARGUMENTS:
                                        (0227) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                        (0228) ;        Passed in the A register
                                        (0229) ;
                                        (0230) ;  RETURNS:
                                        (0231) ;     none.
                                        (0232) ;
                                        (0233) ;  SIDE EFFECTS:
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0241) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                        (0242) ;     on TX register empty or TX transmit complete
                                        (0243) ;
                                        (0244)  UART_1_SetTxIntMode:
                                        (0245) _UART_1_SetTxIntMode:
                                        (0246)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0247)    M8C_SetBank1
0FB3: 21 01    AND   A,0x1              (0248)    and   A, UART_1_INT_MODE_TX_COMPLETE
0FB5: A0 07    JZ    0x0FBD             (0249)    jz    .SetModeRegEmpty
0FB7: 43 28 10 OR    REG[0x28],0x10     (0250)    or    REG[UART_1_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
0FBA: 70 EF    AND   F,0xEF             
                                        (0251)    M8C_SetBank0
                                        (0252)    RAM_EPILOGUE RAM_USE_CLASS_1
0FBC: 7F       RET                      (0253)    ret
                                        (0254) 
                                        (0255) .SetModeRegEmpty:
0FBD: 41 28 EF AND   REG[0x28],0xEF     (0256)    and   REG[UART_1_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
0FC0: 70 EF    AND   F,0xEF             
                                        (0257)    M8C_SetBank0
                                        (0258)    RAM_EPILOGUE RAM_USE_CLASS_1
0FC2: 7F       RET                      (0259)    ret
                                        (0260) .ENDSECTION
                                        (0261) 
                                        (0262) 
                                        (0263) .SECTION
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;  FUNCTION NAME: UART_1_Start(BYTE bParity)
                                        (0266) ;
                                        (0267) ;  DESCRIPTION:
                                        (0268) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0269) ;-----------------------------------------------------------------------------
                                        (0270) ;
                                        (0271) ;  ARGUMENTS:
                                        (0272) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                        (0273) ;        Passed in the A register.
                                        (0274) ;
                                        (0275) ;  RETURNS:
                                        (0276) ;     none.
                                        (0277) ;
                                        (0278) ;  SIDE EFFECTS:
                                        (0279) ;    The A and X registers may be modified by this or future implementations
                                        (0280) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0281) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0282) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0283) ;    functions.
                                        (0284) ;
                                        (0285)  UART_1_Start:
                                        (0286) _UART_1_Start:
                                        (0287)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0288)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                        (0289) 
0FC3: 29 01    OR    A,0x1              (0290)    or    A, bfCONTROL_REG_START_BIT
0FC5: 60 2B    MOV   REG[0x2B],A        (0291)    mov   REG[UART_1_TX_CONTROL_REG], A
0FC7: 60 2F    MOV   REG[0x2F],A        (0292)    mov   REG[UART_1_RX_CONTROL_REG], A
                                        (0293) IF ( UART_1_RXBUF_ENABLE )
0FC9: 91 2A    CALL  _UART_1_CmdReset   (0294)    call  _UART_1_CmdReset
                                        (0295) ENDIF
                                        (0296)    RAM_EPILOGUE RAM_USE_CLASS_1
0FCB: 7F       RET                      (0297)    ret
                                        (0298) .ENDSECTION
                                        (0299) 
                                        (0300) 
                                        (0301) .SECTION
                                        (0302) ;-----------------------------------------------------------------------------
                                        (0303) ;  FUNCTION NAME: UART_1_Stop
                                        (0304) ;
                                        (0305) ;  DESCRIPTION:
                                        (0306) ;     Disables UART operation.
                                        (0307) ;-----------------------------------------------------------------------------
                                        (0308) ;
                                        (0309) ;  ARGUMENTS:
                                        (0310) ;     none.
                                        (0311) ;
                                        (0312) ;  RETURNS:
                                        (0313) ;     none.
                                        (0314) ;
                                        (0315) ;  SIDE EFFECTS:
                                        (0316) ;    The A and X registers may be modified by this or future implementations
                                        (0317) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0318) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0319) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0320) ;    functions.
                                        (0321) ;
                                        (0322)  UART_1_Stop:
                                        (0323) _UART_1_Stop:
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_1
0FCC: 41 2B FE AND   REG[0x2B],0xFE     (0325)    and   REG[UART_1_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
0FCF: 41 2F FE AND   REG[0x2F],0xFE     (0326)    and   REG[UART_1_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0327)    RAM_EPILOGUE RAM_USE_CLASS_1
0FD2: 7F       RET                      (0328)    ret
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) 
                                        (0332) .SECTION
                                        (0333) ;-----------------------------------------------------------------------------
                                        (0334) ;  FUNCTION NAME: UART_1_SendData
                                        (0335) ;
                                        (0336) ;  DESCRIPTION:
                                        (0337) ;     Initiates a transmission of data.
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) ;
                                        (0340) ;  ARGUMENTS:
                                        (0341) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                        (0342) ;
                                        (0343) ;  RETURNS:
                                        (0344) ;     none.
                                        (0345) ;
                                        (0346) ;  SIDE EFFECTS:
                                        (0347) ;    The A and X registers may be modified by this or future implementations
                                        (0348) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0349) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0350) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0351) ;    functions.
                                        (0352) ;
                                        (0353)  UART_1_SendData:
                                        (0354) _UART_1_SendData:
                                        (0355)    RAM_PROLOGUE RAM_USE_CLASS_1
0FD3: 60 29    MOV   REG[0x29],A        (0356)    mov REG[UART_1_TX_BUFFER_REG], A
                                        (0357)    RAM_EPILOGUE RAM_USE_CLASS_1
0FD5: 7F       RET                      (0358)    ret
                                        (0359) .ENDSECTION
                                        (0360) 
                                        (0361) 
                                        (0362) .SECTION
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  FUNCTION NAME: UART_1_bReadTxStatus
                                        (0365) ;
                                        (0366) ;  DESCRIPTION:
                                        (0367) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0368) ;-----------------------------------------------------------------------------
                                        (0369) ;
                                        (0370) ;  ARGUMENTS:
                                        (0371) ;     none.
                                        (0372) ;
                                        (0373) ;  RETURNS:
                                        (0374) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                        (0375) ;           status bits (returned in A)
                                        (0376) ;
                                        (0377) ;  SIDE EFFECTS:
                                        (0378) ;    The A and X registers may be modified by this or future implementations
                                        (0379) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0380) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0381) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0382) ;    functions.
                                        (0383) ;
                                        (0384)  UART_1_bReadTxStatus:
                                        (0385) _UART_1_bReadTxStatus:
                                        (0386)  bUART_1_ReadTxStatus:                           ; For backwards compatibility only
                                        (0387) _bUART_1_ReadTxStatus:                           ; For backwards compatibility only
                                        (0388)    RAM_PROLOGUE RAM_USE_CLASS_1
0FD6: 5D 2B    MOV   A,REG[0x2B]        (0389)    mov A,  REG[UART_1_TX_CONTROL_REG]
                                        (0390)    RAM_EPILOGUE RAM_USE_CLASS_1
0FD8: 7F       RET                      (0391)    ret
                                        (0392) .ENDSECTION
                                        (0393) 
                                        (0394) 
                                        (0395) .SECTION
                                        (0396) ;-----------------------------------------------------------------------------
                                        (0397) ;  FUNCTION NAME: UART_1_bReadRxData
                                        (0398) ;
                                        (0399) ;  DESCRIPTION:
                                        (0400) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0401) ;     sure data is valid.
                                        (0402) ;-----------------------------------------------------------------------------
                                        (0403) ;
                                        (0404) ;  ARGUMENTS:
                                        (0405) ;     none.
                                        (0406) ;
                                        (0407) ;  RETURNS:
                                        (0408) ;     bRxData - returned in A.
                                        (0409) ;
                                        (0410) ;  SIDE EFFECTS:
                                        (0411) ;    The A and X registers may be modified by this or future implementations
                                        (0412) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0413) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0414) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0415) ;    functions.
                                        (0416) ;
                                        (0417)  UART_1_bReadRxData:
                                        (0418) _UART_1_bReadRxData:
                                        (0419)  bUART_1_ReadRxData:                             ; For backwards compatibility only
                                        (0420) _bUART_1_ReadRxData:                             ; For backwards compatibility only
                                        (0421)    RAM_PROLOGUE RAM_USE_CLASS_1
0FD9: 5D 2E    MOV   A,REG[0x2E]        (0422)    mov A, REG[UART_1_RX_BUFFER_REG]
                                        (0423)    RAM_EPILOGUE RAM_USE_CLASS_1
0FDB: 7F       RET                      (0424)    ret
                                        (0425) .ENDSECTION
                                        (0426) 
                                        (0427) 
                                        (0428) .SECTION
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: UART_1_bReadRxStatus
                                        (0431) ;
                                        (0432) ;  DESCRIPTION:
                                        (0433) ;     Reads the RX Status bits in the Control/Status register.
                                        (0434) ;-----------------------------------------------------------------------------
                                        (0435) ;
                                        (0436) ;  ARGUMENTS:
                                        (0437) ;     none.
                                        (0438) ;
                                        (0439) ;  RETURNS:
                                        (0440) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                        (0441) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0442) ;           returned in A.
                                        (0443) ;
                                        (0444) ;  SIDE EFFECTS:
                                        (0445) ;    The A and X registers may be modified by this or future implementations
                                        (0446) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0447) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0448) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0449) ;    functions.
                                        (0450) ;
                                        (0451)  UART_1_bReadRxStatus:
                                        (0452) _UART_1_bReadRxStatus:
                                        (0453)  bUART_1_ReadRxStatus:                           ; For backwards compatibility only
                                        (0454) _bUART_1_ReadRxStatus:                           ; For backwards compatibility only
                                        (0455)    RAM_PROLOGUE RAM_USE_CLASS_1
0FDC: 5D 2F    MOV   A,REG[0x2F]        (0456)    mov A,  REG[UART_1_RX_CONTROL_REG]
                                        (0457)    RAM_EPILOGUE RAM_USE_CLASS_1
0FDE: 7F       RET                      (0458)    ret
                                        (0459) .ENDSECTION
                                        (0460) 
                                        (0461) 
                                        (0462) .SECTION
                                        (0463) ;-----------------------------------------------------------------------------
                                        (0464) ;  FUNCTION NAME: UART_1_TxIntMode
                                        (0465) ;
                                        (0466) ;  DESCRIPTION:
                                        (0467) ;     This function is used to change the TX Interrupt mode.
                                        (0468) ;-----------------------------------------------------------------------------
                                        (0469) ;
                                        (0470) ;  ARGUMENTS:
                                        (0471) ;     A => Tx Interrupt mode
                                        (0472) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                        (0473) ;             1 => Interrupt on TX Complete
                                        (0474) ;
                                        (0475) ;  RETURNS:
                                        (0476) ;     none.
                                        (0477) ;
                                        (0478) ;  SIDE EFFECTS:
                                        (0479) ;    The A and X registers may be modified by this or future implementations
                                        (0480) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0481) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0482) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0483) ;    functions.
                                        (0484) ;
                                        (0485)  UART_1_TxIntMode:
                                        (0486) _UART_1_TxIntMode:
                                        (0487)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0488) 
0FDF: 21 01    AND   A,0x1              (0489)    and  A,UART_1_INT_MODE_TX_COMPLETE
0FE1: 71 10    OR    F,0x10             
                                        (0490)    M8C_SetBank1
0FE3: 39 01    CMP   A,0x1              (0491)    cmp  A,UART_1_INT_MODE_TX_COMPLETE
0FE5: A0 06    JZ    0x0FEC             (0492)    jz   .SetTxCmpMode
                                        (0493) 
0FE7: 41 28 EF AND   REG[0x28],0xEF     (0494)    and  reg[UART_1_TX_FUNC_REG],0xEF             ; Set Interrupt on Tx_Reg_Empty
0FEA: 80 04    JMP   0x0FEF             (0495)    jmp  .TxIntMode_End
                                        (0496) 
                                        (0497) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
0FEC: 43 28 10 OR    REG[0x28],0x10     (0498)    or   reg[UART_1_TX_FUNC_REG],0x10
0FEF: 70 EF    AND   F,0xEF             
                                        (0499) 
                                        (0500) .TxIntMode_End:
                                        (0501)    M8C_SetBank0
                                        (0502)    RAM_EPILOGUE RAM_USE_CLASS_1
0FF1: 7F       RET                      (0503)    ret
                                        (0504) .ENDSECTION
                                        (0505) 
                                        (0506)     
                                        (0507) .SECTION
                                        (0508) ;-----------------------------------------------------------------------------
                                        (0509) ;  FUNCTION NAME: UART_1_IntCntl
                                        (0510) ;
                                        (0511) ;  DESCRIPTION:
                                        (0512) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                        (0513) ;-----------------------------------------------------------------------------
                                        (0514) ;
                                        (0515) ;  ARGUMENTS:
                                        (0516) ;     A => Interrupt mask
                                        (0517) ;
                                        (0518) ;  RETURNS:
                                        (0519) ;     none.
                                        (0520) ;
                                        (0521) ;  SIDE EFFECTS:
                                        (0522) ;    The A and X registers may be modified by this or future implementations
                                        (0523) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0524) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0525) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0526) ;    functions.
                                        (0527) ;
                                        (0528) ;  THEORY of OPERATION or PROCEDURE:
                                        (0529) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                        (0530) ;     and RX block.
                                        (0531) ;
                                        (0532)  UART_1_IntCntl:
                                        (0533) _UART_1_IntCntl:
                                        (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0535) 
0FF2: 08       PUSH  A                  (0536)    push A
0FF3: 21 01    AND   A,0x1              (0537)    and  A,UART_1_ENABLE_RX_INT
0FF5: A0 06    JZ    0x0FFC             (0538)    jz   .DisRxInt
0FF7: 43 E1 08 OR    REG[0xE1],0x8      
                                        (0539)      ; Enable Rx Interrupt
                                        (0540)    M8C_EnableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
0FFA: 80 04    JMP   0x0FFF             (0541)    jmp  .CheckTxInt
0FFC: 41 E1 F7 AND   REG[0xE1],0xF7     
                                        (0542) .DisRxInt:
                                        (0543)      ; Disable Rx Interrupt
                                        (0544)    M8C_DisableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
                                        (0545) 
                                        (0546) .CheckTxInt:
0FFF: 18       POP   A                  (0547)    pop  A
1000: 21 02    AND   A,0x2              (0548)    and  A,UART_1_ENABLE_TX_INT
1002: A0 06    JZ    0x1009             (0549)    jz   .DisTxInt
1004: 43 E1 04 OR    REG[0xE1],0x4      
                                        (0550)      ; Enable Tx Interrupt
                                        (0551)    M8C_EnableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
1007: 80 04    JMP   0x100C             (0552)    jmp  .End_IntCntl
1009: 41 E1 FB AND   REG[0xE1],0xFB     
                                        (0553) .DisTxInt:
                                        (0554)      ; Disable Tx Interrupt
                                        (0555)    M8C_DisableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
                                        (0556) 
                                        (0557) .End_IntCntl:
                                        (0558)    RAM_EPILOGUE RAM_USE_CLASS_1
100C: 7F       RET                      (0559)    ret
                                        (0560) .ENDSECTION
                                        (0561) 
                                        (0562) 
                                        (0563) ;=============================================================================
                                        (0564) ;=============================================================================
                                        (0565) ;
                                        (0566) ;     High-Level Commands
                                        (0567) ;
                                        (0568) ;=============================================================================
                                        (0569) ;=============================================================================
                                        (0570) 
                                        (0571) 
                                        (0572) ;-----------------------------------------------------------------------------
                                        (0573) ;  FUNCTION NAME: UART_1_PutSHexByte
                                        (0574) ;
                                        (0575) ;  DESCRIPTION:
                                        (0576) ;     Print a byte in Hex (two characters) to the UART Tx
                                        (0577) ;-----------------------------------------------------------------------------
                                        (0578) ;
                                        (0579) ;  ARGUMENTS:
                                        (0580) ;     A  => (BYTE) Data/char to be printed
                                        (0581) ;
                                        (0582) ;  RETURNS:
                                        (0583) ;     none.
                                        (0584) ;
                                        (0585) ;  SIDE EFFECTS:
                                        (0586) ;    The A and X registers may be modified by this or future implementations
                                        (0587) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0588) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0589) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0590) ;    functions.
                                        (0591) ;
                                        (0592) .LITERAL
                                        (0593) UART_1_HEX_STR:
                                        (0594)      DS    "0123456789ABCDEF"
                                        (0595) .ENDLITERAL
                                        (0596) 
                                        (0597) .SECTION
                                        (0598)  UART_1_PutSHexByte:
                                        (0599) _UART_1_PutSHexByte:
                                        (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
101D: 08       PUSH  A                  (0601)    push  A                             ; Save lower nibble
101E: 67       ASR   A                  (0602)    asr   A                             ; Shift high nibble to right
101F: 67       ASR   A                  (0603)    asr   A
1020: 67       ASR   A                  (0604)    asr   A
1021: 67       ASR   A                  (0605)    asr   A
1022: 21 0F    AND   A,0xF              (0606)    and   A,0Fh                         ; Mask off nibble
1024: FF E7    INDEX 0x100D             (0607)    index UART_1_HEX_STR                ; Get Hex value
1026: 90 0F    CALL  _UART_1_PutChar    (0608)    call  UART_1_PutChar                ; Write data to screen
1028: 18       POP   A                  (0609)    pop   A                             ; Restore value
1029: 21 0F    AND   A,0xF              (0610)    and   A,0Fh                         ; Mask off lower nibble
102B: FF E0    INDEX 0x100D             (0611)    index UART_1_HEX_STR                ; Get Hex value
102D: 90 08    CALL  _UART_1_PutChar    (0612)    call  UART_1_PutChar                ; Write data to screen
                                        (0613)    RAM_EPILOGUE RAM_USE_CLASS_1
102F: 7F       RET                      (0614)    ret
                                        (0615) .ENDSECTION
                                        (0616) 
                                        (0617) 
                                        (0618) .SECTION
                                        (0619) ;-----------------------------------------------------------------------------
                                        (0620) ;  FUNCTION NAME: UART_1_PutSHexInt
                                        (0621) ;
                                        (0622) ;  DESCRIPTION:
                                        (0623) ;     Print an Int in Hex (four characters) to UART Tx
                                        (0624) ;-----------------------------------------------------------------------------
                                        (0625) ;
                                        (0626) ;  ARGUMENTS:
                                        (0627) ;     Pointer to string
                                        (0628) ;     A  => ASB of Int
                                        (0629) ;     X  => MSB of Int
                                        (0630) ;
                                        (0631) ;  RETURNS:
                                        (0632) ;     none.
                                        (0633) ;
                                        (0634) ;  SIDE EFFECTS:
                                        (0635) ;    The A and X registers may be modified by this or future implementations
                                        (0636) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0637) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0638) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0639) ;    functions.
                                        (0640) ;
                                        (0641) 
                                        (0642)  UART_1_PutSHexInt:
                                        (0643) _UART_1_PutSHexInt:
                                        (0644)    RAM_PROLOGUE RAM_USE_CLASS_1
1030: 4B       SWAP  A,X                (0645)    swap  A,X
1031: 9F EA    CALL  _UART_1_PutSHexByte(0646)    call  UART_1_PutSHexByte            ; Print MSB
1033: 5B       MOV   A,X                (0647)    mov   A,X                           ; Move LSB into position
1034: 9F E7    CALL  _UART_1_PutSHexByte(0648)    call  UART_1_PutSHexByte            ; Print LSB
                                        (0649)    RAM_EPILOGUE RAM_USE_CLASS_1
1036: 7F       RET                      (0650)    ret
1037: 49 2B 10 TST   REG[0x2B],0x10     
103A: AF FC    JZ    _UART_1_PutChar    
103C: 60 29    MOV   REG[0x29],A        
                                        (0651) .ENDSECTION
                                        (0652) 
                                        (0653) 
                                        (0654) .SECTION
                                        (0655) ;-----------------------------------------------------------------------------
                                        (0656) ;  FUNCTION NAME: UART_1_PutChar
                                        (0657) ;
                                        (0658) ;  DESCRIPTION:
                                        (0659) ;     Send character out through UART TX port.
                                        (0660) ;-----------------------------------------------------------------------------
                                        (0661) ;
                                        (0662) ;  ARGUMENTS:
                                        (0663) ;     A has Character to send to UART Tx Port
                                        (0664) ;
                                        (0665) ;  RETURNS:
                                        (0666) ;     none
                                        (0667) ;
                                        (0668) ;  SIDE EFFECTS:
                                        (0669) ;    The A and X registers may be modified by this or future implementations
                                        (0670) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0671) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0672) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0673) ;    functions.
                                        (0674) ;
                                        (0675) 
                                        (0676)    macro InLinePutChar( Source )
                                        (0677) .BufEmptyWaitLoop:
                                        (0678)    tst REG[UART_1_TX_CONTROL_REG], UART_1_TX_BUFFER_EMPTY     ; Check Tx Status
                                        (0679)    jz  .BufEmptyWaitLoop
                                        (0680)    mov REG[UART_1_TX_BUFFER_REG], @Source        ; Write data to Tx Port
                                        (0681)    endm
                                        (0682) 
                                        (0683)  UART_1_PutChar:
                                        (0684) _UART_1_PutChar:
                                        (0685)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0686)    InLinePutChar A
                                        (0687)    RAM_EPILOGUE RAM_USE_CLASS_1
103E: 7F       RET                      (0688)    ret
                                        (0689) .ENDSECTION
                                        (0690) 
                                        (0691) 
                                        (0692) .SECTION
                                        (0693) ;-----------------------------------------------------------------------------
                                        (0694) ;  FUNCTION NAME: UART_1_cGetChar
                                        (0695) ;
                                        (0696) ;  DESCRIPTION:
                                        (0697) ;     Read character from UART RX port.
                                        (0698) ;-----------------------------------------------------------------------------
                                        (0699) ;
                                        (0700) ;  ARGUMENTS:
                                        (0701) ;      none
                                        (0702) ;
                                        (0703) ;  RETURNS:
                                        (0704) ;     char that is returned from UART
                                        (0705) ;
                                        (0706) ;  SIDE EFFECTS:
                                        (0707) ;    The A and X registers may be modified by this or future implementations
                                        (0708) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0709) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0710) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0711) ;    functions.
                                        (0712) ;
                                        (0713) ;    Program flow will stay in this function until a character is received.
                                        (0714) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0715) ;    the delay between characters is less than the watchdog timeout.
                                        (0716) ;
                                        (0717)  UART_1_cGetChar:
                                        (0718) _UART_1_cGetChar:
                                        (0719)    RAM_PROLOGUE RAM_USE_CLASS_1
103F: 49 2F 08 TST   REG[0x2F],0x8      (0720)    tst REG[UART_1_RX_CONTROL_REG],UART_1_RX_REG_FULL    ; Check if a character is ready
1042: AF FC    JZ    _UART_1_cGetChar   (0721)    jz  UART_1_cGetChar                              ; If not loop
1044: 5D 2E    MOV   A,REG[0x2E]        (0722)    mov A, REG[UART_1_RX_BUFFER_REG]                 ; Get character
                                        (0723)    RAM_EPILOGUE RAM_USE_CLASS_1
1046: 7F       RET                      (0724)    ret
                                        (0725) .ENDSECTION
                                        (0726) 
                                        (0727) 
                                        (0728) .SECTION
                                        (0729) ;-----------------------------------------------------------------------------
                                        (0730) ;  FUNCTION NAME: UART_1_cReadChar
                                        (0731) ;
                                        (0732) ;  DESCRIPTION:
                                        (0733) ;     Read character from UART RX port.
                                        (0734) ;-----------------------------------------------------------------------------
                                        (0735) ;
                                        (0736) ;  ARGUMENTS:
                                        (0737) ;      none
                                        (0738) ;
                                        (0739) ;  RETURNS:
                                        (0740) ;     char that is returned from UART
                                        (0741) ;
                                        (0742) ;  SIDE EFFECTS:
                                        (0743) ;    The A and X registers may be modified by this or future implementations
                                        (0744) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0745) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0746) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0747) ;    functions.
                                        (0748) ;
                                        (0749) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0750) ;    implies a valid character or an error condition occured.
                                        (0751) ;
                                        (0752)  UART_1_cReadChar:
                                        (0753) _UART_1_cReadChar:
                                        (0754)    RAM_PROLOGUE RAM_USE_CLASS_1
1047: 5D 2F    MOV   A,REG[0x2F]        (0755)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Get Status of RX
1049: 08       PUSH  A                  (0756)    push A
104A: 21 08    AND   A,0x8              (0757)    and  A,UART_1_RX_COMPLETE                               ; Check if a character is ready
104C: B0 04    JNZ   0x1051             (0758)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
104E: 18       POP   A                  (0759)    pop  A
104F: 80 0B    JMP   0x105B             (0760)    jmp  .RX_NO_VALID_CHAR
                                        (0761) 
                                        (0762) .RX_DATA_RDY:
1051: 5D 2E    MOV   A,REG[0x2E]        (0763)    mov  A,REG[UART_1_RX_BUFFER_REG ]          
1053: 4B       SWAP  A,X                (0764)    swap A,X                                                ; determine if data is valid
                                        (0765) 
1054: 18       POP   A                  (0766)    pop  A                                                  ; Check for errors
1055: 21 A0    AND   A,0xA0             (0767)    and  A,(UART_1_RX_PARITY_ERROR | UART_1_RX_FRAMING_ERROR)
1057: B0 03    JNZ   0x105B             (0768)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
1059: 4B       SWAP  A,X                (0769)    swap A,X                                                ; Put data in A and exit
                                        (0770)    RAM_EPILOGUE RAM_USE_CLASS_1
105A: 7F       RET                      (0771)    ret
                                        (0772) 
                                        (0773) .RX_NO_VALID_CHAR:
105B: 50 00    MOV   A,0x0              (0774)    mov A,0x00                                              ; Zero out character
                                        (0775) 
                                        (0776)  End_UART_1_cReadChar:
                                        (0777)    RAM_EPILOGUE RAM_USE_CLASS_1
105D: 7F       RET                      (0778)    ret
                                        (0779) .ENDSECTION
                                        (0780) 
                                        (0781) 
                                        (0782) .SECTION
                                        (0783) ;-----------------------------------------------------------------------------
                                        (0784) ;  FUNCTION NAME: UART_1_iReadChar
                                        (0785) ;
                                        (0786) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0787) ;  to just set a value in the upper byte if error conditions exists.
                                        (0788) ;
                                        (0789) ;  DESCRIPTION:
                                        (0790) ;     Read character from UART RX port.
                                        (0791) ;-----------------------------------------------------------------------------
                                        (0792) ;
                                        (0793) ;  ARGUMENTS:
                                        (0794) ;      none
                                        (0795) ;
                                        (0796) ;  RETURNS:
                                        (0797) ;     An integer value is returned.  A negative value inplies and error
                                        (0798) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0799) ;
                                        (0800) ;     Error Codes:
                                        (0801) ;        0x80CC    Parity Error
                                        (0802) ;        0x40CC    Overrun Error
                                        (0803) ;        0x20CC    Framing Error
                                        (0804) ;        0x01CC    No Data available
                                        (0805) ;
                                        (0806) ;  SIDE EFFECTS:
                                        (0807) ;    The A and X registers may be modified by this or future implementations
                                        (0808) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0809) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0810) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0811) ;    functions.
                                        (0812) ;
                                        (0813)  UART_1_iReadChar:
                                        (0814) _UART_1_iReadChar:
                                        (0815)    RAM_PROLOGUE RAM_USE_CLASS_1
105E: 5D 2F    MOV   A,REG[0x2F]        (0816)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Get Status of RX
                                        (0817)                                                            ; Mask only errors and data ready
1060: 21 E8    AND   A,0xE8             (0818)    and  A,(UART_1_RX_ERROR|UART_1_RX_REG_FULL)
1062: 08       PUSH  A                  (0819)    push A
1063: 21 08    AND   A,0x8              (0820)    and  A,UART_1_RX_COMPLETE                               ; Check if a character is ready
1065: B0 07    JNZ   0x106D             (0821)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
1067: 18       POP   A                  (0822)    pop  A
1068: 29 01    OR    A,0x1              (0823)    or   A,UART_1_RX_NO_DATA                                ; Add no data flag
106A: 4B       SWAP  A,X                (0824)    swap A,X
106B: 80 07    JMP   0x1073             (0825)    jmp  End_UART_1_iReadChar
                                        (0826) 
                                        (0827) .RX_GET_DATA:
106D: 18       POP   A                  (0828)    pop  A
106E: 21 E0    AND   A,0xE0             (0829)    and  A,UART_1_RX_ERROR
1070: 4B       SWAP  A,X                (0830)    swap A,X
1071: 5D 2E    MOV   A,REG[0x2E]        (0831)    mov  A,REG[UART_1_RX_BUFFER_REG ]                       ; Read data first, then
                                        (0832)                                                            ; determine if data is valid
                                        (0833) 
                                        (0834)  End_UART_1_iReadChar:
                                        (0835)    RAM_EPILOGUE RAM_USE_CLASS_1
1073: 7F       RET                      (0836)    ret
1074: 70 BF    AND   F,0xBF             
1076: 60 D3    MOV   REG[0xD3],A        
                                        (0837) .ENDSECTION
                                        (0838) 
                                        (0839) 
                                        (0840) .SECTION
                                        (0841) ;-----------------------------------------------------------------------------
                                        (0842) ;  FUNCTION NAME: UART_1_PutString
                                        (0843) ;
                                        (0844) ;  DESCRIPTION:
                                        (0845) ;     Send String out through UART TX port.
                                        (0846) ;-----------------------------------------------------------------------------
                                        (0847) ;
                                        (0848) ;  ARGUMENTS:
                                        (0849) ;     Pointer to String
                                        (0850) ;     A has MSB of string address
                                        (0851) ;     X has LSB of string address
                                        (0852) ;
                                        (0853) ;  RETURNS:
                                        (0854) ;     none
                                        (0855) ;
                                        (0856) ;  SIDE EFFECTS:
                                        (0857) ;    The A and X registers may be modified by this or future implementations
                                        (0858) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0859) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0860) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0861) ;    functions.
                                        (0862) ;          
                                        (0863) ;    Currently only the page pointer registers listed below are modified: 
                                        (0864) ;          IDX_PP
                                        (0865) ;
                                        (0866)  UART_1_PutString:
                                        (0867) _UART_1_PutString:
                                        (0868)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0869)    RAM_SETPAGE_IDX A
                                        (0870) .PutStringLoop:
1078: 52 00    MOV   A,[X+0]            (0871)    mov   A,[X]                                   ; Get value pointed to by X
107A: A0 06    JZ    0x1081             (0872)    jz    End_PutString                           ; Check for end of string
107C: 9F B9    CALL  _UART_1_PutChar    (0873)    call  UART_1_PutChar                          ; Send character to Tx port
107E: 75       INC   X                  (0874)    inc   X                                       ; Advance pointer to next character
107F: 8F F8    JMP   0x1078             (0875)    jmp   .PutStringLoop                          ; Get next character
1081: 70 3F    AND   F,0x3F             
1083: 71 C0    OR    F,0xC0             
                                        (0876) 
                                        (0877) End_PutString:
                                        (0878)    RAM_EPILOGUE RAM_USE_CLASS_3
1085: 7F       RET                      (0879)    ret
1086: 70 BF    AND   F,0xBF             
1088: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0880) .ENDSECTION
                                        (0881)     
                                        (0882) .SECTION
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: UART_1_Write
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:
                                        (0887) ;     Send String of length X to serial port
                                        (0888) ;-----------------------------------------------------------------------------
                                        (0889) ;
                                        (0890) ;  ARGUMENTS:
                                        (0891) ;     Pointer to String
                                        (0892) ;     [SP-5] Count of characters to send
                                        (0893) ;     [SP-4] has MSB of string address
                                        (0894) ;     [SP-3] has LSB of string address
                                        (0895) ;
                                        (0896) ;  RETURNS:
                                        (0897) ;     none
                                        (0898) ;
                                        (0899) ;  SIDE EFFECTS:
                                        (0900) ;    The A and X registers may be modified by this or future implementations
                                        (0901) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0902) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0903) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0904) ;    functions.
                                        (0905) ;          
                                        (0906) ;    Currently only the page pointer registers listed below are modified: 
                                        (0907) ;          IDX_PP
                                        (0908) ;
                                        (0909) CNT_LEN:    equ -5                               ; Length of data to send
                                        (0910) STR_MSB:    equ -4                               ; MSB pointer of string 
                                        (0911) STR_LSB:    equ -3                               ; LSB pointer of string 
                                        (0912) 
                                        (0913)  UART_1_Write:
                                        (0914) _UART_1_Write:
                                        (0915)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0916)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
108B: 4F       MOV   X,SP               (0917)    mov   X, SP                                   ; Establish the frame pointer 
                                        (0918) 
                                        (0919) .NextByteLoop:
108C: 52 FB    MOV   A,[X-5]            (0920)    mov   A, [X+CNT_LEN]                          ; End of the string?
108E: A0 1A    JZ    0x10A9             (0921)    jz    .End_Write                              ;   Yes, prepare to exit
1090: 7B FB    DEC   [X-5]              (0922)    dec   [X+CNT_LEN]                             ; Decrement counter
                                        (0923) 
                                        (0924)    IF SYSTEM_LARGE_MEMORY_MODEL
1092: 52 FC    MOV   A,[X-4]            (0925)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                        (0926)    ENDIF
                                        (0927) 
1094: 59 FD    MOV   X,[X-3]            (0928)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
1096: 60 D3    MOV   REG[0xD3],A        
                                        (0929)    RAM_SETPAGE_IDX A                             ; switch index pages
1098: 52 00    MOV   A,[X+0]            (0930)    mov   A, [X]                                  ; Grab the data
109A: 49 2B 10 TST   REG[0x2B],0x10     
109D: AF FC    JZ    0x109A             
109F: 60 29    MOV   REG[0x29],A        
                                        (0931)    InLinePutChar A                               ; Put data in empty TX buf reg
10A1: 4F       MOV   X,SP               (0932)    mov   X, SP                                   ; Recover frame pointer
10A2: 62 D3 03 MOV   REG[0xD3],0x3      
                                        (0933)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
10A5: 77 FD    INC   [X-3]              (0934)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
10A7: 8F E4    JMP   0x108C             (0935)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
10A9: 70 3F    AND   F,0x3F             
10AB: 71 C0    OR    F,0xC0             
                                        (0936) 
                                        (0937) .End_Write:
                                        (0938)    RAM_EPILOGUE RAM_USE_CLASS_3
10AD: 7F       RET                      (0939)    ret
                                        (0940) .ENDSECTION
                                        (0941)     
                                        (0942) 
                                        (0943) .SECTION
                                        (0944) ;-----------------------------------------------------------------------------
                                        (0945) ;  FUNCTION NAME: UART_1_CWrite
                                        (0946) ;
                                        (0947) ;             WARNING WARNING NOT COMPLETE
                                        (0948) ;
                                        (0949) ;  DESCRIPTION:
                                        (0950) ;     Send String of length X to serial port
                                        (0951) ;-----------------------------------------------------------------------------
                                        (0952) ;
                                        (0953) ;  ARGUMENTS:
                                        (0954) ;     [SP-4] MSB of Count of character to send
                                        (0955) ;     [SP-3] LSB of Count of character to send
                                        (0956) ;     [SP-2] has MSB of string address
                                        (0957) ;     [SP-1] has LSB of string address
                                        (0958) ;
                                        (0959) ;  RETURNS:
                                        (0960) ;     none
                                        (0961) ;
                                        (0962) ;  SIDE EFFECTS:
                                        (0963) ;    The A and X registers may be modified by this or future implementations
                                        (0964) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0965) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0966) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0967) ;    functions.
                                        (0968) ;
                                        (0969) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                        (0970) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                        (0971) CSTR_MSB:   equ -4           ; MSB pointer of string
                                        (0972) CSTR_LSB:   equ -3           ; LSB pointer of string
                                        (0973) 
                                        (0974)  UART_1_CWrite:
                                        (0975) _UART_1_CWrite:
                                        (0976)    RAM_PROLOGUE RAM_USE_CLASS_2
10AE: 4F       MOV   X,SP               (0977)    mov   X,SP
                                        (0978) .CW_Loop:
10AF: 3D FA 00 CMP   [X-6],0x0          (0979)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
10B2: B0 06    JNZ   0x10B9             (0980)    jnz   .CW_WRITEIT
10B4: 3D FB 00 CMP   [X-5],0x0          (0981)    cmp   [X+CLEN_LSB],0x00
10B7: A0 1D    JZ    0x10D5             (0982)    jz    .End_CWrite                        ; Leave if done
                                        (0983) 
                                        (0984) .CW_WRITEIT:                                
10B9: 10       PUSH  X                  (0985)    push  X                                  ; Save frame pointer
10BA: 52 FC    MOV   A,[X-4]            (0986)    mov   A,[X+CSTR_MSB]
10BC: 59 FD    MOV   X,[X-3]            (0987)    mov   X,[X+CSTR_LSB]
10BE: 28       ROMX                     (0988)    romx                                     ; Get character from ROM
10BF: 49 2B 10 TST   REG[0x2B],0x10     
10C2: AF FC    JZ    0x10BF             
10C4: 60 29    MOV   REG[0x29],A        
                                        (0989)    InLinePutChar A                          ; Put data in empty TX buf reg
10C6: 20       POP   X                  (0990)    pop   X                                  ; Restore frame pointer
10C7: 07 FD 01 ADD   [X-3],0x1          (0991)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
10CA: 0F FC 00 ADC   [X-4],0x0          (0992)    adc   [X+CSTR_MSB],0
10CD: 17 FB 01 SUB   [X-5],0x1          (0993)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
10D0: 1F FA 00 SBB   [X-6],0x0          (0994)    sbb   [X+CLEN_MSB],0x00
10D3: 8F DB    JMP   0x10AF             (0995)    jmp   .CW_Loop
10D5: 70 3F    AND   F,0x3F             
10D7: 71 C0    OR    F,0xC0             
                                        (0996) 
                                        (0997) .End_CWrite:
                                        (0998)    RAM_EPILOGUE RAM_USE_CLASS_2
10D9: 7F       RET                      (0999)    ret
                                        (1000) .ENDSECTION
                                        (1001) 
                                        (1002) 
                                        (1003) .SECTION
                                        (1004) ;-----------------------------------------------------------------------------
                                        (1005) ;  FUNCTION NAME: UART_1_CPutString
                                        (1006) ;
                                        (1007) ;  DESCRIPTION:
                                        (1008) ;     Send String out through UART TX port.
                                        (1009) ;-----------------------------------------------------------------------------
                                        (1010) ;
                                        (1011) ;  ARGUMENTS:
                                        (1012) ;     Pointer to String
                                        (1013) ;     A has MSB of string address
                                        (1014) ;     X has LSB of string address
                                        (1015) ;
                                        (1016) ;  RETURNS:
                                        (1017) ;     none
                                        (1018) ;
                                        (1019) ;  SIDE EFFECTS:
                                        (1020) ;    The A and X registers may be modified by this or future implementations
                                        (1021) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1022) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1023) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1024) ;    functions.
                                        (1025) ;
                                        (1026)  UART_1_CPutString:
                                        (1027) _UART_1_CPutString:
                                        (1028)    RAM_PROLOGUE RAM_USE_CLASS_1
10DA: 08       PUSH  A                  (1029)    push  A                                       ; Store ROM pointer
10DB: 10       PUSH  X                  (1030)    push  X
10DC: 28       ROMX                     (1031)    romx                                          ; Get character from ROM
10DD: A0 0B    JZ    0x10E9             (1032)    jz    .End_CPutString
10DF: 9F 56    CALL  _UART_1_PutChar    (1033)    call  UART_1_PutChar                          ; Print character
10E1: 20       POP   X                  (1034)    pop   X
10E2: 18       POP   A                  (1035)    pop   A
10E3: 75       INC   X                  (1036)    inc   X                                       ; Inc LSB of pointer
10E4: DF F5    JNC   _UART_1_CPutString (1037)    jnc   UART_1_CPutString                       ; Check for carry
10E6: 74       INC   A                  (1038)    inc   A                                       ; Inc MSB of pointer
10E7: 8F F2    JMP   _UART_1_CPutString (1039)    jmp   UART_1_CPutString
                                        (1040) 
                                        (1041) 
                                        (1042) .End_CPutString:
10E9: 38 FE    ADD   SP,0xFE            (1043)    add   SP, -2
                                        (1044)    RAM_EPILOGUE RAM_USE_CLASS_1
10EB: 7F       RET                      (1045)    ret
                                        (1046) .ENDSECTION
                                        (1047) 
                                        (1048) 
                                        (1049) .SECTION
                                        (1050) ;-----------------------------------------------------------------------------
                                        (1051) ;  FUNCTION NAME: UART_1_PutCRLF
                                        (1052) ;
                                        (1053) ;  DESCRIPTION:
                                        (1054) ;     Send a CR and LF
                                        (1055) ;-----------------------------------------------------------------------------
                                        (1056) ;
                                        (1057) ;  ARGUMENTS:
                                        (1058) ;     none.
                                        (1059) ;
                                        (1060) ;  RETURNS:
                                        (1061) ;     none.
                                        (1062) ;
                                        (1063) ;  SIDE EFFECTS:
                                        (1064) ;    The A and X registers may be modified by this or future implementations
                                        (1065) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1066) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1067) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1068) ;    functions.
                                        (1069) ;
                                        (1070)  UART_1_PutCRLF:
                                        (1071) _UART_1_PutCRLF:
                                        (1072)    RAM_PROLOGUE RAM_USE_CLASS_1
10EC: 50 0D    MOV   A,0xD              (1073)    mov  A,0x0D                        ; Send CR
10EE: 9F 47    CALL  _UART_1_PutChar    (1074)    call UART_1_PutChar
10F0: 50 0A    MOV   A,0xA              (1075)    mov  A,0x0A                        ; Send LF
10F2: 9F 43    CALL  _UART_1_PutChar    (1076)    call UART_1_PutChar
                                        (1077)    RAM_EPILOGUE RAM_USE_CLASS_1
10F4: 7F       RET                      (1078)    ret
10F5: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1079) .ENDSECTION
                                        (1080) 
                                        (1081) 
                                        (1082) IF (UART_1_RXBUF_ENABLE)
                                        (1083) ;=============================================================================
                                        (1084) ;=============================================================================
                                        (1085) ;
                                        (1086) ;     Command Buffer commands
                                        (1087) ;
                                        (1088) ;=============================================================================
                                        (1089) ;=============================================================================
                                        (1090) 
                                        (1091) .SECTION
                                        (1092) ;-----------------------------------------------------------------------------
                                        (1093) ;  FUNCTION NAME: UART_1_CmdReset
                                        (1094) ;
                                        (1095) ;  DESCRIPTION:
                                        (1096) ;     Reset command string and status flags
                                        (1097) ;-----------------------------------------------------------------------------
                                        (1098) ;
                                        (1099) ;  ARGUMENTS:
                                        (1100) ;     none.
                                        (1101) ;
                                        (1102) ;  RETURNS:
                                        (1103) ;     none.
                                        (1104) ;
                                        (1105) ;  SIDE EFFECTS:
                                        (1106) ;    The A and X registers may be modified by this or future implementations
                                        (1107) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1108) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1109) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1110) ;    functions.
                                        (1111) ;          
                                        (1112) ;    Currently only the page pointer registers listed below are modified: 
                                        (1113) ;          CUR_PP
                                        (1114) ;
                                        (1115) ;  THEORY of OPERATION or PROCEDURE:
                                        (1116) ;     Clear the command buffer, command counter, and flag.
                                        (1117) ;
                                        (1118)  UART_1_CmdReset:
                                        (1119) _UART_1_CmdReset:
                                        (1120)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1121)    RAM_SETPAGE_CUR >UART_1_aRxBuffer
10F8: 55 A5 00 MOV   [pData+33],0x0     (1122)    mov [UART_1_aRxBuffer], 0x00
10FB: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1123)    RAM_SETPAGE_CUR >UART_1_bRxCnt
10FE: 55 3B 00 MOV   [0x3B],0x0         (1124)    mov [UART_1_bRxCnt], 0x00
1101: 26 3A 00 AND   [0x3A],0x0         (1125)    and [UART_1_fStatus], 0x00
1104: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1126)    RAM_SETPAGE_CUR >ptrParam
1107: 55 CC 00 MOV   [len+1],0x0        (1127)    mov [ptrParam],0x00
                                        (1128)    RAM_EPILOGUE RAM_USE_CLASS_4
110A: 7F       RET                      (1129)    ret
110B: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1130) .ENDSECTION
                                        (1131) 
                                        (1132) 
                                        (1133) .SECTION
                                        (1134) ;-----------------------------------------------------------------------------
                                        (1135) ;  FUNCTION NAME: UART_1_bCmdCheck
                                        (1136) ;
                                        (1137) ;  DESCRIPTION:
                                        (1138) ;     Check to see if valid command in buffer.
                                        (1139) ;-----------------------------------------------------------------------------
                                        (1140) ;
                                        (1141) ;  ARGUMENTS:
                                        (1142) ;     none.
                                        (1143) ;
                                        (1144) ;  RETURNS:
                                        (1145) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1146) ;                     Returns non-zero value in A if command is valid.
                                        (1147) ;
                                        (1148) ;  SIDE EFFECTS:
                                        (1149) ;    The A and X registers may be modified by this or future implementations
                                        (1150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1153) ;    functions.
                                        (1154) ;          
                                        (1155) ;    Currently only the page pointer registers listed below are modified: 
                                        (1156) ;          CUR_PP
                                        (1157) ;
                                        (1158) ;  THEORY of OPERATION or PROCEDURE:
                                        (1159) ;     Read the status and control register.
                                        (1160) ;
                                        (1161)  UART_1_bCmdCheck:
                                        (1162) _UART_1_bCmdCheck:
                                        (1163)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1164)    RAM_SETPAGE_CUR >UART_1_fStatus
110E: 51 3A    MOV   A,[0x3A]           (1165)    mov A,  [UART_1_fStatus]
1110: 21 01    AND   A,0x1              (1166)    and A, UART_1_RX_BUF_CMDTERM                  ; Mask off Command status
                                        (1167)    RAM_EPILOGUE RAM_USE_CLASS_4
1112: 7F       RET                      (1168)    ret
1113: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1169) .ENDSECTION
                                        (1170)     
                                        (1171) 
                                        (1172) .SECTION
                                        (1173) ;-----------------------------------------------------------------------------
                                        (1174) ;  FUNCTION NAME: UART_1_bErrCheck
                                        (1175) ;
                                        (1176) ;  DESCRIPTION:
                                        (1177) ;     Check to see if an error has occured since last CmdReset
                                        (1178) ;-----------------------------------------------------------------------------
                                        (1179) ;
                                        (1180) ;  ARGUMENTS:
                                        (1181) ;     none.
                                        (1182) ;
                                        (1183) ;  RETURNS:
                                        (1184) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1185) ;                     Returns non-zero value in A if command is valid.
                                        (1186) ;           0x80 => Parity Error
                                        (1187) ;           0x40 => OverRun Error
                                        (1188) ;           0x20 => Framing Error
                                        (1189) ;           0x10 => Software Buffer OverRun
                                        (1190) ;
                                        (1191) ;  SIDE EFFECTS:
                                        (1192) ;    The A and X registers may be modified by this or future implementations
                                        (1193) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1194) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1195) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1196) ;    functions.
                                        (1197) ;          
                                        (1198) ;    Currently only the page pointer registers listed below are modified: 
                                        (1199) ;          CUR_PP
                                        (1200) ;     Error Status is clear when read.
                                        (1201) ;
                                        (1202) ;  THEORY of OPERATION or PROCEDURE:
                                        (1203) ;     Read RX buffer error status and clear status
                                        (1204) ;
                                        (1205)  UART_1_bErrCheck:
                                        (1206) _UART_1_bErrCheck:
                                        (1207)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1208)    RAM_SETPAGE_CUR >UART_1_fStatus
1116: 51 3A    MOV   A,[0x3A]           (1209)    mov A,  [UART_1_fStatus]
1118: 21 F0    AND   A,0xF0             (1210)    and A, UART_1_RX_BUF_ERROR                    ; Mask off Error status
111A: 26 3A 0F AND   [0x3A],0xF         (1211)    and [UART_1_fStatus], ~UART_1_RX_BUF_ERROR
                                        (1212)    RAM_EPILOGUE RAM_USE_CLASS_4
111D: 7F       RET                      (1213)    ret
111E: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1214) .ENDSECTION
                                        (1215) 
                                        (1216) .SECTION
                                        (1217) ;-----------------------------------------------------------------------------
                                        (1218) ;  FUNCTION NAME: UART_1_bCmdLength
                                        (1219) ;
                                        (1220) ;  DESCRIPTION:
                                        (1221) ;     Get length of command string
                                        (1222) ;-----------------------------------------------------------------------------
                                        (1223) ;
                                        (1224) ;  ARGUMENTS:
                                        (1225) ;     none.
                                        (1226) ;
                                        (1227) ;  RETURNS:
                                        (1228) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (1229) ;
                                        (1230) ;  SIDE EFFECTS:
                                        (1231) ;    The A and X registers may be modified by this or future implementations
                                        (1232) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1234) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1235) ;    functions.
                                        (1236) ;          
                                        (1237) ;    Currently only the page pointer registers listed below are modified: 
                                        (1238) ;          CUR_PP
                                        (1239) ;
                                        (1240)  UART_1_bCmdLength:
                                        (1241) _UART_1_bCmdLength:
                                        (1242)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1243)    RAM_SETPAGE_CUR >UART_1_bRxCnt
1121: 51 3B    MOV   A,[0x3B]           (1244)    mov A,  [UART_1_bRxCnt]
                                        (1245)    RAM_EPILOGUE RAM_USE_CLASS_4
1123: 7F       RET                      (1246)    ret
1124: 70 BF    AND   F,0xBF             
1126: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1247) .ENDSECTION
                                        (1248) 
                                        (1249) 
                                        (1250) .SECTION
                                        (1251) ;-----------------------------------------------------------------------------
                                        (1252) ;  FUNCTION NAME: UART_1_szGetParam
                                        (1253) ;
                                        (1254) ;  DESCRIPTION:
                                        (1255) ;      Return next parameter from UART_1 Rx buffer
                                        (1256) ;-----------------------------------------------------------------------------
                                        (1257) ;
                                        (1258) ;  ARGUMENTS:  none
                                        (1259) ;
                                        (1260) ;  RETURNS:
                                        (1261) ;     A => MSB of parameter address
                                        (1262) ;     X => LSB of parameter address
                                        (1263) ;
                                        (1264) ;  SIDE EFFECTS:
                                        (1265) ;    The A and X registers may be modified by this or future implementations
                                        (1266) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1268) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1269) ;    functions.
                                        (1270) ;          
                                        (1271) ;    Currently only the page pointer registers listed below are modified: 
                                        (1272) ;          CUR_PP
                                        (1273) ;          IDX_PP
                                        (1274) ;
                                        (1275) ;     The receive string is modified by placing Null characters at the end
                                        (1276) ;     of each parameter as they are recovered.
                                        (1277) ;
                                        (1278) ;  THEORY OF OPERATION:
                                        (1279) ;     This function is a stateful generator of addresses to the "parameters"
                                        (1280) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (1281) ;     each lexically distinct element into a null-terminated string by replacing
                                        (1282) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (1283) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (1284) ;     offset. The generator is initialized by a call to the function
                                        (1285) ;     UART_1_CmdReset which resets the entire buffer to the 'empty'
                                        (1286) ;     state. Typically this function, UART_1_szGetParam, is
                                        (1287) ;     not called until the buffer has been loaded with an entire command
                                        (1288) ;     (See UART_1_bCmdCheck).
                                        (1289) ;
                                        (1290) ;     Note, there is no special distinction between the "command" and the 
                                        (1291) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (1292) ;     character of the "command"---is also, for the purposes of this function,
                                        (1293) ;     the first "parameter" to which it returns an address.
                                        (1294) ;
                                        (1295) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (1296) ;     is determined at configuration time by a user module parameter.
                                        (1297) ;
                                        (1298)  UART_1_szGetParam:
                                        (1299) _UART_1_szGetParam:
                                        (1300)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1301)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1302)     
                                        (1303)    RAM_SETPAGE_CUR >ptrParam
1129: 50 A5    MOV   A,0xA5             (1304)    mov   A, <UART_1_aRxBuffer               ; Get address to receive buffer
112B: 02 CC    ADD   A,[len+1]          (1305)    add   A, [ptrParam]                      ; Add string offset
112D: 5C       MOV   X,A                (1306)    mov   X, A
112E: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (1307)    RAM_SETPAGE_IDX >UART_1_aRxBuffer
1131: 52 00    MOV   A,[X+0]            (1308)    mov   A, [X]                             ; Get character pointed by X
1133: B0 04    JNZ   0x1138             (1309)    jnz   .SkipOverDelimitersLoop            ; Null? No,  continue...
1135: 10       PUSH  X                  (1310)    push  X                                  ;       Yes, Save LSB of current pointer
1136: 80 33    JMP   0x116A             (1311)    jmp   .End_GetNextParam
                                        (1312)                                             ; Check for delimiter and keep looping until
                                        (1313)                                             ; all leading delimiters have been found.
                                        (1314) .SkipOverDelimitersLoop:
1138: 39 20    CMP   A,0x20             (1315)    cmp   A, UART_1_DELIMITER                ; Do we have a delimiter?
113A: B0 11    JNZ   0x114C             (1316)    jnz   .ParamStartFound                   ;   No,  Bingo! found a parameter
113C: 75       INC   X                  (1317)    inc   X                                  ;   Yes, Increment both index and...
113D: 76 CC    INC   [len+1]            (1318)    inc   [ptrParam]                         ;          the stored pointer.
113F: 52 00    MOV   A,[X+0]            (1319)    mov   A, [X]                             ; Get character pointed by X
1141: 3C CC 0F CMP   [len+1],0xF        (1320)    cmp   [ptrParam], (UART_1_RX_BUFFER_SIZE -1)   ; End of buffer?
1144: BF F3    JNZ   0x1138             (1321)    jnz   .SkipOverDelimitersLoop            ;   No,  continue the scan
                                        (1322) 
                                        (1323) .EndOfString:                               ;   Yes, end of string found...
1146: 10       PUSH  X                  (1324)    push  X                                  ;        Save ptr
                                        (1325) .TerminateString:
1147: 56 00 00 MOV   [X+0],0x0          (1326)    mov   [X], 0x00                          ; Make sure string is zero
114A: 80 1F    JMP   0x116A             (1327)    jmp   .End_GetNextParam
                                        (1328) 
                                        (1329) .ParamStartFound:
114C: 10       PUSH  X                  (1330)    push  X                                  ; Beginning of parameter found, save pointer
                                        (1331) 
                                        (1332) .ParamLoop:                                 ; Now loop until end of parameter found.
114D: 75       INC   X                  (1333)    inc   X                                  ; Advance pointers.
114E: 76 CC    INC   [len+1]            (1334)    inc   [ptrParam]
1150: 3C CC 0F CMP   [len+1],0xF        (1335)    cmp   [ptrParam], (UART_1_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
1153: AF F3    JZ    0x1147             (1336)    jz    .TerminateString
1155: 52 00    MOV   A,[X+0]            (1337)    mov   A, [X]                             ; Get next character
1157: A0 12    JZ    0x116A             (1338)    jz    .End_GetNextParam
1159: 39 20    CMP   A,0x20             (1339)    cmp   A, UART_1_DELIMITER                ; Check if we have a delimiter
115B: BF F1    JNZ   0x114D             (1340)    jnz   .ParamLoop                         ; Still no delimiter, loop again
115D: 56 00 00 MOV   [X+0],0x0          (1341)    mov   [X], 0x00                          ; Replace delimiter with null for end of substring
1160: 76 CC    INC   [len+1]            (1342)    inc   [ptrParam]
1162: 3C CC 0F CMP   [len+1],0xF        (1343)    cmp   [ptrParam], (UART_1_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
1165: B0 04    JNZ   0x116A             (1344)    jnz   .End_GetNextParam                  ; If not end of string leave
1167: 55 CC 0F MOV   [len+1],0xF        (1345)    mov   [ptrParam], (UART_1_RX_BUFFER_SIZE -1)   ; Reset pointer to end of string.
                                        (1346) 
                                        (1347) .End_GetNextParam:
116A: 20       POP   X                  (1348)    pop   X
116B: 10       PUSH  X                  (1349)    push  X
116C: 3D 00 00 CMP   [X+0],0x0          (1350)    cmp   [X], 0x00
116F: B0 0A    JNZ   0x117A             (1351)    jnz   .NotNullString
1171: 20       POP   X                  (1352)    pop   X
1172: 57 00    MOV   X,0x0              (1353)    mov   X, 0x00
1174: 5B       MOV   A,X                (1354)    mov   A, X
1175: 70 3F    AND   F,0x3F             
1177: 71 C0    OR    F,0xC0             
                                        (1355)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1356)    RAM_EPILOGUE RAM_USE_CLASS_4
1179: 7F       RET                      (1357)    ret
                                        (1358) 
                                        (1359) .NotNullString:
117A: 20       POP   X                  (1360)    pop  X
117B: 50 00    MOV   A,0x0              (1361)    mov  A, >UART_1_aRxBuffer                ; Return pointer
117D: 70 3F    AND   F,0x3F             
117F: 71 C0    OR    F,0xC0             
                                        (1362)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1363)    RAM_EPILOGUE RAM_USE_CLASS_4
1181: 7F       RET                      (1364)    ret
1182: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1365) .ENDSECTION
                                        (1366) 
                                        (1367) 
                                        (1368) .SECTION
                                        (1369) ;-----------------------------------------------------------------------------
                                        (1370) ;  FUNCTION NAME: UART_1_szGetRestOfParams
                                        (1371) ;
                                        (1372) ;  DESCRIPTION:
                                        (1373) ;      Returns a pointer to the rest of the UART RX buffer
                                        (1374) ;-----------------------------------------------------------------------------
                                        (1375) ;
                                        (1376) ;  ARGUMENTS:  none
                                        (1377) ;
                                        (1378) ;  RETURNS:
                                        (1379) ;     A => MSB of parameter
                                        (1380) ;     X => LSB of parameter
                                        (1381) ;
                                        (1382) ;  SIDE EFFECTS:
                                        (1383) ;    The A and X registers may be modified by this or future implementations
                                        (1384) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1385) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1386) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1387) ;    functions.
                                        (1388) ;          
                                        (1389) ;    Currently only the page pointer registers listed below are modified: 
                                        (1390) ;          CUR_PP
                                        (1391) ;
                                        (1392)  UART_1_szGetRestOfParams:
                                        (1393) _UART_1_szGetRestOfParams:
                                        (1394)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1395)    RAM_SETPAGE_CUR >ptrParam
1185: 50 A5    MOV   A,0xA5             (1396)    mov  A, <UART_1_aRxBuffer                ; Get address to receive buffer
1187: 02 CC    ADD   A,[len+1]          (1397)    add  A, [ptrParam]                       ; Add string offset
1189: 5C       MOV   X,A                (1398)    mov  X,A
118A: 50 00    MOV   A,0x0              (1399)    mov  A,>UART_1_aRxBuffer                 ; Return pointer
                                        (1400)    RAM_EPILOGUE RAM_USE_CLASS_4
118C: 7F       RET                      (1401)    ret
                                        (1402) .ENDSECTION
                                        (1403) 
                                        (1404) ENDIF
                                        (1405) 
                                        (1406) 
                                        (1407) ; End of File UART_1.asm
FILE: lib\sleeptimer_1int.asm           (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   SleepTimer_1INT.asm
                                        (0004) ;;  Version: 1.0, Updated on 2013/5/19 at 10:44:14
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "SleepTimer_1.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "m8c.inc"
                                        (0016) 
                                        (0017) ;-----------------------------------------------
                                        (0018) ;  Global Symbols
                                        (0019) ;-----------------------------------------------
                                        (0020) export  _SleepTimer_1_ISR
                                        (0021) 
                                        (0022) 
                                        (0023) export  SleepTimer_1_fTick
                                        (0024) export _SleepTimer_1_fTick
                                        (0025) export  SleepTimer_1_bTimerValue
                                        (0026) export _SleepTimer_1_bTimerValue
                                        (0027) export  SleepTimer_1_bCountDown
                                        (0028) export _SleepTimer_1_bCountDown
                                        (0029) export  SleepTimer_1_TickCount
                                        (0030) export _SleepTimer_1_TickCount
                                        (0031) 
                                        (0032) ;-----------------------------------------------
                                        (0033) ; Variable Allocation
                                        (0034) ;-----------------------------------------------
                                        (0035) AREA InterruptRAM (RAM, REL, CON)
                                        (0036) 
                                        (0037)  SleepTimer_1_fTick:
                                        (0038) _SleepTimer_1_fTick:        BLK  1
                                        (0039) 
                                        (0040)  SleepTimer_1_bTimerValue:
                                        (0041) _SleepTimer_1_bTimerValue:  BLK  1
                                        (0042) 
                                        (0043)  SleepTimer_1_bCountDown:
                                        (0044) _SleepTimer_1_bCountDown:   BLK  1
                                        (0045) 
                                        (0046)  SleepTimer_1_TickCount:
                                        (0047) _SleepTimer_1_TickCount:    BLK  SleepTimer_1_TICK_CNTR_SIZE
                                        (0048) 
                                        (0049) 
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _SleepTimer_1_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;      interrupt handler for instance SleepTimer_1.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _SleepTimer_1_ISR:
                                        (0090) 
118D: 2E 3C 01 OR    [0x3C],0x1         (0091)    or   [SleepTimer_1_fTick],0x01           ; Set tick flag
                                        (0092)  
                                        (0093)                                                 ; Decrement CountDown (Sync counter)
1190: 47 3E FF TST   [0x3E],0xFF        (0094)    tst  [SleepTimer_1_bCountDown],0xFF
1193: A0 03    JZ    0x1197             (0095)    jz   .DoTimer
1195: 7A 3E    DEC   [0x3E]             (0096)    dec  [SleepTimer_1_bCountDown]
                                        (0097) 
                                        (0098) .DoTimer:                                       ; Decrement TimerValue, if required
1197: 47 3D FF TST   [0x3D],0xFF        (0099)    tst  [SleepTimer_1_bTimerValue],0xFF
119A: A0 03    JZ    0x119E             (0100)    jz   .IncBigCounter
119C: 7A 3D    DEC   [0x3D]             (0101)    dec  [SleepTimer_1_bTimerValue]
                                        (0102) 
                                        (0103) .IncBigCounter:                                 ; Increment big tick counter
                                        (0104) IF (SleepTimer_1_TICK_CNTR_SIZE & 0x04)
119E: 76 42    INC   [0x42]             (0105)    inc  [SleepTimer_1_TickCount+3]
11A0: D0 0B    JNC   0x11AC             (0106)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0107) 
11A2: 76 41    INC   [0x41]             (0108)    inc  [SleepTimer_1_TickCount+2]
11A4: D0 07    JNC   0x11AC             (0109)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0110) ENDIF
                                        (0111) 
                                        (0112) IF (SleepTimer_1_TICK_CNTR_SIZE & (0x04|0x02))
11A6: 76 40    INC   [0x40]             (0113)    inc  [SleepTimer_1_TickCount+1]
11A8: D0 03    JNC   0x11AC             (0114)    jnc  SleepTimer_1_SLEEP_ISR_END
                                        (0115) ENDIF
                                        (0116) 
11AA: 76 3F    INC   [0x3F]             (0117)    inc  [SleepTimer_1_TickCount+0]
                                        (0118) 
                                        (0119) SleepTimer_1_SLEEP_ISR_END:
                                        (0120) 
                                        (0121)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0122)    ;---------------------------------------------------
                                        (0123)    ; Insert your custom assembly code below this banner
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ;   NOTE: interrupt service routines must preserve
                                        (0126)    ;   the values of the A and X CPU registers.
                                        (0127)    
                                        (0128)    ;---------------------------------------------------
                                        (0129)    ; Insert your custom assembly code above this banner
                                        (0130)    ;---------------------------------------------------
                                        (0131)    
                                        (0132)    ;---------------------------------------------------
                                        (0133)    ; Insert a lcall to a C function below this banner
                                        (0134)    ; and un-comment the lines between these banners
                                        (0135)    ;---------------------------------------------------
                                        (0136)    
                                        (0137)    ;PRESERVE_CPU_CONTEXT
                                        (0138)    ;lcall _My_C_Function
11AC: 7C 16 F1 LCALL _SleepTimer_1_ISRV (0139)    lcall _SleepTimer_1_ISRV
                                        (0140)    ;RESTORE_CPU_CONTEXT
                                        (0141)    
                                        (0142)    ;---------------------------------------------------
                                        (0143)    ; Insert a lcall to a C function above this banner
                                        (0144)    ; and un-comment the lines between these banners
                                        (0145)    ;---------------------------------------------------
                                        (0146)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0147) 
11AF: 7E       RETI                     (0148)    reti
                                        (0149) 
                                        (0150) ; end of file SleepTimer_1INT.asm
                                        (0151) 
FILE: lib\sleeptimer_1.asm              (0001) ;;*****************************************************************************
11B0: 43 E0 40 OR    REG[0xE0],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  Filename:   SleepTimer_1.asm
                                        (0004) ;;  Version: 1.0, Updated on 2013/5/19 at 10:44:14
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  SleepTimer User Module software implementation file for the
                                        (0008) ;;                22/24/27/29xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "SleepTimer_1.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name reference for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  SleepTimer_1_EnableInt
                                        (0041) export _SleepTimer_1_EnableInt
                                        (0042) export  SleepTimer_1_DisableInt
                                        (0043) export _SleepTimer_1_DisableInt
                                        (0044) 
                                        (0045) export  SleepTimer_1_Start
                                        (0046) export _SleepTimer_1_Start
                                        (0047) export  SleepTimer_1_Stop
                                        (0048) export _SleepTimer_1_Stop
                                        (0049) 
                                        (0050) export  SleepTimer_1_TickWait
                                        (0051) export _SleepTimer_1_TickWait
                                        (0052) 
                                        (0053) export  SleepTimer_1_SyncWait
                                        (0054) export _SleepTimer_1_SyncWait
                                        (0055) 
                                        (0056) export  SleepTimer_1_SetInterval
                                        (0057) export _SleepTimer_1_SetInterval
                                        (0058) 	
                                        (0059) export  SleepTimer_1_bGetTickCntr
                                        (0060) export _SleepTimer_1_bGetTickCntr
                                        (0061) 
                                        (0062) export  SleepTimer_1_SetTimer
                                        (0063) export _SleepTimer_1_SetTimer
                                        (0064) 
                                        (0065) export  SleepTimer_1_bGetTimer
                                        (0066) export _SleepTimer_1_bGetTimer
                                        (0067) 
                                        (0068) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0069) export  SleepTimer_1_iGetTickCntr
                                        (0070) export _SleepTimer_1_iGetTickCntr
                                        (0071) ENDIF
                                        (0072) 
                                        (0073) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0074) export  SleepTimer_1_lGetTickCntr
                                        (0075) export _SleepTimer_1_lGetTickCntr
                                        (0076) ENDIF
                                        (0077) 
                                        (0078) 
                                        (0079) area text (ROM,REL)
                                        (0080) 
                                        (0081) ;-----------------------------------------------
                                        (0082) ;  EQUATES
                                        (0083) ;-----------------------------------------------
                                        (0084) 
                                        (0085) ; Counter LSB Offset if 4 byte tick counter
                                        (0086) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0087) ST_LSB_OFFSET:   equ  3
                                        (0088) ENDIF
                                        (0089) 
                                        (0090) ; Counter LSB Offset if 2 byte tick counter
                                        (0091) IF(SleepTimer_1_TICK_CNTR_SIZE & 2)
                                        (0092) ST_LSB_OFFSET:   equ  1
                                        (0093) ENDIF
                                        (0094) 
                                        (0095) ; Counter LSB Offset if 1 byte tick counter
                                        (0096) IF(SleepTimer_1_TICK_CNTR_SIZE & 1)
                                        (0097) ST_LSB_OFFSET:   equ  0
                                        (0098) ENDIF
                                        (0099) 
                                        (0100) 
                                        (0101) area UserModules (ROM, REL, CON)
                                        (0102) 
                                        (0103) ;=============================================================================
                                        (0104) ;=============================================================================
                                        (0105) ;
                                        (0106) ;     Low-Level Commands
                                        (0107) ;
                                        (0108) ;=============================================================================
                                        (0109) ;=============================================================================
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: SleepTimer_1_EnableInt
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Enables SleepTimer interrupts.
                                        (0117) ;-----------------------------------------------------------------------------
                                        (0118) ;
                                        (0119) ;  ARGUMENTS:
                                        (0120) ;     none.
                                        (0121) ;
                                        (0122) ;  RETURNS:
                                        (0123) ;     none.
                                        (0124) ;
                                        (0125) ;  SIDE EFFECTS:
                                        (0126) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0127) ;
                                        (0128) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0129) ;
                                        (0130)  SleepTimer_1_EnableInt:
                                        (0131) _SleepTimer_1_EnableInt:
                                        (0132)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0133)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0134)    RAM_EPILOGUE RAM_USE_CLASS_1
11B3: 7F       RET                      (0135)    ret
11B4: 41 E0 BF AND   REG[0xE0],0xBF     
                                        (0136) .ENDSECTION
                                        (0137) 
                                        (0138)     
                                        (0139) .SECTION
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;  FUNCTION NAME: SleepTimer_1_DisableInt
                                        (0142) ;
                                        (0143) ;  DESCRIPTION:
                                        (0144) ;     Disables the sleep timer. 
                                        (0145) ;
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     none.
                                        (0150) ;
                                        (0151) ;  RETURNS:
                                        (0152) ;     none.
                                        (0153) ;
                                        (0154) ;  SIDE EFFECTS:
                                        (0155) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0156) ;
                                        (0157) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0158) ;
                                        (0159)  SleepTimer_1_DisableInt:
                                        (0160) _SleepTimer_1_DisableInt:
                                        (0161)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0162)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0163)    RAM_EPILOGUE RAM_USE_CLASS_1
11B7: 7F       RET                      (0164)    ret
11B8: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0165) .ENDSECTION
                                        (0166) 
                                        (0167) 
                                        (0168) .SECTION
                                        (0169) ;-----------------------------------------------------------------------------
                                        (0170) ;  FUNCTION NAME: SleepTimer_1_Start()
                                        (0171) ;
                                        (0172) ;  DESCRIPTION:
                                        (0173) ;     Clears all the variables.  
                                        (0174) ;-----------------------------------------------------------------------------
                                        (0175) ;
                                        (0176) ;  ARGUMENTS:
                                        (0177) ;      none
                                        (0178) ;
                                        (0179) ;  RETURNS:
                                        (0180) ;     none.
                                        (0181) ;
                                        (0182) ;  SIDE EFFECTS;    
                                        (0183) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0184) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0185) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0186) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0187) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0188) ;          
                                        (0189) ;    Page Pointer Registers Modified: 
                                        (0190) ;          CUR_PP
                                        (0191) ;
                                        (0192) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0193) ;
                                        (0194)  SleepTimer_1_Start:
                                        (0195) _SleepTimer_1_Start:
                                        (0196)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0197)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
11BB: 50 00    MOV   A,0x0              (0198)    mov  A,0
11BD: 53 3C    MOV   [0x3C],A           (0199)    mov  [SleepTimer_1_fTick],A
11BF: 53 3D    MOV   [0x3D],A           (0200)    mov  [SleepTimer_1_bTimerValue],A
11C1: 53 3E    MOV   [0x3E],A           (0201)    mov  [SleepTimer_1_bCountDown],A
11C3: 53 42    MOV   [0x42],A           (0202)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET],A        ; Clear TickCount[0:7]
                                        (0203) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
11C5: 53 41    MOV   [0x41],A           (0204)    mov  [SleepTimer_1_TickCount + ST_LSB_OFFSET - 1],A    ; Clear TickCount[8:15]
                                        (0205) ENDIF
                                        (0206) 
                                        (0207) 
                                        (0208) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
11C7: 53 40    MOV   [0x40],A           (0209)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 2],A    ; Clear TickCount[16:31]
11C9: 53 3F    MOV   [0x3F],A           (0210)    mov   [SleepTimer_1_TickCount + ST_LSB_OFFSET - 3],A    
                                        (0211) ENDIF
                                        (0212) 
                                        (0213) 
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_4
11CB: 7F       RET                      (0215)    ret
                                        (0216) .ENDSECTION
                                        (0217) 
                                        (0218) 
                                        (0219) .SECTION
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;  FUNCTION NAME: SleepTimer_1_Stop
                                        (0222) ;
                                        (0223) ;  DESCRIPTION:
                                        (0224) ;   This function does nothing at this time.  It is only here as a place 
                                        (0225) ;   holder.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;
                                        (0228) ;  ARGUMENTS:
                                        (0229) ;     none.
                                        (0230) ;
                                        (0231) ;  RETURNS:
                                        (0232) ;     none.
                                        (0233) ;
                                        (0234) ;  SIDE EFFECTS:
                                        (0235) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0236) ;
                                        (0237) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0238) ;
                                        (0239)  SleepTimer_1_Stop:
                                        (0240) _SleepTimer_1_Stop:
                                        (0241)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0242)    RAM_EPILOGUE RAM_USE_CLASS_1
11CC: 7F       RET                      (0243)    ret
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: SleepTimer_1_SetInterval
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Sets sleep timer interval
                                        (0252) ;
                                        (0253) ;-----------------------------------------------------------------------------
                                        (0254) ;
                                        (0255) ;  ARGUMENTS:
                                        (0256) ;     A <= Timer setting
                                        (0257) ;
                                        (0258) ;  RETURNS:
                                        (0259) ;     none.
                                        (0260) ;
                                        (0261) ;  SIDE EFFECTS:
                                        (0262) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0263) ;
                                        (0264) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0265) ;
                                        (0266)  SleepTimer_1_SetInterval:
                                        (0267) _SleepTimer_1_SetInterval:
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_2
11CD: 21 18    AND   A,0x18             (0269)    and  A,SleepTimer_1_CLOCK_MASK               ; Mask off invalid data
11CF: 4F       MOV   X,SP               (0270)    mov  X, SP
11D0: 08       PUSH  A                  (0271)    push A
11D1: 71 10    OR    F,0x10             
                                        (0272)    M8C_SetBank1
11D3: 5D E0    MOV   A,REG[0xE0]        (0273)    mov  A, reg[OSC_CR0]                  ; Get current timer value
11D5: 21 E7    AND   A,0xE7             (0274)    and  A,~SleepTimer_1_CLOCK_MASK   ; Zero out old timer value
11D7: 2B 00    OR    A,[X+0]            (0275)    or   A, [X]                           ; Set new timer values
11D9: 60 E0    MOV   REG[0xE0],A        (0276)    mov  reg[OSC_CR0],A                   ; Write it
11DB: 70 EF    AND   F,0xEF             
                                        (0277)    M8C_SetBank0
11DD: 18       POP   A                  (0278)    pop  A
11DE: 70 3F    AND   F,0x3F             
11E0: 71 C0    OR    F,0xC0             
                                        (0279)    RAM_EPILOGUE RAM_USE_CLASS_2
11E2: 7F       RET                      (0280)    ret
11E3: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0281) .ENDSECTION
                                        (0282) 
                                        (0283) 
                                        (0284) .SECTION
                                        (0285) ;-----------------------------------------------------------------------------
                                        (0286) ;  FUNCTION NAME: SleepTimer_1_TickWait(BYTE bTicks)
                                        (0287) ;
                                        (0288) ;  DESCRIPTION:
                                        (0289) ;     Wait X Ticks and return
                                        (0290) ;
                                        (0291) ;-----------------------------------------------------------------------------
                                        (0292) ;
                                        (0293) ;  ARGUMENTS:
                                        (0294) ;     A <= Count down time
                                        (0295) ;
                                        (0296) ;  RETURNS:
                                        (0297) ;     none.
                                        (0298) ;
                                        (0299) ;  SIDE EFFECTS;    
                                        (0300) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0301) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0302) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0303) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0304) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0305) ;          
                                        (0306) ;    Page Pointer Registers Modified: 
                                        (0307) ;          CUR_PP
                                        (0308) ;
                                        (0309) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0310) ;
                                        (0311)  SleepTimer_1_TickWait:
                                        (0312) _SleepTimer_1_TickWait:
                                        (0313)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0314)    RAM_SETPAGE_CUR >SleepTimer_1_fTick      
11E6: 55 3C 00 MOV   [0x3C],0x0         (0315)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
                                        (0316) 
                                        (0317) .WaitTick:
11E9: 47 3C FF TST   [0x3C],0xFF        (0318)    tst   [SleepTimer_1_fTick],0xFF          ; Check for tick 
11EC: AF FC    JZ    0x11E9             (0319)    jz    .WaitTick
11EE: 55 3C 00 MOV   [0x3C],0x0         (0320)    mov   [SleepTimer_1_fTick],0x00          ; Clear tick flag
11F1: 78       DEC   A                  (0321)    dec   A                                      ; Dec the timer variable
11F2: BF F6    JNZ   0x11E9             (0322)    jnz   .WaitTick                              ; Loop until we count down to zero
                                        (0323) 
                                        (0324)    RAM_EPILOGUE RAM_USE_CLASS_4
11F4: 7F       RET                      (0325)    ret
11F5: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0326) .ENDSECTION
                                        (0327) 
                                        (0328) 
                                        (0329) .SECTION
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: SleepTimer_1_SyncWait(BYTE bCounts, BYTE fMode)
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:
                                        (0334) ;     This function resets the SyncWait timer.  If fMode = 0, the timer
                                        (0335) ;     is set to the new value then exits the function immediatly.  If fMode
                                        (0336) ;     is set to 1, the firmware waits for the timer to expire before the
                                        (0337) ;     timer is reset and and exits.
                                        (0338) ;
                                        (0339) ;-----------------------------------------------------------------------------
                                        (0340) ;
                                        (0341) ;  ARGUMENTS:
                                        (0342) ;     A <= tCounts to wait
                                        (0343) ;     X <= fMode    fMode = 0  Just reload the value, do not wait
                                        (0344) ;                   fMode = 1  Wait for last value to count down to zero
                                        (0345) ;                              then reload.
                                        (0346) ;
                                        (0347) ;  RETURNS:
                                        (0348) ;     none.
                                        (0349) ;
                                        (0350) ;  SIDE EFFECTS;    
                                        (0351) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0352) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0353) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0354) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0355) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0356) ;          
                                        (0357) ;    Page Pointer Registers Modified: 
                                        (0358) ;          CUR_PP
                                        (0359) ;
                                        (0360) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0361) ;
                                        (0362)  SleepTimer_1_SyncWait:
                                        (0363) _SleepTimer_1_SyncWait:
                                        (0364)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0365)    RAM_SETPAGE_CUR >SleepTimer_1_bCountDown
11F8: 4B       SWAP  A,X                (0366)    swap  A,X
11F9: 21 01    AND   A,0x1              (0367)    AND   A,SleepTimer_1_FORCE_RELOAD
11FB: B0 06    JNZ   0x1202             (0368)    jnz   .ReloadIt
                                        (0369) 
                                        (0370) .WaitLoop:
11FD: 47 3E FF TST   [0x3E],0xFF        (0371)    tst   [SleepTimer_1_bCountDown],0xFF
1200: BF FC    JNZ   0x11FD             (0372)    jnz   .WaitLoop
                                        (0373) 
                                        (0374) 
                                        (0375) .ReloadIt:
1202: 4B       SWAP  A,X                (0376)    swap  A,X
1203: 53 3E    MOV   [0x3E],A           (0377)    mov   [SleepTimer_1_bCountDown],A 
                                        (0378) 
                                        (0379)    RAM_EPILOGUE RAM_USE_CLASS_4
1205: 7F       RET                      (0380)    ret
1206: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) 
                                        (0384) 
                                        (0385) .SECTION
                                        (0386) ;-----------------------------------------------------------------------------
                                        (0387) ;  FUNCTION NAME: SleepTimer_1_bGetTickCntr
                                        (0388) ;
                                        (0389) ;  DESCRIPTION:
                                        (0390) ;     Returns the LSB of the tick Counter
                                        (0391) ;
                                        (0392) ;-----------------------------------------------------------------------------
                                        (0393) ;
                                        (0394) ;  ARGUMENTS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  RETURNS:
                                        (0398) ;     LSB of lTickCount
                                        (0399) ;
                                        (0400) ;  SIDE EFFECTS;    
                                        (0401) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0402) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0403) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0404) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0405) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0406) ;          
                                        (0407) ;    Page Pointer Registers Modified: 
                                        (0408) ;          CUR_PP
                                        (0409) ;
                                        (0410) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0411) ;
                                        (0412)  SleepTimer_1_bGetTickCntr:
                                        (0413) _SleepTimer_1_bGetTickCntr:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0415)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
1209: 51 42    MOV   A,[0x42]           (0416)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]
                                        (0417)    RAM_EPILOGUE RAM_USE_CLASS_4
120B: 7F       RET                      (0418)    ret
120C: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) .SECTION
                                        (0422) ;-----------------------------------------------------------------------------
                                        (0423) ;  FUNCTION NAME: SleepTimer_1_SetTimer
                                        (0424) ;
                                        (0425) ;  DESCRIPTION:
                                        (0426) ;     Set timer with parameter in A
                                        (0427) ;
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;
                                        (0430) ;  ARGUMENTS:
                                        (0431) ;     A => Value used to set Timer value
                                        (0432) ;
                                        (0433) ;  RETURNS:
                                        (0434) ;     None
                                        (0435) ;
                                        (0436) ;  SIDE EFFECTS;    
                                        (0437) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0438) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0439) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0440) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0441) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0442) ;          
                                        (0443) ;    Page Pointer Registers Modified: 
                                        (0444) ;          CUR_PP
                                        (0445) ;
                                        (0446) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0447) ;
                                        (0448)  SleepTimer_1_SetTimer:
                                        (0449) _SleepTimer_1_SetTimer:
                                        (0450)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0451)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
120F: 53 3D    MOV   [0x3D],A           (0452)    mov   [SleepTimer_1_bTimerValue],A
                                        (0453)    RAM_EPILOGUE RAM_USE_CLASS_4
1211: 7F       RET                      (0454)    ret
1212: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0455) .ENDSECTION
                                        (0456) 
                                        (0457) .SECTION
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: SleepTimer_1_bGetTimer
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:
                                        (0462) ;     Returns timer value in A
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;     None
                                        (0468) ;
                                        (0469) ;  RETURNS:
                                        (0470) ;     Return timer value in A
                                        (0471) ;
                                        (0472) ;  SIDE EFFECTS;    
                                        (0473) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0474) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0475) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0476) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0477) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0478) ;          
                                        (0479) ;    Page Pointer Registers Modified: 
                                        (0480) ;          CUR_PP
                                        (0481) ;
                                        (0482) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0483) ;
                                        (0484)  SleepTimer_1_bGetTimer:
                                        (0485) _SleepTimer_1_bGetTimer:
                                        (0486)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0487)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
1215: 51 3D    MOV   A,[0x3D]           (0488)    mov   A,[SleepTimer_1_bTimerValue]
                                        (0489)    RAM_EPILOGUE RAM_USE_CLASS_4
1217: 7F       RET                      (0490)    ret
1218: 62 D0 00 MOV   REG[0xD0],0x0      
121B: 41 E0 BF AND   REG[0xE0],0xBF     
                                        (0491) .ENDSECTION
                                        (0492) 
                                        (0493) IF(SleepTimer_1_TICK_CNTR_SIZE & (4|2))
                                        (0494) .SECTION
                                        (0495) ;-----------------------------------------------------------------------------
                                        (0496) ;  FUNCTION NAME: SleepTimer_1_iGetTickCntr
                                        (0497) ;
                                        (0498) ;  DESCRIPTION:
                                        (0499) ;     Returns the least significant 16 bits.
                                        (0500) ;
                                        (0501) ;-----------------------------------------------------------------------------
                                        (0502) ;
                                        (0503) ;  ARGUMENTS:
                                        (0504) ;     none
                                        (0505) ;
                                        (0506) ;  RETURNS:
                                        (0507) ;     (int)TickCount in A and X  
                                        (0508) ;     X  <= MSB
                                        (0509) ;     A  <= LSB
                                        (0510) ;
                                        (0511) ;  SIDE EFFECTS;    
                                        (0512) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0513) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0514) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0515) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0516) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0517) ;          
                                        (0518) ;    Page Pointer Registers Modified: 
                                        (0519) ;          CUR_PP
                                        (0520) ;
                                        (0521) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0522) ;
                                        (0523)  SleepTimer_1_iGetTickCntr:
                                        (0524) _SleepTimer_1_iGetTickCntr:
                                        (0525)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0526)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0527)    ; Disable interrupt here
                                        (0528)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
121E: 51 42    MOV   A,[0x42]           (0529)    mov   A,[SleepTimer_1_TickCount + ST_LSB_OFFSET]    ; Place LSB in A
1220: 58 41    MOV   X,[0x41]           (0530)    mov   X,[SleepTimer_1_TickCount + ST_LSB_OFFSET - 1]    ; Place MSB in X
1222: 43 E0 40 OR    REG[0xE0],0x40     
                                        (0531)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0532)    RAM_EPILOGUE RAM_USE_CLASS_4
1225: 7F       RET                      (0533)    ret
1226: 70 BF    AND   F,0xBF             
1228: 41 E0 BF AND   REG[0xE0],0xBF     
122B: 62 D0 00 MOV   REG[0xD0],0x0      
122E: 60 D3    MOV   REG[0xD3],A        
                                        (0534) .ENDSECTION
                                        (0535) ENDIF
                                        (0536) 
                                        (0537) IF(SleepTimer_1_TICK_CNTR_SIZE & 4)
                                        (0538) .SECTION
                                        (0539) ;-----------------------------------------------------------------------------
                                        (0540) ;  FUNCTION NAME: SleepTimer_1_lGetTickCntr
                                        (0541) ;
                                        (0542) ;  DESCRIPTION:
                                        (0543) ;     Returns a pointer to TickCount
                                        (0544) ;
                                        (0545) ;-----------------------------------------------------------------------------
                                        (0546) ;
                                        (0547) ;  ARGUMENTS:
                                        (0548) ;     [A:X] => Pointer to 32 bit tick counter (X=LSB, A=MSB)
                                        (0549) ;
                                        (0550) ;  RETURNS:
                                        (0551) ;     Pointer to lTickCount
                                        (0552) ;
                                        (0553) ;  SIDE EFFECTS;    
                                        (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0555) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0556) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0557) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0558) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0559) ;          
                                        (0560) ;    Page Pointer Registers Modified: 
                                        (0561) ;          CUR_PP
                                        (0562) ;
                                        (0563) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0564) ;
                                        (0565)  SleepTimer_1_lGetTickCntr:
                                        (0566) _SleepTimer_1_lGetTickCntr:
                                        (0567)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0568)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0569)    ; Disable interrupt here
                                        (0570)    M8C_DisableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0571)    RAM_SETPAGE_CUR >SleepTimer_1_TickCount
                                        (0572)    RAM_SETPAGE_IDX A
1230: 08       PUSH  A                  (0573)    push  A
1231: 51 3F    MOV   A,[0x3F]           (0574)    mov   A,[SleepTimer_1_TickCount + 0]
1233: 54 00    MOV   [X+0],A            (0575)    mov   [X + 0],A
1235: 51 40    MOV   A,[0x40]           (0576)    mov   A,[SleepTimer_1_TickCount + 1]
1237: 54 01    MOV   [X+1],A            (0577)    mov   [X + 1],A
1239: 51 41    MOV   A,[0x41]           (0578)    mov   A,[SleepTimer_1_TickCount + 2]
123B: 54 02    MOV   [X+2],A            (0579)    mov   [X + 2],A
123D: 51 42    MOV   A,[0x42]           (0580)    mov   A,[SleepTimer_1_TickCount + 3]
123F: 54 03    MOV   [X+3],A            (0581)    mov   [X + 3],A
1241: 18       POP   A                  (0582)    pop   A
1242: 43 E0 40 OR    REG[0xE0],0x40     
1245: 70 3F    AND   F,0x3F             
1247: 71 C0    OR    F,0xC0             
                                        (0583)    
                                        (0584)    M8C_EnableIntMask SleepTimer_1_INT_REG, SleepTimer_1_INT_MASK
                                        (0585)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_EPILOGUE RAM_USE_CLASS_3
1249: 7F       RET                      (0587)    ret
                                        (0588) .ENDSECTION
                                        (0589) ENDIF
                                        (0590) 
                                        (0591) 
                                        (0592) 
                                        (0593) 
                                        (0594) ; End of File SleepTimer_1.asm
FILE: lib\led_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_1.asm
                                        (0004) ;;  Version: 1.40, Updated on 2013/5/19 at 10:43:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_1_Start
                                        (0027) export  LED_1_Start
                                        (0028) 
                                        (0029) export _LED_1_Stop
                                        (0030) export  LED_1_Stop
                                        (0031) 
                                        (0032) export _LED_1_On
                                        (0033) export  LED_1_On
                                        (0034) 
                                        (0035) export _LED_1_Off
                                        (0036) export  LED_1_Off
                                        (0037) 
                                        (0038) export _LED_1_Switch
                                        (0039) export  LED_1_Switch
                                        (0040) 
                                        (0041) export _LED_1_Invert
                                        (0042) export  LED_1_Invert
                                        (0043) 
                                        (0044) export _LED_1_GetState
                                        (0045) export  LED_1_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_1_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_1_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_1_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_1_On:
                                        (0079)  LED_1_On:
124A: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
124C: 80 03    JMP   _LED_1_Switch      (0081)    jmp  LED_1_Switch 
                                        (0082) 
                                        (0083) _LED_1_Start:
                                        (0084)  LED_1_Start:
                                        (0085) _LED_1_Stop:
                                        (0086)  LED_1_Stop:
                                        (0087) _LED_1_Off:
                                        (0088)  LED_1_Off:
124E: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
1250: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0090) 
                                        (0091) _LED_1_Switch:
                                        (0092)  LED_1_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0096) 
1253: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
1255: A0 06    JZ    0x125C             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(1)                                            ; Active High Digit Drive
1257: 2E 43 08 OR    [0x43],0x8         (0102)    or   [Port_1_Data_SHADE],LED_1_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
                                        (0104)    and  [Port_1_Data_SHADE],~LED_1_PinMask
                                        (0105) ENDIF
125A: 80 04    JMP   0x125F             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(1)                      ; Active High Digit Drive
125C: 26 43 F7 AND   [0x43],0xF7        (0110)    and  [Port_1_Data_SHADE],~LED_1_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
                                        (0112)    or   [Port_1_Data_SHADE],LED_1_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
125F: 51 43    MOV   A,[0x43]           (0116)    mov  A,[Port_1_Data_SHADE]
1261: 60 04    MOV   REG[0x4],A         (0117)    mov  reg[LED_1_PortDR],A
1263: 70 3F    AND   F,0x3F             
1265: 71 C0    OR    F,0xC0             
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
1267: 7F       RET                      (0121)    ret
1268: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_1_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_1_Invert:
                                        (0144)  LED_1_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0148) 
126B: 36 43 08 XOR   [0x43],0x8         (0149)    xor  [Port_1_Data_SHADE],LED_1_PinMask
126E: 51 43    MOV   A,[0x43]           (0150)    mov  A,[Port_1_Data_SHADE]
1270: 60 04    MOV   REG[0x4],A         (0151)    mov  reg[LED_1_PortDR],A
1272: 70 3F    AND   F,0x3F             
1274: 71 C0    OR    F,0xC0             
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
1276: 7F       RET                      (0155)    ret
1277: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_1_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_1_GetState:
                                        (0177)  LED_1_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_1_Data_SHADE
                                        (0181) 
127A: 51 43    MOV   A,[0x43]           (0182)    mov   A,[Port_1_Data_SHADE]         ; Get shade value
                                        (0183) IF(1)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
127C: 21 08    AND   A,0x8              (0188)    and   A,LED_1_PinMask               ; Mask off the trash
127E: A0 03    JZ    0x1282             (0189)    jz    .End_LED_GS                   ; If zero, we're done
1280: 50 01    MOV   A,0x1              (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
1282: 70 3F    AND   F,0x3F             
1284: 71 C0    OR    F,0xC0             
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
1286: 7F       RET                      (0195)    ret
FILE: lib\counter8_1int.asm             (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Counter8_1INT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2013/5/19 at 10:42:36
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Counter8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Counter8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Counter8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Counter8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
1287: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Counter8_1INT.asm
FILE: lib\counter8_1.asm                (0001) ;;*****************************************************************************
1288: 43 E1 01 OR    REG[0xE1],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Counter8_1.asm
                                        (0004) ;;   Version: 2.60, Updated on 2013/5/19 at 10:42:36
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Counter8_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Counter8_1_EnableInt
                                        (0030) export _Counter8_1_EnableInt
                                        (0031) export  Counter8_1_DisableInt
                                        (0032) export _Counter8_1_DisableInt
                                        (0033) export  Counter8_1_Start
                                        (0034) export _Counter8_1_Start
                                        (0035) export  Counter8_1_Stop
                                        (0036) export _Counter8_1_Stop
                                        (0037) export  Counter8_1_WritePeriod
                                        (0038) export _Counter8_1_WritePeriod
                                        (0039) export  Counter8_1_WriteCompareValue
                                        (0040) export _Counter8_1_WriteCompareValue
                                        (0041) export  Counter8_1_bReadCompareValue
                                        (0042) export _Counter8_1_bReadCompareValue
                                        (0043) export  Counter8_1_bReadCounter
                                        (0044) export _Counter8_1_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bCounter8_1_ReadCompareValue  ; deprecated
                                        (0049) export _bCounter8_1_ReadCompareValue  ; deprecated
                                        (0050) export  bCounter8_1_ReadCounter       ; deprecated
                                        (0051) export _bCounter8_1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ;  Constant Definitions
                                        (0055) ;-----------------------------------------------
                                        (0056) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0057) 
                                        (0058) 
                                        (0059) AREA UserModules (ROM, REL)
                                        (0060) 
                                        (0061) .SECTION
                                        (0062) ;-----------------------------------------------------------------------------
                                        (0063) ;  FUNCTION NAME: Counter8_1_EnableInt
                                        (0064) ;
                                        (0065) ;  DESCRIPTION:
                                        (0066) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
                                        (0067) ;     associated with this User Module. This function has no effect until and
                                        (0068) ;     unless the global interrupts are enabled (for example by using the
                                        (0069) ;     macro M8C_EnableGInt).
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;
                                        (0072) ;  ARGUMENTS:    None.
                                        (0073) ;  RETURNS:      Nothing.
                                        (0074) ;  SIDE EFFECTS: 
                                        (0075) ;    The A and X registers may be modified by this or future implementations
                                        (0076) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0077) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0078) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0079) ;    functions.
                                        (0080) ;
                                        (0081)  Counter8_1_EnableInt:
                                        (0082) _Counter8_1_EnableInt:
                                        (0083)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0084)    Counter8_1_EnableInt_M
                                        (0085)    RAM_EPILOGUE RAM_USE_CLASS_1
128B: 7F       RET                      (0086)    ret
128C: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0087) 
                                        (0088) .ENDSECTION
                                        (0089) 
                                        (0090) .SECTION
                                        (0091) ;-----------------------------------------------------------------------------
                                        (0092) ;  FUNCTION NAME: Counter8_1_DisableInt
                                        (0093) ;
                                        (0094) ;  DESCRIPTION:
                                        (0095) ;     Disables this counter's interrupt by clearing the interrupt enable
                                        (0096) ;     mask bit associated with this User Module.
                                        (0097) ;-----------------------------------------------------------------------------
                                        (0098) ;
                                        (0099) ;  ARGUMENTS:    None
                                        (0100) ;  RETURNS:      Nothing
                                        (0101) ;  SIDE EFFECTS: 
                                        (0102) ;    The A and X registers may be modified by this or future implementations
                                        (0103) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0104) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0105) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0106) ;    functions.
                                        (0107) ;
                                        (0108)  Counter8_1_DisableInt:
                                        (0109) _Counter8_1_DisableInt:
                                        (0110)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0111)    Counter8_1_DisableInt_M
                                        (0112)    RAM_EPILOGUE RAM_USE_CLASS_1
128F: 7F       RET                      (0113)    ret
1290: 43 23 01 OR    REG[0x23],0x1      
                                        (0114) 
                                        (0115) 
                                        (0116) .ENDSECTION
                                        (0117) 
                                        (0118) .SECTION
                                        (0119) ;-----------------------------------------------------------------------------
                                        (0120) ;  FUNCTION NAME: Counter8_1_Start
                                        (0121) ;
                                        (0122) ;  DESCRIPTION:
                                        (0123) ;     Sets the start bit in the Control register of this user module.  The
                                        (0124) ;     counter will begin counting on the next input clock as soon as the
                                        (0125) ;     enable input is asserted high.
                                        (0126) ;-----------------------------------------------------------------------------
                                        (0127) ;
                                        (0128) ;  ARGUMENTS:    None
                                        (0129) ;  RETURNS:      Nothing
                                        (0130) ;  SIDE EFFECTS: 
                                        (0131) ;    The A and X registers may be modified by this or future implementations
                                        (0132) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0133) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0134) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0135) ;    functions.
                                        (0136) ;
                                        (0137)  Counter8_1_Start:
                                        (0138) _Counter8_1_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0140)    Counter8_1_Start_M
                                        (0141)    RAM_EPILOGUE RAM_USE_CLASS_1
1293: 7F       RET                      (0142)    ret
1294: 41 23 FE AND   REG[0x23],0xFE     
                                        (0143) 
                                        (0144) 
                                        (0145) .ENDSECTION
                                        (0146) 
                                        (0147) .SECTION
                                        (0148) ;-----------------------------------------------------------------------------
                                        (0149) ;  FUNCTION NAME: Counter8_1_Stop
                                        (0150) ;
                                        (0151) ;  DESCRIPTION:
                                        (0152) ;     Disables counter operation by clearing the start bit in the Control
                                        (0153) ;     register.
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;
                                        (0156) ;  ARGUMENTS:    None
                                        (0157) ;  RETURNS:      Nothing
                                        (0158) ;  SIDE EFFECTS: 
                                        (0159) ;    The A and X registers may be modified by this or future implementations
                                        (0160) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0161) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0162) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0163) ;    functions.
                                        (0164) ;
                                        (0165)  Counter8_1_Stop:
                                        (0166) _Counter8_1_Stop:
                                        (0167)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0168)    Counter8_1_Stop_M
                                        (0169)    RAM_EPILOGUE RAM_USE_CLASS_1
1297: 7F       RET                      (0170)    ret
                                        (0171) 
                                        (0172) 
                                        (0173) .ENDSECTION
                                        (0174) 
                                        (0175) .SECTION
                                        (0176) ;-----------------------------------------------------------------------------
                                        (0177) ;  FUNCTION NAME: Counter8_1_WritePeriod
                                        (0178) ;
                                        (0179) ;  DESCRIPTION:
                                        (0180) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0181) ;-----------------------------------------------------------------------------
                                        (0182) ;
                                        (0183) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0184) ;  RETURNS:   Nothing
                                        (0185) ;  SIDE EFFECTS:
                                        (0186) ;    If the counter user module is stopped, then this value will also be
                                        (0187) ;    latched into the Count register (DR0).
                                        (0188) ;     
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195)  Counter8_1_WritePeriod:
                                        (0196) _Counter8_1_WritePeriod:
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_1
1298: 60 21    MOV   REG[0x21],A        (0198)    mov   reg[Counter8_1_PERIOD_REG], A
                                        (0199)    RAM_EPILOGUE RAM_USE_CLASS_1
129A: 7F       RET                      (0200)    ret
                                        (0201) 
                                        (0202) 
                                        (0203) .ENDSECTION
                                        (0204) 
                                        (0205) .SECTION
                                        (0206) ;-----------------------------------------------------------------------------
                                        (0207) ;  FUNCTION NAME: Counter8_1_WriteCompareValue
                                        (0208) ;
                                        (0209) ;  DESCRIPTION:
                                        (0210) ;     Writes compare value into the Compare register (DR2).
                                        (0211) ;-----------------------------------------------------------------------------
                                        (0212) ;
                                        (0213) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0214) ;  RETURNS:      Nothing
                                        (0215) ;  SIDE EFFECTS: 
                                        (0216) ;    The A and X registers may be modified by this or future implementations
                                        (0217) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0218) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0219) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0220) ;    functions.
                                        (0221) ;
                                        (0222)  Counter8_1_WriteCompareValue:
                                        (0223) _Counter8_1_WriteCompareValue:
                                        (0224)    RAM_PROLOGUE RAM_USE_CLASS_1
129B: 60 22    MOV   REG[0x22],A        (0225)    mov   reg[Counter8_1_COMPARE_REG], A
                                        (0226)    RAM_EPILOGUE RAM_USE_CLASS_1
129D: 7F       RET                      (0227)    ret
                                        (0228) 
                                        (0229) 
                                        (0230) .ENDSECTION
                                        (0231) 
                                        (0232) .SECTION
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) ;  FUNCTION NAME: Counter8_1_bReadCompareValue
                                        (0235) ;
                                        (0236) ;  DESCRIPTION:
                                        (0237) ;     Reads the Compare register.
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) ;
                                        (0240) ;  ARGUMENTS:    None
                                        (0241) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0242) ;  SIDE EFFECTS: 
                                        (0243) ;    The A and X registers may be modified by this or future implementations
                                        (0244) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0245) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0246) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0247) ;    functions.
                                        (0248) ;
                                        (0249)  Counter8_1_bReadCompareValue:
                                        (0250) _Counter8_1_bReadCompareValue:
                                        (0251)  bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                        (0252) _bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                        (0253)    RAM_PROLOGUE RAM_USE_CLASS_1
129E: 5D 22    MOV   A,REG[0x22]        (0254)    mov   A, reg[Counter8_1_COMPARE_REG]
                                        (0255)    RAM_EPILOGUE RAM_USE_CLASS_1
12A0: 7F       RET                      (0256)    ret
                                        (0257) 
                                        (0258) 
                                        (0259) .ENDSECTION
                                        (0260) 
                                        (0261) .SECTION
                                        (0262) ;-----------------------------------------------------------------------------
                                        (0263) ;  FUNCTION NAME: Counter8_1_bReadCounter
                                        (0264) ;
                                        (0265) ;  DESCRIPTION:
                                        (0266) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0267) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0268) ;     from the Count to the Compare registers by holding the clock low in
                                        (0269) ;     the PSoC block.
                                        (0270) ;-----------------------------------------------------------------------------
                                        (0271) ;
                                        (0272) ;  ARGUMENTS: None
                                        (0273) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0274) ;  SIDE EFFECTS:
                                        (0275) ;     1) If running, the user module is stopped momentarily and one or more
                                        (0276) ;        counts may be missed.
                                        (0277) ;     2) The A and X registers may be modified by this or future implementations
                                        (0278) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0279) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0280) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0281) ;        functions.
                                        (0282) ;
                                        (0283)  Counter8_1_bReadCounter:
                                        (0284) _Counter8_1_bReadCounter:
                                        (0285)  bCounter8_1_ReadCounter:                        ; this name deprecated
                                        (0286) _bCounter8_1_ReadCounter:                        ; this name deprecated
                                        (0287) 
                                        (0288)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0289)    bOrigControlReg:        EQU   1               ; Frame offset to temp CR0     store
                                        (0290)    bOrigClockSetting:      EQU   2               ; Frame offset to temp Input   store
                                        (0291)    wCounter:               EQU   3               ; Frame offset to temp Count   store
                                        (0292)    STACK_FRAME_SIZE:       EQU   4               ; max stack frame size is 4 bytes
                                        (0293) 
                                        (0294)    RAM_PROLOGUE RAM_USE_CLASS_2
12A1: 4F       MOV   X,SP               (0295)    mov   X, SP                                   ; X <- stack frame pointer
12A2: 5D 22    MOV   A,REG[0x22]        (0296)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Save the Compare register on the stack
12A4: 08       PUSH  A                  (0297)    push  A                                       ;
12A5: 5D 23    MOV   A,REG[0x23]        (0298)    mov   A, reg[Counter8_1_CONTROL_REG]          ; Save CR0 (running or stopped state)
12A7: 08       PUSH  A                  (0299)    push  A                                       ;
12A8: 41 23 FE AND   REG[0x23],0xFE     
12AB: 71 10    OR    F,0x10             
                                        (0300)    Counter8_1_Stop_M                             ; Disable (stop) the Counter if running
                                        (0301)    M8C_SetBank1                                  ;
12AD: 5D 21    MOV   A,REG[0x21]        (0302)    mov   A, reg[Counter8_1_INPUT_REG]            ; save the clock input setting
12AF: 08       PUSH  A                  (0303)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0304)                                                  ;   hold the clock low:
12B0: 62 21 00 MOV   REG[0x21],0x0      (0305)    mov   reg[Counter8_1_INPUT_REG], INPUT_REG_NULL
12B3: 70 EF    AND   F,0xEF             
                                        (0306)    M8C_SetBank0
                                        (0307)                                                  ; Extract the Count via DR2 register
12B5: 5D 20    MOV   A,REG[0x20]        (0308)    mov   A, reg[Counter8_1_COUNTER_REG]          ; DR2 <- DR0
12B7: 5D 22    MOV   A,REG[0x22]        (0309)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Stash the Count on the stack
12B9: 08       PUSH  A                  (0310)    push  A                                       ;  -stack frame is now 3 bytes
12BA: 52 00    MOV   A,[X+0]            (0311)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
12BC: 60 22    MOV   REG[0x22],A        (0312)    mov   reg[Counter8_1_COMPARE_REG], A
12BE: 71 10    OR    F,0x10             
                                        (0313)    M8C_SetBank1                                  ; Restore the counter operation:
12C0: 52 02    MOV   A,[X+2]            (0314)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
12C2: 60 21    MOV   REG[0x21],A        (0315)    mov   reg[Counter8_1_INPUT_REG], A            ;
12C4: 70 EF    AND   F,0xEF             
                                        (0316)    M8C_SetBank0                                  ;   then re-enable (start) the counter
12C6: 52 01    MOV   A,[X+1]            (0317)    mov   A, [X+bOrigControlReg]                  ;     if it was running when
12C8: 60 23    MOV   REG[0x23],A        (0318)    mov   reg[Counter8_1_CONTROL_REG], A          ;     this function was first called
12CA: 18       POP   A                  (0319)    pop   A                                       ; Setup the return value
12CB: 38 FD    ADD   SP,0xFD            (0320)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
12CD: 70 3F    AND   F,0x3F             
12CF: 71 C0    OR    F,0xC0             
                                        (0321)    RAM_EPILOGUE RAM_USE_CLASS_2
12D1: 7F       RET                      (0322)    ret
                                        (0323) 
                                        (0324) .ENDSECTION
                                        (0325) 
                                        (0326) ; End of File Counter8_1.asm
FILE: U:\moxon\MYDOCU~1\GitHub\TinySoc\firmware\TINYSO~1\TINYSO~1\TINYSO~1\TINYSO~1\main.c
(0001) /*****************************************************************************
(0002) # File Name:	TinySoc_USB_UART
(0003) # Platform :	TinySoc
(0004) # Version  :	1.10
(0005) # Author   :	(www.PatternAgents.com)
(0006) #*****************************************************************************
(0007) # Copyright:	(C) 2001-2013 by PatternAgents. All rights reserved.
(0008) #*****************************************************************************
(0009) # PatternAgents Licensing Model:
(0010) # 
(0011) # PatternAgents uses the increasingly popular business model called 
(0012) # "Dual Licensing" in which both the open source software distribution 
(0013) # mechanism and traditional commercial software distribution models 
(0014) # are combined.
(0015) # 
(0016) # Open Source Projects:
(0017) # 
(0018) # If you are developing and distributing open source applications 
(0019) # under the GNU General Public License version 2 (GPLv2), 
(0020) # as published by the Free Software Foundation, then you are free 
(0021) # to use the RSVP software under the GPLv2 license. Please note 
(0022) # that GPLv2 Section 2(b) requires that all modifications to the 
(0023) # original code as well as all Derivative Works must also be 
(0024) # released under the terms of the GPLv2 open source license.
(0025) # 
(0026) # Closed Source Projects:
(0027) # 
(0028) # If you are developing and distributing traditional closed source 
(0029) # applications, you must purchase a PatternAgents commercial use license, 
(0030) # which is specifically designed for users interested in retaining 
(0031) # the proprietary status of their code. All PatternAgents commercial licenses 
(0032) # expressly supersede the GPLv2 open source license. This means that 
(0033) # when you license the PatternAgents software under a commercial license, 
(0034) # you specifically do not use the software under the open source 
(0035) # license and therefore you are not subject to any of its terms.
(0036) #
(0037) # Commercial licensing options available on the PatternAgents Website at : 
(0038) #	http://www.PatternAgents.com/licensing/
(0039) #
(0040) #*****************************************************************************
(0041) # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
(0042) # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
(0043) # BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
(0044) # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
(0045) # COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
(0046) # INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(0047) # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
(0048) # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
(0049) # AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
(0050) # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
(0051) # USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
(0052) #*****************************************************************************
(0053) #
(0054) # Introduction:
(0055) #
(0056) # The TinySoc is a postage stamp size PC board with a USB based PSoC1
(0057) # (Programmable System-on-Chip) of type CY7C64215 (Encore III) 
(0058) #
(0059) #*****************************************************************************
(0060) #
(0061) # Description:
(0062) #
(0063) # This first example loops back the USB data stream for testing.
(0064) #			
(0065) *****************************************************************************/
(0066) 
(0067) #include <m8c.h>        			// part specific constants and macros
(0068) #include "PSoCAPI.h"    			// PSoC API definitions for all User Modules
(0069) 
(0070) const char rsvp_lcd_str_blank[ ]   = "                ";
(0071) const char rsvp_lcd_str_version[ ] = "RSVP Version 1.1";
(0072) const char rsvp_lcd_str_crlf[ ]    = "\n\r";
(0073) 
(0074) /* Buffer for storing UART configuration data */
(0075) BYTE ReadData[10];
(0076) 
(0077) /* Buffer for incoming USB data, and pointer to current place in that buffer */
(0078) BYTE pData[33];
(0079) BYTE len;
(0080) 
(0081) /* Flag and counter for VBUS detection */
(0082) BYTE VDD_ON = 0;
(0083) BYTE USB_VDD_Counter = 0;
(0084) 
(0085) char * strPtr;                         /* Parameter pointer */
(0086) BYTE Data1;  						   /* Data byte for UART */
(0087) 
(0088) BYTE USB_Count;
(0089) BYTE USB_Buffer[64];
(0090) 
(0091) int delay, loop;
(0092) 
(0093) void RSVP_Initialize(void);        		/* RSVP Initialize */
(0094) void RSVP_UART_1_Config( void );
(0095) void RSVP_USBUART_Initialize( void );
(0096) void RSVP_blinkVersion( void );
(0097) void RSVP_UART_Initialize( void );
(0098) void RSVP_USBUART_Send_Greeting( void );
(0099) void RSVP_USBUART_Echo( void );
(0100) 
(0101) void main(void)
(0102) {
(0103) 	RSVP_Initialize();				    /* Initialize all components */
__UserModules_end|__text_start|_main|_main:
    12D2: 94 23    CALL  _RSVP_Initialize
(0104) 	RSVP_USBUART_Initialize();			/* Enumerate the USB UART    */
    12D4: 90 EB    CALL  _RSVP_USBUART_Initialize
(0105) 	RSVP_blinkVersion();				/* Blink the Version Number  */
    12D6: 90 87    CALL  _RSVP_blinkVersion
(0106) 	RSVP_UART_Initialize();				/* Initialize the UART       */
    12D8: 91 00    CALL  _RSVP_UART_Initialize
(0107) 	RSVP_USBUART_Send_Greeting();		/* Print Greeting on USBUART */
    12DA: 90 58    CALL  _RSVP_USBUART_Send_Greeting
    12DC: 80 03    JMP   0x12E0
(0108) 		
(0109) 		
(0110)     while(1)
(0111)     {
(0112) 		RSVP_USBUART_Echo();
    12DE: 90 04    CALL  _RSVP_USBUART_Echo
(0113)     }
    12E0: 8F FD    JMP   0x12DE
    12E2: 8F FF    JMP   0x12E2
(0114) }
(0115) 
(0116) void RSVP_USBUART_Echo( void )
(0117) {
(0118) 	    LED_1_Off();
_RSVP_USBUART_Echo:
    12E4: 10       PUSH  X
    12E5: 7C 12 4E LCALL _LED_1_Start|LED_1_Off|_LED_1_Off|LED_1_Stop|_LED_1_Stop
(0119) 		USB_Count = USBUART_1_bGetRxCount();
    12E8: 7C 0B C0 LCALL _USBUART_1_bGetRxCount
    12EB: 20       POP   X
    12EC: 62 D0 00 MOV   REG[0xD0],0x0
    12EF: 53 C9    MOV   [USB_Count],A
(0120) 		if(USB_Count != 0)							/* Check for input data from PC */
    12F1: 3C C9 00 CMP   [USB_Count],0x0
    12F4: A0 3E    JZ    0x1333
(0121) 		{
(0122) 		    LED_1_On();
    12F6: 10       PUSH  X
    12F7: 7C 12 4A LCALL _LED_1_On
(0123) 			USBUART_1_ReadAll(USB_Buffer);
    12FA: 50 00    MOV   A,0x0
    12FC: 08       PUSH  A
    12FD: 50 44    MOV   A,0x44
    12FF: 5C       MOV   X,A
    1300: 18       POP   A
    1301: 7C 0D ED LCALL _USBUART_1_ReadAll
(0124) 			USBUART_1_Write(USB_Buffer, USB_Count);		/* Echo data back to PC */
    1304: 62 D0 00 MOV   REG[0xD0],0x0
    1307: 51 C9    MOV   A,[USB_Count]
    1309: 08       PUSH  A
    130A: 50 00    MOV   A,0x0
    130C: 08       PUSH  A
    130D: 50 44    MOV   A,0x44
    130F: 08       PUSH  A
    1310: 7C 0B F3 LCALL _USBUART_1_Write
    1313: 38 FD    ADD   SP,0xFD
(0125) 			UART_1_Write(USB_Buffer, USB_Count);
    1315: 62 D0 00 MOV   REG[0xD0],0x0
    1318: 51 C9    MOV   A,[USB_Count]
    131A: 08       PUSH  A
    131B: 50 00    MOV   A,0x0
    131D: 08       PUSH  A
    131E: 50 44    MOV   A,0x44
    1320: 08       PUSH  A
    1321: 7C 10 86 LCALL _UART_1_Write
    1324: 38 FD    ADD   SP,0xFD
    1326: 20       POP   X
(0126) 			while(!USBUART_1_bTxIsReady()){}		/* Wait for Tx to finish */ 
    1327: 10       PUSH  X
    1328: 7C 0E 1B LCALL _USBUART_1_bTxIsReady
    132B: 20       POP   X
    132C: 62 D0 00 MOV   REG[0xD0],0x0
    132F: 39 00    CMP   A,0x0
    1331: AF F5    JZ    0x1327
(0127) 		}
    1333: 7F       RET   
(0128) }
(0129) 
(0130) void RSVP_USBUART_Send_Greeting( void )
(0131) {
(0132) 	/* output the greeting/version string */
(0133) 	USBUART_1_CWrite(rsvp_lcd_str_version, 16);
_RSVP_USBUART_Send_Greeting:
    1334: 10       PUSH  X
    1335: 50 10    MOV   A,0x10
    1337: 08       PUSH  A
    1338: 50 01    MOV   A,0x1
    133A: 08       PUSH  A
    133B: 50 B1    MOV   A,0xB1
    133D: 08       PUSH  A
    133E: 7C 0B EE LCALL _USBUART_1_CWrite
    1341: 38 FD    ADD   SP,0xFD
(0134) 	USBUART_1_CWrite(rsvp_lcd_str_crlf, 2);
    1343: 50 02    MOV   A,0x2
    1345: 08       PUSH  A
    1346: 50 01    MOV   A,0x1
    1348: 08       PUSH  A
    1349: 50 C2    MOV   A,0xC2
    134B: 08       PUSH  A
    134C: 7C 0B EE LCALL _USBUART_1_CWrite
    134F: 38 FD    ADD   SP,0xFD
    1351: 20       POP   X
(0135) 	//USBUART_1_PutCRLF();
(0136) 	while(!USBUART_1_bTxIsReady()){}
    1352: 10       PUSH  X
    1353: 7C 0E 1B LCALL _USBUART_1_bTxIsReady
    1356: 20       POP   X
    1357: 62 D0 00 MOV   REG[0xD0],0x0
    135A: 39 00    CMP   A,0x0
    135C: AF F5    JZ    0x1352
    135E: 7F       RET   
(0137) }
(0138) 
(0139) void RSVP_blinkVersion( void )
(0140) {
(0141) 	/* Send the Version Number as blinks, give time to receive */
(0142) 	for (loop = 0; loop < 30; loop++) {
_RSVP_blinkVersion:
    135F: 62 D0 00 MOV   REG[0xD0],0x0
    1362: 55 C5 00 MOV   [loop+1],0x0
    1365: 55 C4 00 MOV   [loop],0x0
(0143) 		for (delay = 0; delay < 10000; delay++) {
    1368: 62 D0 00 MOV   REG[0xD0],0x0
    136B: 55 C3 00 MOV   [delay+1],0x0
    136E: 55 C2 00 MOV   [delay],0x0
(0144) 			LED_1_On();
    1371: 10       PUSH  X
    1372: 7C 12 4A LCALL _LED_1_On
    1375: 20       POP   X
(0145) 		}
    1376: 62 D0 00 MOV   REG[0xD0],0x0
    1379: 76 C3    INC   [delay+1]
    137B: 0E C2 00 ADC   [delay],0x0
    137E: 51 C3    MOV   A,[delay+1]
    1380: 11 10    SUB   A,0x10
    1382: 51 C2    MOV   A,[delay]
    1384: 31 80    XOR   A,0x80
    1386: 19 A7    SBB   A,0xA7
    1388: CF E8    JC    0x1371
(0146) 		for (delay = 0; delay < 10000; delay++) {
    138A: 62 D0 00 MOV   REG[0xD0],0x0
    138D: 55 C3 00 MOV   [delay+1],0x0
    1390: 55 C2 00 MOV   [delay],0x0
(0147) 			LED_1_Off();
    1393: 10       PUSH  X
    1394: 7C 12 4E LCALL _LED_1_Start|LED_1_Off|_LED_1_Off|LED_1_Stop|_LED_1_Stop
    1397: 20       POP   X
(0148) 		}
    1398: 62 D0 00 MOV   REG[0xD0],0x0
    139B: 76 C3    INC   [delay+1]
    139D: 0E C2 00 ADC   [delay],0x0
    13A0: 51 C3    MOV   A,[delay+1]
    13A2: 11 10    SUB   A,0x10
    13A4: 51 C2    MOV   A,[delay]
    13A6: 31 80    XOR   A,0x80
    13A8: 19 A7    SBB   A,0xA7
    13AA: CF E8    JC    0x1393
(0149) 	}
    13AC: 62 D0 00 MOV   REG[0xD0],0x0
    13AF: 76 C5    INC   [loop+1]
    13B1: 0E C4 00 ADC   [loop],0x0
    13B4: 51 C5    MOV   A,[loop+1]
    13B6: 11 1E    SUB   A,0x1E
    13B8: 51 C4    MOV   A,[loop]
    13BA: 31 80    XOR   A,0x80
    13BC: 19 80    SBB   A,0x80
    13BE: CF A9    JC    0x1368
    13C0: 7F       RET   
(0150) }
(0151) 
(0152) void RSVP_USBUART_Initialize( void )
(0153) {
_RSVP_USBUART_Initialize:
    13C1: 80 06    JMP   0x13C8
(0154) 	/* Wait for USBUART_1 to initialize */
(0155) 	while( !USBUART_1_Init() ) {
(0156) 		LED_1_On();
    13C3: 10       PUSH  X
    13C4: 7C 12 4A LCALL _LED_1_On
    13C7: 20       POP   X
(0157) 	}
    13C8: 10       PUSH  X
    13C9: 7C 0E 24 LCALL _USBUART_1_Init
    13CC: 20       POP   X
    13CD: 62 D0 00 MOV   REG[0xD0],0x0
    13D0: 39 00    CMP   A,0x0
    13D2: AF F0    JZ    0x13C3
(0158) 	LED_1_Off();
    13D4: 10       PUSH  X
    13D5: 7C 12 4E LCALL _LED_1_Start|LED_1_Off|_LED_1_Off|LED_1_Stop|_LED_1_Stop
    13D8: 20       POP   X
    13D9: 7F       RET   
(0159) }
(0160) 
(0161) void RSVP_UART_Initialize( void )
(0162) {
(0163) /*
(0164) 	UART_1_SwitchBuffer = 0;		
(0165) 	UART_1_bTxCnt = 0;				
(0166) 	UART_1_bTxFlag = 0;
(0167) */
(0168) 	UART_1_CWrite(rsvp_lcd_str_version, 16);
_RSVP_UART_Initialize:
    13DA: 10       PUSH  X
    13DB: 50 00    MOV   A,0x0
    13DD: 08       PUSH  A
    13DE: 50 10    MOV   A,0x10
    13E0: 08       PUSH  A
    13E1: 50 01    MOV   A,0x1
    13E3: 08       PUSH  A
    13E4: 50 B1    MOV   A,0xB1
    13E6: 08       PUSH  A
    13E7: 7C 10 AE LCALL _UART_1_CWrite
    13EA: 38 FC    ADD   SP,0xFC
(0169) 	UART_1_CWrite(rsvp_lcd_str_crlf, 2);
    13EC: 50 00    MOV   A,0x0
    13EE: 08       PUSH  A
    13EF: 50 02    MOV   A,0x2
    13F1: 08       PUSH  A
    13F2: 50 01    MOV   A,0x1
    13F4: 08       PUSH  A
    13F5: 50 C2    MOV   A,0xC2
    13F7: 08       PUSH  A
    13F8: 7C 10 AE LCALL _UART_1_CWrite
    13FB: 38 FC    ADD   SP,0xFC
    13FD: 20       POP   X
    13FE: 7F       RET   
(0170) }
(0171) 
(0172) void RSVP_UART_1_Config( void )
(0173) {
_RSVP_UART_1_Config:
  Return_Config        --> X+4
  dwDTERate            --> X+0
    13FF: 10       PUSH  X
    1400: 4F       MOV   X,SP
    1401: 38 07    ADD   SP,0x7
(0174) 	unsigned long dwDTERate;
(0175) 	BYTE Return_Config;
(0176) 	USBUART_1_dwGetDTERate( &dwDTERate );
    1403: 62 D0 00 MOV   REG[0xD0],0x0
    1406: 10       PUSH  X
    1407: 50 03    MOV   A,0x3
    1409: 08       PUSH  A
    140A: 18       POP   A
    140B: 7C 0E 7D LCALL _USBUART_1_dwGetDTERate
    140E: 62 D0 00 MOV   REG[0xD0],0x0
    1411: 20       POP   X
(0177) 
(0178)     switch( dwDTERate )
    1412: 52 03    MOV   A,[X+3]
    1414: 11 00    SUB   A,0x0
    1416: 53 BF    MOV   [__rY],A
    1418: 52 02    MOV   A,[X+2]
    141A: 19 4B    SBB   A,0x4B
    141C: 2C BF    OR    [__rY],A
    141E: 52 01    MOV   A,[X+1]
    1420: 19 00    SBB   A,0x0
    1422: 2C BF    OR    [__rY],A
    1424: 52 00    MOV   A,[X+0]
    1426: 31 80    XOR   A,0x80
    1428: 19 80    SBB   A,0x80
    142A: 2A BF    OR    A,[__rY]
    142C: A1 81    JZ    0x15AE
    142E: D0 4E    JNC   0x147D
    1430: 52 03    MOV   A,[X+3]
    1432: 11 C0    SUB   A,0xC0
    1434: 62 D0 00 MOV   REG[0xD0],0x0
    1437: 53 BF    MOV   [__rY],A
    1439: 52 02    MOV   A,[X+2]
    143B: 19 12    SBB   A,0x12
    143D: 2C BF    OR    [__rY],A
    143F: 52 01    MOV   A,[X+1]
    1441: 19 00    SBB   A,0x0
    1443: 2C BF    OR    [__rY],A
    1445: 52 00    MOV   A,[X+0]
    1447: 31 80    XOR   A,0x80
    1449: 19 80    SBB   A,0x80
    144B: 2A BF    OR    A,[__rY]
    144D: A0 C8    JZ    0x1516
    144F: D0 17    JNC   0x1467
    1451: 3D 00 00 CMP   [X+0],0x0
    1454: B0 10    JNZ   0x1465
    1456: 3D 01 00 CMP   [X+1],0x0
    1459: B0 0B    JNZ   0x1465
    145B: 3D 02 09 CMP   [X+2],0x9
    145E: B0 06    JNZ   0x1465
    1460: 3D 03 60 CMP   [X+3],0x60
    1463: A0 66    JZ    0x14CA
    1465: 80 FC    JMP   0x1562
    1467: 3D 00 00 CMP   [X+0],0x0
    146A: B0 10    JNZ   0x147B
    146C: 3D 01 00 CMP   [X+1],0x0
    146F: B0 0B    JNZ   0x147B
    1471: 3D 02 25 CMP   [X+2],0x25
    1474: B0 06    JNZ   0x147B
    1476: 3D 03 80 CMP   [X+3],0x80
    1479: A0 E8    JZ    0x1562
    147B: 80 E6    JMP   0x1562
    147D: 52 03    MOV   A,[X+3]
    147F: 11 00    SUB   A,0x0
    1481: 62 D0 00 MOV   REG[0xD0],0x0
    1484: 53 BF    MOV   [__rY],A
    1486: 52 02    MOV   A,[X+2]
    1488: 19 E1    SBB   A,0xE1
    148A: 2C BF    OR    [__rY],A
    148C: 52 01    MOV   A,[X+1]
    148E: 19 00    SBB   A,0x0
    1490: 2C BF    OR    [__rY],A
    1492: 52 00    MOV   A,[X+0]
    1494: 31 80    XOR   A,0x80
    1496: 19 80    SBB   A,0x80
    1498: 2A BF    OR    A,[__rY]
    149A: A1 87    JZ    0x1622
    149C: D0 17    JNC   0x14B4
    149E: 3D 00 00 CMP   [X+0],0x0
    14A1: B0 10    JNZ   0x14B2
    14A3: 3D 01 00 CMP   [X+1],0x0
    14A6: B0 0B    JNZ   0x14B2
    14A8: 3D 02 96 CMP   [X+2],0x96
    14AB: B0 06    JNZ   0x14B2
    14AD: 3D 03 00 CMP   [X+3],0x0
    14B0: A1 3E    JZ    0x15EF
    14B2: 80 AF    JMP   0x1562
    14B4: 3D 00 00 CMP   [X+0],0x0
    14B7: B0 10    JNZ   0x14C8
    14B9: 3D 01 01 CMP   [X+1],0x1
    14BC: B0 0B    JNZ   0x14C8
    14BE: 3D 02 C2 CMP   [X+2],0xC2
    14C1: B0 06    JNZ   0x14C8
    14C3: 3D 03 00 CMP   [X+3],0x0
    14C6: A1 8E    JZ    0x1655
    14C8: 80 99    JMP   0x1562
(0179)     {
(0180)     	case 2400:
(0181) 			Counter8_1_OUTPUT_REG = 0x40 | (Counter8_1_OUTPUT_REG &0x3F); 
    14CA: 71 10    OR    F,0x10
    14CC: 5D 22    MOV   A,REG[0x22]
    14CE: 70 CF    AND   F,0xCF
    14D0: 62 D0 00 MOV   REG[0xD0],0x0
    14D3: 53 C1    MOV   [__r0],A
    14D5: 26 C1 3F AND   [__r0],0x3F
    14D8: 2E C1 40 OR    [__r0],0x40
    14DB: 51 C1    MOV   A,[__r0]
    14DD: 71 10    OR    F,0x10
    14DF: 60 22    MOV   REG[0x22],A
(0182) 			OSC_CR1 = 0x70 | (OSC_CR1& OSC_CR1_VC2); 
    14E1: 5D E1    MOV   A,REG[0xE1]
    14E3: 53 C1    MOV   [__r0],A
    14E5: 26 C1 0F AND   [__r0],0xF
    14E8: 2E C1 70 OR    [__r0],0x70
    14EB: 51 C1    MOV   A,[__r0]
    14ED: 60 E1    MOV   REG[0xE1],A
(0183) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x05;
    14EF: 5D 21    MOV   A,REG[0x21]
    14F1: 53 C1    MOV   [__r0],A
    14F3: 26 C1 F0 AND   [__r0],0xF0
    14F6: 2E C1 05 OR    [__r0],0x5
    14F9: 51 C1    MOV   A,[__r0]
    14FB: 60 21    MOV   REG[0x21],A
(0184) 			Counter8_1_WritePeriod(155);
    14FD: 10       PUSH  X
    14FE: 50 9B    MOV   A,0x9B
    1500: 70 CF    AND   F,0xCF
    1502: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0185) 			Counter8_1_WriteCompareValue(78);
    1505: 50 4E    MOV   A,0x4E
    1507: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    150A: 20       POP   X
(0186) 			ReadData[2] = 0;
    150B: 62 D0 00 MOV   REG[0xD0],0x0
    150E: 55 B7 00 MOV   [ReadData+2],0x0
(0187) 			ReadData[3] = 24;
    1511: 55 B8 18 MOV   [ReadData+3],0x18
(0188)     	break;
    1514: 81 71    JMP   0x1686
(0189) 
(0190)     	case 4800:
(0191) 			Counter8_1_OUTPUT_REG = 0x40 | (Counter8_1_OUTPUT_REG &0x3F);
    1516: 71 10    OR    F,0x10
    1518: 5D 22    MOV   A,REG[0x22]
    151A: 70 CF    AND   F,0xCF
    151C: 62 D0 00 MOV   REG[0xD0],0x0
    151F: 53 C1    MOV   [__r0],A
    1521: 26 C1 3F AND   [__r0],0x3F
    1524: 2E C1 40 OR    [__r0],0x40
    1527: 51 C1    MOV   A,[__r0]
    1529: 71 10    OR    F,0x10
    152B: 60 22    MOV   REG[0x22],A
(0192) 			OSC_CR1 = 0x30 | (OSC_CR1& OSC_CR1_VC2); 
    152D: 5D E1    MOV   A,REG[0xE1]
    152F: 53 C1    MOV   [__r0],A
    1531: 26 C1 0F AND   [__r0],0xF
    1534: 2E C1 30 OR    [__r0],0x30
    1537: 51 C1    MOV   A,[__r0]
    1539: 60 E1    MOV   REG[0xE1],A
(0193) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x05;
    153B: 5D 21    MOV   A,REG[0x21]
    153D: 53 C1    MOV   [__r0],A
    153F: 26 C1 F0 AND   [__r0],0xF0
    1542: 2E C1 05 OR    [__r0],0x5
    1545: 51 C1    MOV   A,[__r0]
    1547: 60 21    MOV   REG[0x21],A
(0194) 			Counter8_1_WritePeriod(155);
    1549: 10       PUSH  X
    154A: 50 9B    MOV   A,0x9B
    154C: 70 CF    AND   F,0xCF
    154E: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0195) 			Counter8_1_WriteCompareValue(78);
    1551: 50 4E    MOV   A,0x4E
    1553: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    1556: 20       POP   X
(0196) 			ReadData[2] = 0;
    1557: 62 D0 00 MOV   REG[0xD0],0x0
    155A: 55 B7 00 MOV   [ReadData+2],0x0
(0197) 			ReadData[3] = 48;
    155D: 55 B8 30 MOV   [ReadData+3],0x30
(0198)     	break;
    1560: 81 25    JMP   0x1686
(0199) 
(0200)  		case 9600:
(0201)     	default:
(0202) 			Counter8_1_OUTPUT_REG = 0x40 | (Counter8_1_OUTPUT_REG &0x3F);
    1562: 71 10    OR    F,0x10
    1564: 5D 22    MOV   A,REG[0x22]
    1566: 70 CF    AND   F,0xCF
    1568: 62 D0 00 MOV   REG[0xD0],0x0
    156B: 53 C1    MOV   [__r0],A
    156D: 26 C1 3F AND   [__r0],0x3F
    1570: 2E C1 40 OR    [__r0],0x40
    1573: 51 C1    MOV   A,[__r0]
    1575: 71 10    OR    F,0x10
    1577: 60 22    MOV   REG[0x22],A
(0203) 			OSC_CR1 = 0x10 | (OSC_CR1& OSC_CR1_VC2); 
    1579: 5D E1    MOV   A,REG[0xE1]
    157B: 53 C1    MOV   [__r0],A
    157D: 26 C1 0F AND   [__r0],0xF
    1580: 2E C1 10 OR    [__r0],0x10
    1583: 51 C1    MOV   A,[__r0]
    1585: 60 E1    MOV   REG[0xE1],A
(0204) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x05;
    1587: 5D 21    MOV   A,REG[0x21]
    1589: 53 C1    MOV   [__r0],A
    158B: 26 C1 F0 AND   [__r0],0xF0
    158E: 2E C1 05 OR    [__r0],0x5
    1591: 51 C1    MOV   A,[__r0]
    1593: 60 21    MOV   REG[0x21],A
(0205) 			Counter8_1_WritePeriod(155);
    1595: 10       PUSH  X
    1596: 50 9B    MOV   A,0x9B
    1598: 70 CF    AND   F,0xCF
    159A: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0206) 			Counter8_1_WriteCompareValue(78);
    159D: 50 4E    MOV   A,0x4E
    159F: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    15A2: 20       POP   X
(0207) 			ReadData[2] = 0;
    15A3: 62 D0 00 MOV   REG[0xD0],0x0
    15A6: 55 B7 00 MOV   [ReadData+2],0x0
(0208) 			ReadData[3] = 96;
    15A9: 55 B8 60 MOV   [ReadData+3],0x60
(0209)     	break;
    15AC: 80 D9    JMP   0x1686
(0210) 
(0211)     	case 19200:
(0212) 			Counter8_1_OUTPUT_REG = 0xC0 | (Counter8_1_OUTPUT_REG &0x3F); 
    15AE: 71 10    OR    F,0x10
    15B0: 5D 22    MOV   A,REG[0x22]
    15B2: 70 CF    AND   F,0xCF
    15B4: 62 D0 00 MOV   REG[0xD0],0x0
    15B7: 53 C1    MOV   [__r0],A
    15B9: 26 C1 3F AND   [__r0],0x3F
    15BC: 2E C1 C0 OR    [__r0],0xC0
    15BF: 51 C1    MOV   A,[__r0]
    15C1: 71 10    OR    F,0x10
    15C3: 60 22    MOV   REG[0x22],A
(0213) 			OSC_CR1 = 0x00 | (OSC_CR1& OSC_CR1_VC2); 
    15C5: 41 E1 0F AND   REG[0xE1],0xF
(0214) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x05; 
    15C8: 5D 21    MOV   A,REG[0x21]
    15CA: 53 C1    MOV   [__r0],A
    15CC: 26 C1 F0 AND   [__r0],0xF0
    15CF: 2E C1 05 OR    [__r0],0x5
    15D2: 51 C1    MOV   A,[__r0]
    15D4: 60 21    MOV   REG[0x21],A
(0215) 			Counter8_1_WritePeriod(155);
    15D6: 10       PUSH  X
    15D7: 50 9B    MOV   A,0x9B
    15D9: 70 CF    AND   F,0xCF
    15DB: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0216) 			Counter8_1_WriteCompareValue(78);
    15DE: 50 4E    MOV   A,0x4E
    15E0: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    15E3: 20       POP   X
(0217) 			ReadData[2] = 1;
    15E4: 62 D0 00 MOV   REG[0xD0],0x0
    15E7: 55 B7 01 MOV   [ReadData+2],0x1
(0218) 			ReadData[3] = 92;
    15EA: 55 B8 5C MOV   [ReadData+3],0x5C
(0219)     	break;
    15ED: 80 98    JMP   0x1686
(0220) 
(0221)     	case 38400:
(0222) 			Counter8_1_OUTPUT_REG = 0x00 | (Counter8_1_OUTPUT_REG &0x3F);
    15EF: 71 10    OR    F,0x10
    15F1: 41 22 3F AND   REG[0x22],0x3F
(0223) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x04; 
    15F4: 5D 21    MOV   A,REG[0x21]
    15F6: 70 CF    AND   F,0xCF
    15F8: 62 D0 00 MOV   REG[0xD0],0x0
    15FB: 53 C1    MOV   [__r0],A
    15FD: 26 C1 F0 AND   [__r0],0xF0
    1600: 2E C1 04 OR    [__r0],0x4
    1603: 51 C1    MOV   A,[__r0]
    1605: 71 10    OR    F,0x10
    1607: 60 21    MOV   REG[0x21],A
(0224) 			Counter8_1_WritePeriod(155);
    1609: 10       PUSH  X
    160A: 50 9B    MOV   A,0x9B
    160C: 70 CF    AND   F,0xCF
    160E: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0225) 			Counter8_1_WriteCompareValue(78);
    1611: 50 4E    MOV   A,0x4E
    1613: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    1616: 20       POP   X
(0226) 			ReadData[2] = 3;
    1617: 62 D0 00 MOV   REG[0xD0],0x0
    161A: 55 B7 03 MOV   [ReadData+2],0x3
(0227) 			ReadData[3] = 84;
    161D: 55 B8 54 MOV   [ReadData+3],0x54
(0228)     	break;
    1620: 80 65    JMP   0x1686
(0229) 
(0230)     	case 57600:
(0231) 			Counter8_1_OUTPUT_REG = 0x00 | (Counter8_1_OUTPUT_REG &0x3F);
    1622: 71 10    OR    F,0x10
    1624: 41 22 3F AND   REG[0x22],0x3F
(0232) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x04;
    1627: 5D 21    MOV   A,REG[0x21]
    1629: 70 CF    AND   F,0xCF
    162B: 62 D0 00 MOV   REG[0xD0],0x0
    162E: 53 C1    MOV   [__r0],A
    1630: 26 C1 F0 AND   [__r0],0xF0
    1633: 2E C1 04 OR    [__r0],0x4
    1636: 51 C1    MOV   A,[__r0]
    1638: 71 10    OR    F,0x10
    163A: 60 21    MOV   REG[0x21],A
(0233) 			Counter8_1_WritePeriod(103);
    163C: 10       PUSH  X
    163D: 50 67    MOV   A,0x67
    163F: 70 CF    AND   F,0xCF
    1641: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0234) 			Counter8_1_WriteCompareValue(52);
    1644: 50 34    MOV   A,0x34
    1646: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    1649: 20       POP   X
(0235) 			ReadData[2] = 5;
    164A: 62 D0 00 MOV   REG[0xD0],0x0
    164D: 55 B7 05 MOV   [ReadData+2],0x5
(0236) 			ReadData[3] = 76;
    1650: 55 B8 4C MOV   [ReadData+3],0x4C
(0237)     	break;
    1653: 80 32    JMP   0x1686
(0238) 
(0239)     	case 115200:
(0240) 			Counter8_1_OUTPUT_REG = 0x00 | (Counter8_1_OUTPUT_REG &0x3F);
    1655: 71 10    OR    F,0x10
    1657: 41 22 3F AND   REG[0x22],0x3F
(0241) 			Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x04; 
    165A: 5D 21    MOV   A,REG[0x21]
    165C: 70 CF    AND   F,0xCF
    165E: 62 D0 00 MOV   REG[0xD0],0x0
    1661: 53 C1    MOV   [__r0],A
    1663: 26 C1 F0 AND   [__r0],0xF0
    1666: 2E C1 04 OR    [__r0],0x4
    1669: 51 C1    MOV   A,[__r0]
    166B: 71 10    OR    F,0x10
    166D: 60 21    MOV   REG[0x21],A
(0242) 			Counter8_1_WritePeriod(51);
    166F: 10       PUSH  X
    1670: 50 33    MOV   A,0x33
    1672: 70 CF    AND   F,0xCF
    1674: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0243) 			Counter8_1_WriteCompareValue(26);
    1677: 50 1A    MOV   A,0x1A
    1679: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
    167C: 20       POP   X
(0244) 			ReadData[2] =11;
    167D: 62 D0 00 MOV   REG[0xD0],0x0
    1680: 55 B7 0B MOV   [ReadData+2],0xB
(0245) 			ReadData[3] = 52;
    1683: 55 B8 34 MOV   [ReadData+3],0x34
(0246)     	break;
(0247)     }
(0248) 
(0249) 	Return_Config = USBUART_1_bGetParityType();
    1686: 10       PUSH  X
    1687: 7C 0E A7 LCALL _USBUART_1_bGetParityType
    168A: 20       POP   X
    168B: 62 D0 00 MOV   REG[0xD0],0x0
    168E: 54 04    MOV   [X+4],A
(0250) 
(0251) 	switch( Return_Config )
    1690: 52 04    MOV   A,[X+4]
    1692: 54 06    MOV   [X+6],A
    1694: 56 05 00 MOV   [X+5],0x0
    1697: 3D 05 00 CMP   [X+5],0x0
    169A: B0 06    JNZ   0x16A1
    169C: 3D 06 00 CMP   [X+6],0x0
    169F: A0 2B    JZ    0x16CB
    16A1: 3D 05 00 CMP   [X+5],0x0
    16A4: B0 06    JNZ   0x16AB
    16A6: 3D 06 01 CMP   [X+6],0x1
    16A9: A0 2A    JZ    0x16D4
    16AB: 3D 05 00 CMP   [X+5],0x0
    16AE: B0 06    JNZ   0x16B5
    16B0: 3D 06 02 CMP   [X+6],0x2
    16B3: A0 29    JZ    0x16DD
    16B5: 3D 05 00 CMP   [X+5],0x0
    16B8: B0 06    JNZ   0x16BF
    16BA: 3D 06 03 CMP   [X+6],0x3
    16BD: A0 28    JZ    0x16E6
    16BF: 3D 05 00 CMP   [X+5],0x0
    16C2: B0 06    JNZ   0x16C9
    16C4: 3D 06 04 CMP   [X+6],0x4
    16C7: A0 1E    JZ    0x16E6
    16C9: 80 1C    JMP   0x16E6
(0252) 	{
(0253) 		case USBUART_1_PARITY_NONE:
(0254) 			UART_1_Start( UART_1_PARITY_NONE );
    16CB: 10       PUSH  X
    16CC: 50 00    MOV   A,0x0
    16CE: 7C 0F C3 LCALL _UART_1_Start
    16D1: 20       POP   X
(0255) 		break;
    16D2: 80 1A    JMP   0x16ED
(0256) 
(0257) 		case USBUART_1_PARITY_ODD:
(0258) 			UART_1_Start( UART_1_PARITY_ODD );      
    16D4: 10       PUSH  X
    16D5: 50 06    MOV   A,0x6
    16D7: 7C 0F C3 LCALL _UART_1_Start
    16DA: 20       POP   X
(0259) 	 	break;
    16DB: 80 11    JMP   0x16ED
(0260) 
(0261) 		case USBUART_1_PARITY_EVEN:
(0262) 			UART_1_Start( UART_1_PARITY_EVEN );       
    16DD: 10       PUSH  X
    16DE: 50 02    MOV   A,0x2
    16E0: 7C 0F C3 LCALL _UART_1_Start
    16E3: 20       POP   X
(0263) 		break;
    16E4: 80 08    JMP   0x16ED
(0264) 
(0265) 		default:
(0266) 		case USBUART_1_PARITY_MARK:
(0267) 		case USBUART_1_PARITY_SPACE:
(0268) 			UART_1_Start( UART_1_PARITY_NONE );        
    16E6: 10       PUSH  X
    16E7: 50 00    MOV   A,0x0
    16E9: 7C 0F C3 LCALL _UART_1_Start
    16EC: 20       POP   X
(0269) 		break;
(0270) 	}
(0271) 	return;
    16ED: 38 F9    ADD   SP,0xF9
    16EF: 20       POP   X
    16F0: 7F       RET   
(0272) }
(0273) 
(0274) //-----------------------------------------------------------------------------
(0275) //  Sleep timer ISR function definition
(0276) //-----------------------------------------------------------------------------
(0277) void SleepTimer_1_ISRV(void)
(0278) {
(0279) 	// start of the Sleep Timer ISR, 
(0280) 	// the M8C processor executes this ISR after it comes out of sleep
(0281) 	// Toggle the LED
(0282) 	   LED_1_Invert(); 
_SleepTimer_1_ISRV:
    16F1: 10       PUSH  X
    16F2: 7C 12 68 LCALL _LED_1_Invert
    16F5: 20       POP   X
    16F6: 7F       RET   
(0283) }
(0284) 
(0285) //-----------------------------------------------------------------------------
(0286) //  RSVP_Initialize function definition
(0287) //  Initialize RSVP Platform
(0288) //-----------------------------------------------------------------------------
(0289) void RSVP_Initialize(void)
(0290) {
(0291) 	SleepTimer_1_Start();
_RSVP_Initialize:
    16F7: 10       PUSH  X
    16F8: 7C 11 B8 LCALL _SleepTimer_1_Start
(0292) 	SleepTimer_1_SetInterval(SleepTimer_1_1_HZ);
    16FB: 50 18    MOV   A,0x18
    16FD: 7C 11 CD LCALL _SleepTimer_1_SetInterval
(0293) 	SleepTimer_1_EnableInt();
    1700: 7C 11 B0 LCALL _SleepTimer_1_EnableInt
(0294) 
(0295) 	LED_1_Start();
    1703: 7C 12 4E LCALL _LED_1_Start|LED_1_Off|_LED_1_Off|LED_1_Stop|_LED_1_Stop
(0296) 	LED_1_On();
    1706: 7C 12 4A LCALL _LED_1_On
    1709: 20       POP   X
(0297) 
(0298)     //UART_1_IntCntl( UART_1_ENABLE_RX_INT|UART_1_ENABLE_TX_INT );    /* Setup UART baud clock */
(0299) 	Counter8_1_OUTPUT_REG = 0x00 | (Counter8_1_OUTPUT_REG &0x3F);
    170A: 71 10    OR    F,0x10
    170C: 41 22 3F AND   REG[0x22],0x3F
(0300) 	Counter8_1_INPUT_REG = (Counter8_1_INPUT_REG & 0xF0) | 0x04;
    170F: 5D 21    MOV   A,REG[0x21]
    1711: 70 CF    AND   F,0xCF
    1713: 62 D0 00 MOV   REG[0xD0],0x0
    1716: 53 C1    MOV   [__r0],A
    1718: 26 C1 F0 AND   [__r0],0xF0
    171B: 2E C1 04 OR    [__r0],0x4
    171E: 51 C1    MOV   A,[__r0]
    1720: 71 10    OR    F,0x10
    1722: 60 21    MOV   REG[0x21],A
(0301) 	Counter8_1_WritePeriod(103);
    1724: 10       PUSH  X
    1725: 50 67    MOV   A,0x67
    1727: 70 CF    AND   F,0xCF
    1729: 7C 12 98 LCALL _Counter8_1_WritePeriod
(0302) 	Counter8_1_WriteCompareValue(52);
    172C: 50 34    MOV   A,0x34
    172E: 7C 12 9B LCALL _Counter8_1_WriteCompareValue
(0303)     Counter8_1_Start();                     						 /* Start UART baud clock */
    1731: 7C 12 90 LCALL _Counter8_1_Start
(0304) 
(0305)     UART_1_Start(UART_1_PARITY_NONE);         					/* Enable UART */
    1734: 50 00    MOV   A,0x0
    1736: 7C 0F C3 LCALL _UART_1_Start
    1739: 20       POP   X
(0306)     USB_CR1 |= USB_CR1_ENABLE_LOCK;		  						/* Lock IMO to USB clock */
    173A: 71 10    OR    F,0x10
    173C: 43 C1 02 OR    REG[0xC1],0x2
(0307)     M8C_EnableGInt ;                     						/* Enable global interrupts */
    173F: 71 01    OR    F,0x1
(0308) 
(0309) 	USBUART_1_Start(USBUART_1_5V_OPERATION);    				/* Start USBUART */
    1741: 10       PUSH  X
    1742: 50 03    MOV   A,0x3
    1744: 70 CF    AND   F,0xCF
    1746: 7C 0B 56 LCALL _USBUART_1_Start
    1749: 20       POP   X
(0310)     RSVP_UART_1_Config();		     							/* Setup UART to match USBUART */
    174A: 9C B3    CALL  _RSVP_UART_1_Config
(0311) 	LED_1_Off();
    174C: 10       PUSH  X
    174D: 7C 12 4E LCALL _LED_1_Start|LED_1_Off|_LED_1_Off|LED_1_Stop|_LED_1_Stop
    1750: 20       POP   X
    1751: 7F       RET   
FILE: lib\usbuart_1int.asm              (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBUART_1Int.asm
                                        (0004) ;;  Version: 1.60, Updated on 2013/5/19 at 10:44:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USBFS User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's
                                        (0014) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "USBUART_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ; include instance specific register definitions
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-------------------------------------------------------------------
                                        (0034) ;  Declare the functions global for both assembler and C compiler.
                                        (0035) ;
                                        (0036) ;  Note that there are two names for each API. First name is
                                        (0037) ;  assembler reference. Name with underscore is name reference for
                                        (0038) ;  C compiler.  Calling function in C source code does not require
                                        (0039) ;  the underscore.
                                        (0040) ;-------------------------------------------------------------------
                                        (0041) 
                                        (0042) export    USBUART_1_EP1_ISR
                                        (0043) export   _USBUART_1_EP1_ISR
                                        (0044) export    USBUART_1_EP2_ISR
                                        (0045) export   _USBUART_1_EP2_ISR
                                        (0046) export    USBUART_1_EP3_ISR
                                        (0047) export   _USBUART_1_EP3_ISR
                                        (0048) export    USBUART_1_EP4_ISR
                                        (0049) export   _USBUART_1_EP4_ISR
                                        (0050) export    USBUART_1_RESET_ISR
                                        (0051) export   _USBUART_1_RESET_ISR
                                        (0052) export    USBUART_1_SOF_ISR
                                        (0053) export   _USBUART_1_SOF_ISR
                                        (0054) export    USBUART_1_WAKEUP_ISR
                                        (0055) export   _USBUART_1_WAKEUP_ISR
                                        (0056) 
                                        (0057) 
                                        (0058) AREA InterruptRAM (RAM, REL, CON)
                                        (0059) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0060) ;---------------------------------------------------
                                        (0061) ; Insert your custom declarations below this banner
                                        (0062) ;---------------------------------------------------
                                        (0063) 
                                        (0064) ;------------------------
                                        (0065) ; Includes
                                        (0066) ;------------------------
                                        (0067) 
                                        (0068) 
                                        (0069) ;------------------------
                                        (0070) ;  Constant Definitions
                                        (0071) ;------------------------
                                        (0072) 
                                        (0073) 
                                        (0074) ;------------------------
                                        (0075) ; Variable Allocation
                                        (0076) ;------------------------
                                        (0077) 
                                        (0078) 
                                        (0079) ;---------------------------------------------------
                                        (0080) ; Insert your custom declarations above this banner
                                        (0081) ;---------------------------------------------------
                                        (0082) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0083) 
                                        (0084) AREA text (ROM, REL)
                                        (0085) 
                                        (0086) 
                                        (0087)  USBUART_1_EP1_ISR:
                                        (0088) _USBUART_1_EP1_ISR:
                                        (0089) 
1752: 55 23 01 MOV   [0x23],0x1         (0090)    mov  [USBUART_1_EndpointAPIStatus + 1], EVENT_PENDING
                                        (0091)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0092)    ;---------------------------------------------------
                                        (0093)    ; Insert your custom assembly code below this banner
                                        (0094)    ;---------------------------------------------------
                                        (0095)    ;   NOTE: interrupt service routines must preserve
                                        (0096)    ;   the values of the A and X CPU registers.
                                        (0097)    
                                        (0098)    ;---------------------------------------------------
                                        (0099)    ; Insert your custom assembly code above this banner
                                        (0100)    ;---------------------------------------------------
                                        (0101)    
                                        (0102)    ;---------------------------------------------------
                                        (0103)    ; Insert a lcall to a C function below this banner
                                        (0104)    ; and un-comment the lines between these banners
                                        (0105)    ;---------------------------------------------------
                                        (0106)    
                                        (0107)    ;PRESERVE_CPU_CONTEXT
                                        (0108)    ;lcall _My_C_Function
                                        (0109)    ;RESTORE_CPU_CONTEXT
                                        (0110)    
                                        (0111)    ;---------------------------------------------------
                                        (0112)    ; Insert a lcall to a C function above this banner
                                        (0113)    ; and un-comment the lines between these banners
                                        (0114)    ;---------------------------------------------------
                                        (0115)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0116) 
1755: 7E       RETI                     (0117)    reti
                                        (0118) 
                                        (0119)  USBUART_1_EP2_ISR:
                                        (0120) _USBUART_1_EP2_ISR:
                                        (0121) 
1756: 55 24 01 MOV   [0x24],0x1         (0122)    mov  [USBUART_1_EndpointAPIStatus + 2], EVENT_PENDING
                                        (0123)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ; Insert your custom assembly code below this banner
                                        (0126)    ;---------------------------------------------------
                                        (0127)    ;   NOTE: interrupt service routines must preserve
                                        (0128)    ;   the values of the A and X CPU registers.
                                        (0129)    
                                        (0130)    ;---------------------------------------------------
                                        (0131)    ; Insert your custom assembly code above this banner
                                        (0132)    ;---------------------------------------------------
                                        (0133)    
                                        (0134)    ;---------------------------------------------------
                                        (0135)    ; Insert a lcall to a C function below this banner
                                        (0136)    ; and un-comment the lines between these banners
                                        (0137)    ;---------------------------------------------------
                                        (0138)    
                                        (0139)    ;PRESERVE_CPU_CONTEXT
                                        (0140)    ;lcall _My_C_Function
                                        (0141)    ;RESTORE_CPU_CONTEXT
                                        (0142)    
                                        (0143)    ;---------------------------------------------------
                                        (0144)    ; Insert a lcall to a C function above this banner
                                        (0145)    ; and un-comment the lines between these banners
                                        (0146)    ;---------------------------------------------------
                                        (0147)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0148) 
1759: 7E       RETI                     (0149)    reti
                                        (0150) 
                                        (0151)  USBUART_1_EP3_ISR:
                                        (0152) _USBUART_1_EP3_ISR:
                                        (0153) 
175A: 55 25 01 MOV   [0x25],0x1         (0154)    mov  [USBUART_1_EndpointAPIStatus + 3], EVENT_PENDING
                                        (0155)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0156)    ;---------------------------------------------------
                                        (0157)    ; Insert your custom assembly code below this banner
                                        (0158)    ;---------------------------------------------------
                                        (0159)    ;   NOTE: interrupt service routines must preserve
                                        (0160)    ;   the values of the A and X CPU registers.
                                        (0161)    
                                        (0162)    ;---------------------------------------------------
                                        (0163)    ; Insert your custom assembly code above this banner
                                        (0164)    ;---------------------------------------------------
                                        (0165)    
                                        (0166)    ;---------------------------------------------------
                                        (0167)    ; Insert a lcall to a C function below this banner
                                        (0168)    ; and un-comment the lines between these banners
                                        (0169)    ;---------------------------------------------------
                                        (0170)    
                                        (0171)    ;PRESERVE_CPU_CONTEXT
                                        (0172)    ;lcall _My_C_Function
                                        (0173)    ;RESTORE_CPU_CONTEXT
                                        (0174)    
                                        (0175)    ;---------------------------------------------------
                                        (0176)    ; Insert a lcall to a C function above this banner
                                        (0177)    ; and un-comment the lines between these banners
                                        (0178)    ;---------------------------------------------------
                                        (0179)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0180) 
175D: 7E       RETI                     (0181)    reti
                                        (0182) 
                                        (0183)  USBUART_1_EP4_ISR:
                                        (0184) _USBUART_1_EP4_ISR:
                                        (0185) 
175E: 55 26 01 MOV   [0x26],0x1         (0186)    mov  [USBUART_1_EndpointAPIStatus + 4], EVENT_PENDING
                                        (0187)    ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
                                        (0188)    ;---------------------------------------------------
                                        (0189)    ; Insert your custom assembly code below this banner
                                        (0190)    ;---------------------------------------------------
                                        (0191)    ;   NOTE: interrupt service routines must preserve
                                        (0192)    ;   the values of the A and X CPU registers.
                                        (0193)    
                                        (0194)    ;---------------------------------------------------
                                        (0195)    ; Insert your custom assembly code above this banner
                                        (0196)    ;---------------------------------------------------
                                        (0197)    
                                        (0198)    ;---------------------------------------------------
                                        (0199)    ; Insert a lcall to a C function below this banner
                                        (0200)    ; and un-comment the lines between these banners
                                        (0201)    ;---------------------------------------------------
                                        (0202)    
                                        (0203)    ;PRESERVE_CPU_CONTEXT
                                        (0204)    ;lcall _My_C_Function
                                        (0205)    ;RESTORE_CPU_CONTEXT
                                        (0206)    
                                        (0207)    ;---------------------------------------------------
                                        (0208)    ; Insert a lcall to a C function above this banner
                                        (0209)    ; and un-comment the lines between these banners
                                        (0210)    ;---------------------------------------------------
                                        (0211)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0212) 
1761: 7E       RETI                     (0213)    reti
                                        (0214) 
                                        (0215)  USBUART_1_RESET_ISR:
                                        (0216) _USBUART_1_RESET_ISR:
1762: 08       PUSH  A                  (0217)    push    A
1763: 50 00    MOV   A,0x0              (0218)    mov     A, 0
1765: 53 01    MOV   [0x1],A            (0219)    mov     [USBUART_1_Configuration], A
1767: 53 02    MOV   [0x2],A            (0220)    mov     [USBUART_1_DeviceStatus], A
1769: 53 03    MOV   [0x3],A            (0221)    mov     [USBUART_1_InterfaceSetting], A
176B: 53 05    MOV   [0x5],A            (0222)    mov     [USBUART_1_EndpointStatus], A
176D: 53 0B    MOV   [0xB],A            (0223)    mov     [USBUART_1_TransferType], A
176F: 53 1E    MOV   [0x1E],A           (0224)    mov     [USBUART_1_fDataPending], A
1771: 62 56 03 MOV   REG[0x56],0x3      (0225)    mov     reg[USBUART_1_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
1774: 71 10    OR    F,0x10             
                                        (0226)    M8C_SetBank1
1776: 60 C4    MOV   REG[0xC4],A        (0227)    mov     reg[USBUART_1_EP1MODE], A
1778: 60 C5    MOV   REG[0xC5],A        (0228)    mov     reg[USBUART_1_EP2MODE], A
177A: 60 C6    MOV   REG[0xC6],A        (0229)    mov     reg[USBUART_1_EP3MODE], A
177C: 60 C7    MOV   REG[0xC7],A        (0230)    mov     reg[USBUART_1_EP4MODE], A
177E: 70 EF    AND   F,0xEF             
                                        (0231)    M8C_SetBank0
1780: 53 1D    MOV   [0x1D],A           (0232)    mov     [USBUART_1_EPDataToggle], A   ; Clear all EP data toggles
                                        (0233) 
                                        (0234) ;   mov     X, USB_MAX_EP_NUMBER       ; Set up loop to clear all of the endpoint data items
                                        (0235) ;.loop:
                                        (0236) ;   mov     [X + USBUART_1_EPDataToggle], 0  ; Or in the toggle
                                        (0237) ;   dec     X                          ; Are we done?
                                        (0238) ;   jnz     .loop                      ; Jump to do another endpoint
                                        (0239) 
1782: 62 4A 80 MOV   REG[0x4A],0x80     (0240)    mov     reg[USBUART_1_ADDR], USB_ADDR_ENABLE ; Enable Address 0
                                        (0241) 
                                        (0242)    ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
                                        (0243)    ;---------------------------------------------------
                                        (0244)    ; Insert your custom assembly code below this banner
                                        (0245)    ;---------------------------------------------------
                                        (0246)    ;   NOTE: interrupt service routines must preserve
                                        (0247)    ;   the values of the A and X CPU registers.
                                        (0248)    
                                        (0249)    ;---------------------------------------------------
                                        (0250)    ; Insert your custom assembly code above this banner
                                        (0251)    ;---------------------------------------------------
                                        (0252)    
                                        (0253)    ;---------------------------------------------------
                                        (0254)    ; Insert a lcall to a C function below this banner
                                        (0255)    ; and un-comment the lines between these banners
                                        (0256)    ;---------------------------------------------------
                                        (0257)    
                                        (0258)    ;PRESERVE_CPU_CONTEXT
                                        (0259)    ;lcall _My_C_Function
                                        (0260)    ;RESTORE_CPU_CONTEXT
                                        (0261)    
                                        (0262)    ;---------------------------------------------------
                                        (0263)    ; Insert a lcall to a C function above this banner
                                        (0264)    ; and un-comment the lines between these banners
                                        (0265)    ;---------------------------------------------------
                                        (0266)    ;@PSoC_UserCode_END@ (Do not change this line.)
1785: 18       POP   A                  (0267)    pop  A
1786: 7E       RETI                     (0268)    reti
                                        (0269) 
                                        (0270)  USBUART_1_SOF_ISR:
                                        (0271) _USBUART_1_SOF_ISR:
                                        (0272) 
                                        (0273)    ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
                                        (0274)    ;---------------------------------------------------
                                        (0275)    ; Insert your custom assembly code below this banner
                                        (0276)    ;---------------------------------------------------
                                        (0277)    ;   NOTE: interrupt service routines must preserve
                                        (0278)    ;   the values of the A and X CPU registers.
                                        (0279)    
                                        (0280)    ;---------------------------------------------------
                                        (0281)    ; Insert your custom assembly code above this banner
                                        (0282)    ;---------------------------------------------------
                                        (0283)    
                                        (0284)    ;---------------------------------------------------
                                        (0285)    ; Insert a lcall to a C function below this banner
                                        (0286)    ; and un-comment the lines between these banners
                                        (0287)    ;---------------------------------------------------
                                        (0288)    
                                        (0289)    ;PRESERVE_CPU_CONTEXT
                                        (0290)    ;lcall _My_C_Function
                                        (0291)    ;RESTORE_CPU_CONTEXT
                                        (0292)    
                                        (0293)    ;---------------------------------------------------
                                        (0294)    ; Insert a lcall to a C function above this banner
                                        (0295)    ; and un-comment the lines between these banners
                                        (0296)    ;---------------------------------------------------
                                        (0297)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0298) 
1787: 7E       RETI                     (0299)    reti
                                        (0300) 
                                        (0301)  USBUART_1_WAKEUP_ISR:
                                        (0302) _USBUART_1_WAKEUP_ISR:
                                        (0303) 
                                        (0304)    ;@PSoC_UserCode_BODY_7@ (Do not change this line.)
                                        (0305)    ;---------------------------------------------------
                                        (0306)    ; Insert your custom assembly code below this banner
                                        (0307)    ;---------------------------------------------------
                                        (0308)    ;   NOTE: interrupt service routines must preserve
                                        (0309)    ;   the values of the A and X CPU registers.
                                        (0310)    
                                        (0311)    ;---------------------------------------------------
                                        (0312)    ; Insert your custom assembly code above this banner
                                        (0313)    ;---------------------------------------------------
                                        (0314)    
                                        (0315)    ;---------------------------------------------------
                                        (0316)    ; Insert a lcall to a C function below this banner
                                        (0317)    ; and un-comment the lines between these banners
                                        (0318)    ;---------------------------------------------------
                                        (0319)    
                                        (0320)    ;PRESERVE_CPU_CONTEXT
                                        (0321)    ;lcall _My_C_Function
                                        (0322)    ;RESTORE_CPU_CONTEXT
                                        (0323)    
                                        (0324)    ;---------------------------------------------------
                                        (0325)    ; Insert a lcall to a C function above this banner
                                        (0326)    ; and un-comment the lines between these banners
                                        (0327)    ;---------------------------------------------------
                                        (0328)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0329) 
1788: 7E       RETI                     (0330)    reti
                                        (0331) 
                                        (0332) ; End of File USBUART_1.asm
